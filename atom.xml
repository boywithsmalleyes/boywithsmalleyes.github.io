<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶白</title>
  <icon>https://www.gravatar.com/avatar/f27b936c2ac428d82177b6d3626c8e3a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaoman.ren/"/>
  <updated>2021-01-04T11:49:19.954Z</updated>
  <id>http://xiaoman.ren/</id>
  
  <author>
    <name>茶白</name>
    <email>zhuangbudong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler 消息机制</title>
    <link href="http://xiaoman.ren/2021/01/04/Handler-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaoman.ren/2021/01/04/Handler-消息机制/</id>
    <published>2021-01-04T11:47:24.000Z</published>
    <updated>2021-01-04T11:49:19.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler-消息机制"><a href="#Handler-消息机制" class="headerlink" title="Handler 消息机制"></a>Handler 消息机制</h1><p>Handler 消息机制，在整个 Android 系统中，有着很重要的地位。</p><p>他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.</p><p>本文旨在对源码进行预览分析。</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 <code>Handler</code> 机制的核心秘密。</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true" alt="Handler 类图"></p><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a><strong>类图分析</strong></h4><p>从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类</p><p><strong>Message：</strong> 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。</p><p><strong>Handler:</strong>     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用</p><p><strong>Looper:</strong>       这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的<em>大心脏</em></p><h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><p>看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 <code>main()</code> 方法中。</p><p>在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  <code>application</code> 和 <code>activity</code> 的工作,接下来我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                    args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                                            LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码，我主要分析 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code></p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><p>这里的标题虽然不是 <code>prepareMainLooper()</code>  的一个主要原因是他们的核心内容是一样的，只不过，<code>prepareMainLooper()</code> 是系统帮我们创建了要给不可退出的<code>Looper</code>，而 <code>prepare()</code> 方法创建的 <code>Looper</code> 是可以退出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">      * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">      * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>说到 <code>Looper</code> 的创建工作，这里就需要讲一下 <code>ThreadLocal</code> ， 它的意思是<strong>帮助我们在自己线程中保存一份它自己的本地变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。</p><p>面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h3><p>继续看源码，<code>Looper.loop();</code> 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行</p><p>这部分的源码比较长，捡主要的看和说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//..............</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...............</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread 中的 <code>main()</code> 方法，在最后一行，执行了我们的 <code>Looper.loop()</code> 方法， 进入后，我们可以看到 <code>loop()</code> 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 <code>prepareMainLooper()</code>  ，这也是系统帮我们创建的一个主线程<code>main</code> 。</p><p>接下来就慢慢分析一下 <code>loop</code> 都做了什么事情</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true" alt="looper.loop()"></p><p>从流程图上，我们简述了一下 <code>loop()</code> 方法，都做了些什么事情，下面就展开讲都做了什么</p><ol><li>首先获取当前线程的 looper 对象，如果不存在，则抛出异常</li><li>接着获取当前 Looper 绑定的消息队列<code>MessageQueue</code></li><li>进入循环，开始获取消息 <code>queue.next()</code></li><li>调用 <code>msg.target.dispathMessage(msg)</code> 分发消息</li><li>msg.recycleUnchecked()</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Handler-消息机制&quot;&gt;&lt;a href=&quot;#Handler-消息机制&quot; class=&quot;headerlink&quot; title=&quot;Handler 消息机制&quot;&gt;&lt;/a&gt;Handler 消息机制&lt;/h1&gt;&lt;p&gt;Handler 消息机制，在整个 Android 系统中，有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 中堆和栈的区别</title>
    <link href="http://xiaoman.ren/2021/01/04/Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xiaoman.ren/2021/01/04/Java-中堆和栈的区别/</id>
    <published>2021-01-04T11:46:46.000Z</published>
    <updated>2021-01-04T11:46:59.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-中堆和栈的区别"><a href="#Java-中堆和栈的区别" class="headerlink" title="Java 中堆和栈的区别"></a>Java 中堆和栈的区别</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Java 中堆和栈的区别具体由一下几点</p><h3 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h3><p><strong>栈：</strong> 用来存储局部变量和方法调用</p><p><strong>堆： </strong> 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。</p><h3 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h3><p><strong>栈：</strong> 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存</p><p><strong>堆： </strong> 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。</p><h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><p>如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 <code>java.lang.StackOverFlowError</code> </p><p>如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 <code>Java.lang.OutOfMemoryError</code></p><h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 <code>StackOverFlowError</code> 问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-中堆和栈的区别&quot;&gt;&lt;a href=&quot;#Java-中堆和栈的区别&quot; class=&quot;headerlink&quot; title=&quot;Java 中堆和栈的区别&quot;&gt;&lt;/a&gt;Java 中堆和栈的区别&lt;/h1&gt;&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 枚举</title>
    <link href="http://xiaoman.ren/2021/01/04/Java-%E6%9E%9A%E4%B8%BE/"/>
    <id>http://xiaoman.ren/2021/01/04/Java-枚举/</id>
    <published>2021-01-04T11:46:11.000Z</published>
    <updated>2021-01-04T11:46:22.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a>Java 枚举</h1><p>枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。</p><p><strong>使用<code>enum</code> 来标识枚举类</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>必须使用 <code>enum</code> 关键字声明</li><li>除了初始化，不能通过任何方式手动创建枚举实例</li><li>不可以被继承</li><li>JVM 保证线程安全</li><li>无法继承其他类</li></ol><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><strong>常量枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// RED</span></span><br></pre></td></tr></table></figure><p>上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。</p><p>通过字节码分析 <code>Color.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final 修饰，不能被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 声明的变量，都对应一个枚举实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回原数组的副本，防止数组的修改，引起内部 values 值的改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color[])$VALUE.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照名字获取枚举实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(com/example/Color, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态初始化</span></span><br><span class="line">    <span class="comment">// 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RED = <span class="keyword">new</span> Color(<span class="string">"RED"</span>, <span class="number">0</span>);</span><br><span class="line">        GREEN = <span class="keyword">new</span> Color(<span class="string">"GREEN"</span>, <span class="number">1</span>);</span><br><span class="line">        BLUE =  <span class="keyword">new</span> Color(<span class="string">"BLUE"</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</span><br><span class="line">            RED, GREEN, BLUE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的类中可以看出，<code>enum</code> 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 <code>jvm</code> 中运行的代码</p><p><code>Enum</code> 类接受一个继承自 <code>Enum</code> 的泛型（反编译阶段，<code>Java</code>中没有具体体现泛型，是应为泛型在编译阶段就会被 <code>JVM</code> 进行泛型擦除，替换为具体实现）</p><p>从枚举类以及反编译出来的字节码可以看出，枚举类第一个 <code>;</code> 前的变量，都会在字节码中体现为一个 <code>Color</code> 实例，且在 <code>clinit</code> 静态代码块中进行初始化。而静态块在类加载阶段，<code>JVM</code> 会保证枚举对象的线程安全。</p><p>生成的 <code>$VALUES[]</code> 可通过 <code>values()</code> 方法被外部获取实例。</p><h2 id="枚举-Enum-类分析"><a href="#枚举-Enum-类分析" class="headerlink" title="枚举 Enum 类分析"></a>枚举 Enum 类分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != var1.getClass() &amp;&amp; <span class="keyword">this</span>.getDeclaringClass() != var1.getDeclaringClass()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ordinal - var1.ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Enum</code> 类实现了 <code>Comparable</code> 接口，表明它是支持排序的，实现 <code>compareTo</code> ，方法定义为 <code>final</code> 且实现以来 <code>ordinal</code> 字段也是 <code>final</code> 类型，说明只能依据 <code>ordinal</code> 排序，排序规则不可变.</p><p><strong>ordinal:</strong> 表示枚举的顺序，从 <code>Color</code> 类中可以看出他是从 0 开始自然顺序增长，且其值是 <code>final</code> 类型，外部无法改变。</p><p><strong>name:</strong> 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）</p><p><strong>equals():</strong>  使用 <code>==</code> 判断两个枚举是否相等</p><h2 id="每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的"><a href="#每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的" class="headerlink" title="每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的"></a>每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的</h2><p>枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 <code>JVM</code> 中有且只有一个对应的实例</p><p><em>为达到这种效果，枚举通过下面的方式来完成</em></p><ol><li><p>类加载时创建，保证线程安全</p><p>枚举对象在静态块中创建，由类加载时进行初始化，<code>JVM</code> 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例</p></li><li><p>对序列化进行特殊处理，防止反序列化时创建对象</p><p>一旦实现 <code>Serializable</code> 接口之后，反序列化时每次调用 <code>readObject()</code> 方法返回的都是一个新创建出来的对象</p><p>而枚举在序列化时，<code>Java</code> 仅仅是将枚举对象的 <code>name</code> 属性输出到结果中，反序列化时则是通过枚举的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; var0, String var1)</span> </span>&#123;</span><br><span class="line">        Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No enum constant "</span> + var0.getCanonicalName() + <span class="string">"."</span> + var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>私有构造函数，无法正常 new 出对象</p></li><li><p>无法通过 <code>clone()</code> 方法， 克隆对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无法通过反射的方式创建枚举对象</p><p>枚举类型在 <code>JVM</code> 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 <code>Cannot reflectively create enum objects</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reflectTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 获取类对象</span></span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"com.example.Color"</span>);</span><br><span class="line">    <span class="comment">// 获取构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 设置访问权限</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">    Object refObj = constructor.newInstance(<span class="string">"name"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="keyword">enum</span> objects</span><br></pre></td></tr></table></figure></li></ol><h2 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h2><h3 id="枚举与单例模式"><a href="#枚举与单例模式" class="headerlink" title="枚举与单例模式"></a>枚举与单例模式</h3><p>传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// todo...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。</p><p>在 <code>Android</code> 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 <strong>双重检查锁</strong>，<strong>静态内部类</strong> 的方式实现单例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-枚举&quot;&gt;&lt;a href=&quot;#Java-枚举&quot; class=&quot;headerlink&quot; title=&quot;Java 枚举&quot;&gt;&lt;/a&gt;Java 枚举&lt;/h1&gt;&lt;p&gt;枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="http://xiaoman.ren/2021/01/04/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://xiaoman.ren/2021/01/04/阻塞队列/</id>
    <published>2021-01-04T11:45:46.000Z</published>
    <updated>2021-01-04T11:45:56.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p><code>BlockingQueue</code> 是一个支持两个附加操作的队列。</p><p>在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。</p><p>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p><ul><li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue: 一个使用优先级排序的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</li></ul><h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p>使用<strong>通知模式</strong>实现</p><p>所谓 <strong>通知模式</strong> 就是当生产者往<strong><code>满的队列</code></strong>里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p><strong>ArrayBlockingQueue：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(count == items.length) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty = await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 <code>LockSupport.park(this)</code>  来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaitting(node)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123;</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(node.nextWaiter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(interruptMode != <span class="number">0</span>) &#123;</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阻塞队列&quot;&gt;&lt;a href=&quot;#阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列&quot;&gt;&lt;/a&gt;阻塞队列&lt;/h1&gt;&lt;h2 id=&quot;什么是阻塞队列&quot;&gt;&lt;a href=&quot;#什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Room</title>
    <link href="http://xiaoman.ren/2021/01/04/Android-Room/"/>
    <id>http://xiaoman.ren/2021/01/04/Android-Room/</id>
    <published>2021-01-04T11:44:57.000Z</published>
    <updated>2021-01-04T11:45:12.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Room"><a href="#Android-Room" class="headerlink" title="Android Room"></a>Android Room</h1><p><a href="https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn" target="_blank" rel="noopener">翻译自官网文档</a></p><p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库</p><ul><li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li><li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li><li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: User.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">// Room 请求 set 和 get 方法去访问数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: UserDao.java</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select * from user"</span>) </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">loadAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select * from user where uid in (:userIds)"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">loadAllByUserId</span><span class="params">(<span class="keyword">int</span>... userIds)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select * from user where name like :first and last_name like :last limit 1"</span>)</span><br><span class="line">    <span class="function">User <span class="title">loadOneByNameAndLastName</span><span class="params">(String first, String last)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertAll</span><span class="params">(User... users)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: AppDatabse.java</span></span><br><span class="line"><span class="meta">@Database</span>(entities = &#123;User.java&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 AppDatabase 实例</span></span><br><span class="line">AppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, <span class="string">"database_name"</span>).build();</span><br></pre></td></tr></table></figure><p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p><p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p><p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData 会自动分发数据表的改变</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"Select * from user order by name limit 5"</span>) </span><br><span class="line"><span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; loadFirstFiveUsers();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Room&quot;&gt;&lt;a href=&quot;#Android-Room&quot; class=&quot;headerlink&quot; title=&quot;Android Room&quot;&gt;&lt;/a&gt;Android Room&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.and
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程-调度器</title>
    <link href="http://xiaoman.ren/2021/01/04/%E5%8D%8F%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>http://xiaoman.ren/2021/01/04/协程-调度器/</id>
    <published>2021-01-04T11:44:20.000Z</published>
    <updated>2021-01-04T11:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><p><img src="https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp" alt="img"></p><h2 id="协程上下文（CoroutineContext）"><a href="#协程上下文（CoroutineContext）" class="headerlink" title="协程上下文（CoroutineContext）"></a>协程上下文（CoroutineContext）</h2><p>调度器本质上就是协程上下文的实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E: Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>:E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial:  <span class="type">R</span>, operation:(<span class="type">R</span>, Element)</span></span> -&gt; R):R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CorountineContext = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E: Element</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，上下文就是一个以 <code>key</code> 为索引的  <code>List</code> </p><p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code> ， 每一个 <code>Element</code> 都有一个 <code>Key</code> ，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code>  的子接口，因此也可以作为集合出现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedContext</span> </span>(</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> element: Element) : CoroutineContext, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CombinedContext</code> 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的<code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 <code>key</code> 来查找</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch&#123;</span><br><span class="line">        println(coroutineContext[Job]) <span class="comment">// “coroutine#1: StandaloneCoroutine&#123;Active&#125;@1ff5025</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(coroutineContext[Job]) <span class="comment">// null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Key for [job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key: CoroutineContext.Key&lt;Job&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿照<code>Thread.currentThread()</code> 来获取当前 <code>Job</code> 的方法 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Job.Key.<span class="title">currentJob</span><span class="params">()</span></span> = coroutineContext[Job]</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(Job.currentJob())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log(Job.currentJob())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取协程名字</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(CoroutineName(<span class="string">"Hello"</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果有多个上下文，需要添加 <code>+</code> 就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatcher.Main + CoroutineName(<span class="string">"Hello"</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterception</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key: CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，</p><p>协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的<code>Continuation</code>，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。</p><p>我们可以自己定义一个拦截器放到我们协程的上下问中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuationInterceptor</span>: <span class="type">ContinuationInterceptor &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation:<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCOntinuation</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = continuation.context</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result:<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        log(<span class="string">"&lt;MyContinuation&gt;<span class="variable">$result</span>"</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> job = async &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> result = job.await()</span><br><span class="line">        log(<span class="string">"5.<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>launch</code> 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用<code>async</code> 启动了一个协程，<code>async</code> 和 <code>launch</code>从功能上是同等类型的函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果。可以通过 <code>await</code> 方法获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[main] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[main] 1</span><br><span class="line">[main] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[main] 2</span><br><span class="line">[main] 4</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello)</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 5.Hello</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;调度器&quot;&gt;&lt;a href=&quot;#调度器&quot; class=&quot;headerlink&quot; title=&quot;调度器&quot;&gt;&lt;/a&gt;调度器&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/18062676-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程-启动</title>
    <link href="http://xiaoman.ren/2021/01/04/%E5%8D%8F%E7%A8%8B-%E5%90%AF%E5%8A%A8/"/>
    <id>http://xiaoman.ren/2021/01/04/协程-启动/</id>
    <published>2021-01-04T11:43:52.000Z</published>
    <updated>2021-01-04T11:44:06.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程-启动"><a href="#协程-启动" class="headerlink" title="协程-启动"></a>协程-启动</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = <span class="keyword">object</span> : Thread() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run()</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>上面是线程的启动方法，通常还会忘记去写 <code>start()</code> ，那再 kotlin 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread(start = <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//do you wang</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start()</code> 方法是默认被开启自动会执行的，为我们省去了很多麻煩</p><h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">// do you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineStart</span> </span>&#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LAZY,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    ATOMIC，</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    UNDISPATCHED；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>DEFAULT</td><td>立即执行协程体</td></tr><tr><td>ATOMIC</td><td>立即执行协程体，但在开始运行之前无法取消</td></tr><tr><td>UNDISPATCHED</td><td>立即在当前线程执行协程体，直到第一个 suspend 调用</td></tr><tr><td>LAZY</td><td>只有在需要的情况下运行</td></tr></tbody></table><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>四种启动模式中，常用的其实是<code>DEFAULT</code> 和 <code>LAZY</code></p><p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch&#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br><span class="line">[main] 4</span><br></pre></td></tr></table></figure><p>它取决于 CPU 对于当前线程和后台线程的调度顺序</p><h3 id="LAZY"><a href="#LAZY" class="headerlink" title="LAZY"></a>LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。<code>launch</code> 后会返回一个 <code>job</code> 实例，因此我们可以通过 <code>job</code> 来实现</p><ul><li>调用 <code>Job.start()</code> 主动触发协程的调度</li><li>调用 <code>Job.join()</code> 隐式的触发协程的调度</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.start()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>其输出结果可能为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[main] 4</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure><p>运气好话，2 也可能在 4  的前面，而对于 <code>join()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>因为要等待协程执行完毕，因此数据结果一定是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br><span class="line">[main] 4</span><br></pre></td></tr></table></figure><h3 id="ATOMIC"><a href="#ATOMIC" class="headerlink" title="ATOMIC"></a>ATOMIC</h3><p><code>ATOMIC</code> 只有涉及到 <code>cancel</code> 的时候才有意义， <code>cancel</code> 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 <code>cancel</code> 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们创建写成后立即 <code>cancel</code> 但由于 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说</p><p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时，如果 <code>cancel</code> 就已经调用，那么协程就会被直接 <code>cancel</code> 而不会有任何调度。</p><blockquote><p>需要注意， <code>cancel</code> 调用一定会将 job 的状态设置为 cancelling, 只不过 <code>ATOMIC</code> 模式的协程在启动时无视了这一状态。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p>2 和 3 之间加了一个 <code>delay</code> ，<code>delay</code> 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 <code>ATOMIC</code> 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 <code>suspend</code> 函数，此时程序迎来了第一个挂起点，恰好 <code>delay</code> 是支持 <code>cancel</code> 的，因此后面的 3 将不会打印。</p><h4 id="UNDISPATCHED"><a href="#UNDISPATCHED" class="headerlink" title="UNDISPATCHED"></a>UNDISPATCHED</h4><p>协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 <code>ATOMIC</code> 很像，不同在于 <code>DISPATCHED</code> 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协程-启动&quot;&gt;&lt;a href=&quot;#协程-启动&quot; class=&quot;headerlink&quot; title=&quot;协程-启动&quot;&gt;&lt;/a&gt;协程-启动&lt;/h1&gt;&lt;h2 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerlink&quot; title=&quot;T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程-入门</title>
    <link href="http://xiaoman.ren/2021/01/04/%E5%8D%8F%E7%A8%8B-%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaoman.ren/2021/01/04/协程-入门/</id>
    <published>2021-01-04T11:43:24.000Z</published>
    <updated>2021-01-04T11:43:38.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程入门"><a href="#协程入门" class="headerlink" title="协程入门"></a>协程入门</h1><h2 id="通过-Retrofit-请求"><a href="#通过-Retrofit-请求" class="headerlink" title="通过 Retrofit 请求"></a>通过 Retrofit 请求</h2><p>通过 <code>Retrofit</code> 发送一个网络请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login:<span class="type">String</span>)</span></span>:Call&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id:String, <span class="keyword">val</span> name:String, <span class="keyword">val</span> url:String)</span><br></pre></td></tr></table></figure><p><code>Retrofit</code> 初始化如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> githubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retorfit = retrofit2.Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https//api.github.com"</span>)</span><br><span class="line">        .addConverterFacetory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    retrofit.create(GitHUbServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起网络请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">githubServiceApi.getUser(<span class="string">"small"</span>)</span><br><span class="line">.enqueue(<span class="keyword">object</span>: Callback&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        handler.post&#123;showError(t)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        handler.post&#123;</span><br><span class="line">            response.body()?.let(::showUser) ?: showError(NullPointerException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="改造为携程"><a href="#改造为携程" class="headerlink" title="改造为携程"></a>改造为携程</h2><p>对于 <code>Retrofit</code> 改造为协程的方式有两种，分别通过 <code>CallAdapter</code> 和 <code>suspend</code> 函数</p><h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>该方法的本质是让接口的方法返回一个协程的 <code>Job</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span>login:<span class="type">String</span>)</span></span>:Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Deferred 是 Job 的子接口</p></blockquote><p>同时需要为 <code>Retrofit</code> 添加对 <code>Deferred</code> 的支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></span><br></pre></td></tr></table></figure><p>对构造 <code>Retorfit</code> 的实例添加</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> githubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retorfit = retrofit2.Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https//api.github.com"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(CoroutineCallAdapterFactroy())</span><br><span class="line">        .build()</span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的修改，那么我们的请求就可以这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        showUser(githubServiceApi.getUser(<span class="string">"small"</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        shwoError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>  我们首先通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个: 协程上下文、协程启动模式、协程体</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CorountineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">context:<span class="type">CorountineContext</span> = EmptyCouroutineContext,<span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFGAULT, <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CorountineScope</span>.()</span></span> -&gt; UNit <span class="comment">// 协程体</span></span><br><span class="line">) :Job</span><br></pre></td></tr></table></figure><p><strong>启动模式</strong> 不是一个复杂的概念，默认直接俄允许调度执行</p><p><strong>上下文</strong>可以有很多作用，包括<em>携带参数</em>、<em>拦截协程执行</em>等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保<code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己再 <code>launch</code> 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）</p><p>换句话说，在例子当中的整个 <code>launch</code> 内部，你看到的代码都是运行在UI线程中的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 <code>getUser</code> 返回了要给 <code>Deferred</code> 类型，他的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么<code>await</code> 不会阻塞 UI 线程嘛？</p><p>当然不会。不然 <code>Deferred</code> 于 <code>Future</code>  又有上面区别的，这里<code>await</code>  很可疑。因为实际上是要给 <code>suspend</code> 函数。整个函数只能在协程体或者其他 <code>suspend</code> 函数内部被调用，就像是回调的语法糖一样，通过一个叫 <code>Continuation</code> 的接口来实现返回结果<code></code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.3"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context:CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result:<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context:CorouineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是要给回调，有结果正常返回， <code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常。</p><p>因此，请求的代码执行流程本质上是一个异步回调</p><p>而之所以可以看起来是同步的，那就是编译器的黑魔法了</p><p>在虚拟机上 <code>await</code> 函数的真实样子是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object</span><br></pre></td></tr></table></figure><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 这么一个函数，所以前面的代码可以理解为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是正确代码，仅用来理解协程使用</span></span><br><span class="line">GlobalScope.launch(Dispathcers.Main) &#123;</span><br><span class="line">    githubServiceApi.getUser(<span class="string">"small"</span>).await(<span class="keyword">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            showUser(value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            showError(exception)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>await</code> 当中大致就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是正确代码，仅用来理解协程使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">awiat</span><span class="params">(continuation:<span class="type">Continuation</span>&lt;<span class="type">user</span>&gt;)</span></span>:Any&#123;</span><br><span class="line">    ...<span class="comment">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = ....<span class="comment">// 这里执行任务</span></span><br><span class="line">        handler.post &#123;</span><br><span class="line">            continuation.resume(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: Exception) &#123;</span><br><span class="line">        handler.post&#123;continuation.resumeWithException(e)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从运行机制上来讲，协程和回调没有本质的区别</p></blockquote><h3 id="suspend-方式"><a href="#suspend-方式" class="headerlink" title="suspend  方式"></a>suspend  方式</h3><p><code>suspend</code> 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用</p><blockquote><p>Retrofit 在 release 2.5.0 之后才会支持 suspend 函数</p></blockquote><p>首先修改一下接口方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span>login:<span class="type">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure><p>这种情况下， <code>Retrofit</code> 会根据接口方法的生命来构造<code>Continuation</code> ，并且在内部封装了一个 <code>Call</code> 的异步请求(使用 <code>enqueue</code>) ，进而得到 User 实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(githubServiceApi.getUser(<span class="string">"small"</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程到底是什么"><a href="#协程到底是什么" class="headerlink" title="协程到底是什么"></a>协程到底是什么</h2><p>以前我们使用 Java 进行开发的时候，经常会遇到 <em>回调地域</em> ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。</p><p>而 <strong>协程</strong> 可以帮我们优雅的处理掉这些</p><p>协程本身是一个脱离语言实现的概念。简单来说就是：</p><p>协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>:<span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下 <strong>Thread</strong> 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协程入门&quot;&gt;&lt;a href=&quot;#协程入门&quot; class=&quot;headerlink&quot; title=&quot;协程入门&quot;&gt;&lt;/a&gt;协程入门&lt;/h1&gt;&lt;h2 id=&quot;通过-Retrofit-请求&quot;&gt;&lt;a href=&quot;#通过-Retrofit-请求&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://xiaoman.ren/2021/01/04/%E5%8D%8F%E7%A8%8B/"/>
    <id>http://xiaoman.ren/2021/01/04/协程/</id>
    <published>2021-01-04T11:39:26.000Z</published>
    <updated>2021-01-04T11:40:25.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;<span class="comment">// 后台启动一个新的协程并继续， launch 协程的构建器</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 非阻塞的等待1s，</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 延时后，输出 </span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello"</span>) <span class="comment">// 协程已再等待时，主线程还在继续</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// 阻塞主线程 2s 保证， JVM 存活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程是轻量级的线程。 <code>CoroutineScope</code> 通常与 <code>launch</code> 协程构建器一起启动。</p><p><strong>GlobalScope</strong>： 意味着新协程的生命周期与应用程序的生命周期一致</p><p><code>delay</code> 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。</p><h2 id="桥接阻塞与非阻塞的世界"><a href="#桥接阻塞与非阻塞的世界" class="headerlink" title="桥接阻塞与非阻塞的世界"></a>桥接阻塞与非阻塞的世界</h2><p>使用<code>runBlocking</code> 协程构建器来阻塞，使用非阻塞函数<code>delay</code> 方便，不易与 <code>Thread.sleep()</code> 阻塞函数混淆</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"hello "</span>)</span><br><span class="line">    runBlocking&#123; <span class="comment">// 这个表达式阻塞了主线程</span></span><br><span class="line">        delay(<span class="number">2000L</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例，只使用了非阻塞函数 <code>delay</code>, 调用 <code>runBlocking</code> 的主线程会一直阻塞，直到 <code>runBlocking</code> 内部的协程执行完毕</p><p>还可以使用 <code>runBlocking</code> 包裹 main 函数来执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello "</span>)</span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runBlicking&lt;Unit&gt; {}</code> 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型</p><h2 id="等待一个作业"><a href="#等待一个作业" class="headerlink" title="等待一个作业"></a>等待一个作业</h2><p>延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// 启动一个新协程并持有这个作业的引用</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"hello "</span>)</span><br><span class="line">job.join()<span class="comment">// 等待直到子协程执行结束</span></span><br></pre></td></tr></table></figure><p>这里主协程与后台作业的持续时间没有任何关系了。</p><h2 id="结构化的并发"><a href="#结构化的并发" class="headerlink" title="结构化的并发"></a>结构化的并发</h2><p>当我们使用 <code>GlobalScope.launch</code> 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 <code>join</code> 很容易出错</p><p>结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 <code>GlobalScope</code> 中启动。</p><p>我们使用<code>runBlocking</code> 协程构建器将 <code>main</code> 函数转化为协程，包括 <code>runBlocking</code> 在内的每个协程构建器都将 <code>CoroutineScope</code> 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 <code>join</code> 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// 在 runBlocking 作用域中启动一个新的协程</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello, "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域构建"><a href="#作用域构建" class="headerlink" title="作用域构建"></a>作用域构建</h2><p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束</p><p><code>runBlocking</code> 与 <code>coroutineScope</code>  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 <code>runBlocking</code> 方法会<strong>阻塞</strong>当前线程来等待，而 <code>coroutineScope</code> 只会挂起，会释放底层线程用于其他用途。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> main = runBlocking &#123; // coroutine scope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">"Task from runBlocking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123;<span class="comment">// 创建一个作用域协程</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            println(<span class="string">"Task from nested launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">println(<span class="string">"Task from coroutine scope"</span>) <span class="comment">// 这一行会在内嵌 launch 之前输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Coroutine scope is over"</span>)    <span class="comment">// 这一行在内嵌 launch 执行完毕后输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h2><p>当将 <code>launch{}</code> 内部代码块提取到独立的函数体中时，需要 <code>suspend</code>  修饰新函数。这是一个挂起函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;doWorld()&#125;</span><br><span class="line">    println(<span class="string">"hello "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程很轻量"><a href="#协程很轻量" class="headerlink" title="协程很轻量"></a>协程很轻量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> main = runBlocking &#123;</span></span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            println(<span class="string">"."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10w 个协程，每个都数出一个点，如果尝试使用线程，会发生内存不足的情况</p><h2 id="全局协程像守护线程"><a href="#全局协程像守护线程" class="headerlink" title="全局协程像守护线程"></a>全局协程像守护线程</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt; </span><br><span class="line">println(<span class="string">"I`m sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">                  delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1399L</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lifecycle 源码分析</title>
    <link href="http://xiaoman.ren/2020/09/17/Lifecycle-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2020/09/17/Lifecycle-源码分析/</id>
    <published>2020-09-16T16:00:39.000Z</published>
    <updated>2020-09-16T16:37:02.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始是废话（翻译自源码）"><a href="#开始是废话（翻译自源码）" class="headerlink" title="开始是废话（翻译自源码）"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 </span></span><br><span class="line">Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME</span><br><span class="line"><span class="comment">// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。</span></span><br><span class="line">Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">DefaultLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStopped</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_CREATE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreated</span><span class="params">(LifecycleOwner source)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_ANY)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onAny</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p><h2 id="那我能做什么呢"><a href="#那我能做什么呢" class="headerlink" title="那我能做什么呢"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p><p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p><p>干货~~~来了</p><p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p><p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Lifecycle-UML"><a href="#Lifecycle-UML" class="headerlink" title="Lifecycle UML"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true" alt="Lifecycle UML"></p><p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p><p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p><h3 id="ComponentActivity-amp-ReportFragment"><a href="#ComponentActivity-amp-ReportFragment" class="headerlink" title="ComponentActivity &amp; ReportFragment"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><h4 id="ComponentActivity"><a href="#ComponentActivity" class="headerlink" title="ComponentActivity"></a><code>ComponentActivity</code></h4><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleOwner 接口，提供了一个 getLifecycle() 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComponentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lifecycle lifecycle = getLifecycle();</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"getLifecycle() returned null in ComponentActivity's "</span></span><br><span class="line">                                        + <span class="string">"constructor. Please make sure you are lazily constructing your Lifecycle "</span></span><br><span class="line">                                        + <span class="string">"in the first call to getLifecycle() rather than relying on field "</span></span><br><span class="line">                                        + <span class="string">"initialization."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">                    Window window = getWindow();</span><br><span class="line">                    <span class="keyword">final</span> View decor = window != <span class="keyword">null</span> ? window.peekDecorView() : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (decor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        decor.cancelPendingInputEvents();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">19</span> &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= <span class="number">23</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> ImmLeaksCleaner(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p><p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If your ComponentActivity is annotated with &#123;<span class="doctag">@link</span> ContentView&#125;, this will</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> #setContentView(int)&#125; for you.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">        setContentView(mContentLayoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p><p>别慌，进去看。</p><h4 id="ReportFragment"><a href="#ReportFragment" class="headerlink" title="ReportFragment"></a><code>ReportFragment</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">    <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p><p>按照 <code>Fragment</code> 的生命周期，我们继续看</p><h5 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a><code>dispatch()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatchStart(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatchResume(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">    mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p><h5 id="handleLifecycleEvent"><a href="#handleLifecycleEvent" class="headerlink" title="handleLifecycleEvent()"></a><code>handleLifecycleEvent()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p><p>你跑，那我就追！</p><h3 id="LifecycleRegister"><a href="#LifecycleRegister" class="headerlink" title="LifecycleRegister"></a><strong><code>LifecycleRegister</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current state and notifies the observers.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that if the &#123;<span class="doctag">@code</span> currentState&#125; is the same state as the last call to this method,</span></span><br><span class="line"><span class="comment">     * calling this method has no effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event The event that was received</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法，我们翻译下注释</p><blockquote><p>设置当前状态，并通知观察者</p><p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p></blockquote><h4 id="getStateAfter"><a href="#getStateAfter" class="headerlink" title="getStateAfter()"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p><p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync()"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">    <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"><span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line"><span class="comment">// so it doesn't have to take in account parents</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"LifecycleOwner of this LifecycleRegistry is already"</span></span><br><span class="line">                                        + <span class="string">"garbage collected. It is too late to change lifecycle state."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p><p>继续分析源码</p><p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p><p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p><h4 id="Lifecycle-State-Sequence"><a href="#Lifecycle-State-Sequence" class="headerlink" title="Lifecycle State Sequence"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_STOP;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_START;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true" alt="Lifecycle State Sequence"></p><p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p><h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a><code>dispatchEvent</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">        mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">        mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            Event event = downEvent(observer.mState);</span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p><p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p><h4 id="ReflectiveGenericLifecycleObserver"><a href="#ReflectiveGenericLifecycleObserver" class="headerlink" title="ReflectiveGenericLifecycleObserver"></a><code>ReflectiveGenericLifecycleObserver</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An internal implementation of &#123;<span class="doctag">@link</span> LifecycleObserver&#125; that relies on reflection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p><p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p><p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p><p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p><p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p><h4 id="reflect-invoke-method"><a href="#reflect-invoke-method" class="headerlink" title="reflect invoke method"></a><code>reflect invoke method</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">                mMethod.invoke(target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">                mMethod.invoke(target, source);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                mMethod.invoke(target, source, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to call observer method"</span>, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p><p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p><p>但是！！！！！！！！！！！！！！！！</p><p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p><h4 id="addObserver"><a href="#addObserver" class="headerlink" title="addObserver()"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p><p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p><p>我们这里要逐行清点</p><p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p><p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p><p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p><p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p><p>总结一下，分析源码我们从两方面入手</p><ol><li><p><code>addObserver()</code></p><p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p><ol><li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li><li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li><li>立即进行状态判断，决定是否处理生命周期变化</li></ol></li><li><p><code>ReportFragment</code></p><p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p></li><li><p><strong>反射</strong></p><p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p></li><li><p><code>sync()</code></p><p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;a href=&quot;#开始是废话（翻译自源码）&quot; class=&quot;headerlink&quot; title=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;/a&gt;开始是废话（翻译自源码）&lt;/h2&gt;&lt;p&gt;定义了一个 Android 生命周期的对象。 &lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;FragmentActivity&lt;/code&gt;类实现&lt;code&gt;LifecycleOwner&lt;/code&gt;接口， 并可以通过 &lt;code&gt;getLifecycle()&lt;/code&gt; 方法来访问生命周期。 我们也可以实现&lt;code&gt;LifecycleOwner&lt;/code&gt;在自己的类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView</title>
    <link href="http://xiaoman.ren/2020/07/09/RecyclerView/"/>
    <id>http://xiaoman.ren/2020/07/09/RecyclerView/</id>
    <published>2020-07-09T12:33:30.000Z</published>
    <updated>2020-07-09T12:36:43.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RechclerView-总结"><a href="#RechclerView-总结" class="headerlink" title="RechclerView 总结"></a>RechclerView 总结</h1><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true" alt="image-20200709164241306"></p><p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p><p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p><p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p><p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p><p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p><p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p><a id="more"></a><h2 id="RecyclerView-的绘制"><a href="#RecyclerView-的绘制" class="headerlink" title="RecyclerView 的绘制"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p><ul><li><p>自动测量原理：</p><p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p><p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p><p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p><ul><li>STEP_START</li><li>STEP_LAYOUT</li><li>STEP_ANIMATIONS</li></ul><p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p><ul><li>dispatchLayoutStep1:  负责记录状态</li><li>dispatchLayoutStep2：负责布局</li><li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li></ul><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mAdapterHelper.hasUpdates() </span><br><span class="line">              || mLayout.getWidth() != getWidth() </span><br><span class="line">              || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// first 2 steps are done in onMeasure but looks like we have to run again due to changed size</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p><h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p><h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    </span><br><span class="line">    mState.mLayoutStep = State.STATE_ANIMATIONS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!mAnchorInfo.mValid </span><br><span class="line">      || mPendingScrollPosition != NO_POSITION </span><br><span class="line">      || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTIONTAIL</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayouStateToFillEnd(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  流程很负责，大致流程如下</p><ul><li>找到 anchor点</li><li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li><li><p>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</p><p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p><p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">        recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="keyword">while</span>((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start-layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>recycleViewsFromStart</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="keyword">int</span> dt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> limit = dt;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">if</span>(mShouldReverseLayout) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++)&#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span>(mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">              || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">        recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAndRecycleViewAt</span><span class="params">(<span class="keyword">int</span> index, Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = getChildAt(index);</span><br><span class="line">    removeViewAt(index);</span><br><span class="line">    recycler.recycleView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((layoutState.mInfinite || remainningSpace &gt; <span class="number">0</span>) </span><br><span class="line">     &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">    layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要又剩余空间，就会执行 layoutChunk 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)</span></span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    </span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p><p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123;</span><br><span class="line">    addView(view);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addView(view, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p><p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p><h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>最后一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);</span><br><span class="line">            mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span>(record == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;record.flags |= FLAT_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p></li></ul><h3 id="缓存逻辑"><a href="#缓存逻辑" class="headerlink" title="缓存逻辑"></a>缓存逻辑</h3><p>  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> fromScrap = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">fromScrap = holder != <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(hoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="keyword">if</span>(mAdapter.hasStableIds())&#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fallback to recycler</span></span><br><span class="line">            holder = getRecyclerViewPool().getRecyclerView(type);</span><br><span class="line">            <span class="keyword">if</span>(holder != <span class="keyword">null</span>)&#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span>(FORCE_INVALIDATE_DISPLAY_LIST)&#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 LayoutParams 的代码</span></span><br><span class="line">    <span class="keyword">return</span> holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 View 的逻辑可以整理为</p><ul><li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li><li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li><li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li><li>搜索 mRecyclerPool, 如果找到则返回 Holder</li><li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li></ul><p>对于 View 的回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder.isRecyclable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123;</span><br><span class="line">            <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                cachedViewSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">                mCachedViews.add(holder);</span><br><span class="line">                cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder);</span><br><span class="line">            recycled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p><h2 id="与-AdapterView-比较"><a href="#与-AdapterView-比较" class="headerlink" title="与 AdapterView 比较"></a>与 AdapterView 比较</h2><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">AdapterView</th><th style="text-align:center">RecyclerView</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Simple click listener</td><td style="text-align:center">OnItemTouchListener</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Simple Divider</td><td style="text-align:center">ItemDecoration</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ListView and GridView</td><td style="text-align:center">LinearLayoutManager<br>GridLayoutManager..</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">RecyclerBin</td><td style="text-align:center">Recycler</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Header and Footer</td><td style="text-align:center">Partial refresh</td></tr></tbody></table><ul><li><p>点击事件</p><p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p></li><li><p>分割线</p><p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p><p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p></li><li><p>布局类型</p><p>AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。</p></li><li><p>缓存方式</p><p>ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致</p></li></ul><p><strong>不同点</strong></p><ul><li><p>局部刷新</p><p>ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 <code>notifyItemChanged(position)</code> 来完成，甚至可以通过 <code>notifyItemChanged(position, payload)</code> 传入一个 payload 信息来刷新单个 item 中的特定内容。</p></li><li><p>动画</p><p>RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难</p></li><li><p>嵌套布局</p><p>RecyclerView 实现了 <code>NestedScrollingChild</code> 接口，可以和一切嵌套组件很好的工作</p></li></ul><p><strong>ListView 原生特点</strong></p><ul><li><p>头部与尾部支持</p><p>ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、</p></li><li><p>多选</p><p>支持多选和单选的 ListView 更方便</p></li><li><p>多数据源支持</p><p>ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。</p></li></ul><p><strong>总结</strong></p><p>RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RechclerView-总结&quot;&gt;&lt;a href=&quot;#RechclerView-总结&quot; class=&quot;headerlink&quot; title=&quot;RechclerView 总结&quot;&gt;&lt;/a&gt;RechclerView 总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true&quot; alt=&quot;image-20200709164241306&quot;&gt;&lt;/p&gt;
&lt;p&gt;Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View&lt;/p&gt;
&lt;p&gt;Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示&lt;/p&gt;
&lt;p&gt;ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView&lt;/p&gt;
&lt;p&gt;LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成&lt;/p&gt;
&lt;p&gt;Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误&lt;/p&gt;
&lt;p&gt;ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Q 文件权限适配</title>
    <link href="http://xiaoman.ren/2020/03/11/Android-Q-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D/"/>
    <id>http://xiaoman.ren/2020/03/11/Android-Q-文件权限适配/</id>
    <published>2020-03-11T12:11:41.000Z</published>
    <updated>2020-03-11T12:37:13.921Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；<br>Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。</p><p>“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为<br><code>Context.getExternalFilesDir()</code> 下的文件夹。需要传入以下参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Environment.DIRECTORY_MUSIC</span><br><span class="line">Environment.DIRECTORY_PODCASTS</span><br><span class="line">Environment.DIRECTORY_RINGTONES</span><br><span class="line">Environment.DIRECTORY_ALARMS</span><br><span class="line">Environment.DIRECTORY_NOTIFICATIONS</span><br><span class="line">Environment.DIRECTORY_PICUTRES</span><br><span class="line">Environment.DIRECTORY_MOVIES</span><br></pre></td></tr></table></figure><p>可根据具体需要，传入不通的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个文件通过文件夹类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> boxType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> File <span class="title">getFile</span><span class="params">(String fileName, String boxType, String defaultPath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        file = <span class="keyword">new</span> File(defaultPath + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="keyword">null</span> || !file.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码未经测试，忘见谅</strong></p><p>接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：</p><p>访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，<code>Manifest.permission.READ_EXTERNAL_STORAGE</code> 和 <code>Manifest.permission.WRITE_EXTERNAL_STORAGE</code> </p><p>我们来看一下获取相册资源的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Uri contentUri = MediaStore.Files.getContentUri(<span class="string">"external"</span>);</span><br><span class="line">            <span class="keyword">final</span> String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + <span class="string">" DESC"</span>;</span><br><span class="line">            <span class="keyword">final</span> String selection =</span><br><span class="line">                    <span class="string">"("</span> + MediaStore.Files.FileColumns.MEDIA_TYPE + <span class="string">"=?"</span></span><br><span class="line">                            + <span class="string">" OR "</span></span><br><span class="line">                            + MediaStore.Files.FileColumns.MEDIA_TYPE + <span class="string">"=?)"</span></span><br><span class="line">                            + <span class="string">" AND "</span></span><br><span class="line">                            + MediaStore.MediaColumns.SIZE + <span class="string">"&gt;0"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String[] selectionAllArgs = &#123;String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)&#125;;</span><br><span class="line"></span><br><span class="line">            ContentResolver contentResolver = mContext.getContentResolver();</span><br><span class="line">            String[] projections;</span><br><span class="line">            projections = <span class="keyword">new</span> String[]&#123;MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA,</span><br><span class="line">                    MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED,</span><br><span class="line">                    MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore</span><br><span class="line">                    .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE&#125;;</span><br><span class="line"></span><br><span class="line">            Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);</span><br><span class="line">                        <span class="keyword">int</span> mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE);</span><br><span class="line">                        <span class="keyword">int</span> sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE);</span><br><span class="line">                        <span class="keyword">int</span> widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH);</span><br><span class="line">                        <span class="keyword">int</span> heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> size = cursor.getLong(sizeIndex);</span><br><span class="line">                            <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            String type = cursor.getString(mimeTypeIndex);</span><br><span class="line">                            String path = cursor.getString(pathIndex);</span><br><span class="line">                            <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">int</span> width = cursor.getInt(widthIndex);</span><br><span class="line">                            <span class="keyword">int</span> height = cursor.getInt(heightIndex);</span><br><span class="line">                            <span class="keyword">if</span> (width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            File file = <span class="keyword">new</span> File(path);</span><br><span class="line">                            <span class="keyword">if</span> (!file.exists() || !file.isFile()) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            File parentFile = file.getParentFile();</span><br><span class="line">                            <span class="keyword">if</span> (parentFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                images.add(path);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line"></span><br><span class="line">                        cursor.close();</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在<code>AndroidManifest.xml</code> 中的 <code>&lt;application&gt;</code> 标签中加入 <code>android:requestLegacyExternalStorage=&quot;true&quot;</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；&lt;br&gt;Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ASpectJ 初识</title>
    <link href="http://xiaoman.ren/2020/03/06/ASpectJ-%E5%88%9D%E8%AF%86/"/>
    <id>http://xiaoman.ren/2020/03/06/ASpectJ-初识/</id>
    <published>2020-03-06T02:41:22.000Z</published>
    <updated>2020-03-06T08:45:31.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先我们先来了解一下-AOP"><a href="#首先我们先来了解一下-AOP" class="headerlink" title="首先我们先来了解一下 AOP"></a>首先我们先来了解一下 AOP</h2><blockquote><p>AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能</p></blockquote><p>面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。</p><h2 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h2><table><thead><tr><th style="text-align:center">key</th><th style="text-align:center">别名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">Advice</td><td style="text-align:center">通知</td><td>切面的具体行为，要执行的代码</td></tr><tr><td style="text-align:center">PointCut</td><td style="text-align:center">切点</td><td>通知被应用的具体位置</td></tr><tr><td style="text-align:center">Join Point</td><td style="text-align:center">连接点</td><td>程序运行时，能够应用通知的所有点</td></tr><tr><td style="text-align:center">Aspect</td><td style="text-align:center">切面</td><td>什么时候在什么地方做什么事情，是切点和通知的结合</td></tr><tr><td style="text-align:center">Target</td><td style="text-align:center">目标对象</td><td>被切入功能的目标对象</td></tr><tr><td style="text-align:center">Introduction</td><td style="text-align:center">引入</td><td>将新的方法或属性引入到现有的类中</td></tr><tr><td style="text-align:center">Weaving</td><td style="text-align:center">织入</td><td>将切面应用到目标对象并创建新的代理对象的过程</td></tr></tbody></table><p>AOP 底层通过使用动态代理实现，包含两种方式：</p><ol><li>使用 JDK 动态代理实现</li><li>使用 cglib 实现</li></ol><p><strong>通知类型</strong></p><ol><li>前置通知(Befor)：在方法之前执行</li><li>后置通知(After)：在方法之后执行</li><li>异常通知(AfterThrowing)：方法出现异常执行</li><li>最终通知(AfterReturning)：在后置之后执行</li><li>环绕通知(Around)：在方法之前和之后执行</li></ol><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>AspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。</p><p>先写到这里！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先我们先来了解一下-AOP&quot;&gt;&lt;a href=&quot;#首先我们先来了解一下-AOP&quot; class=&quot;headerlink&quot; title=&quot;首先我们先来了解一下 AOP&quot;&gt;&lt;/a&gt;首先我们先来了解一下 AOP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AOP(面向切面编
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OKHttp 重定向拦截器</title>
    <link href="http://xiaoman.ren/2020/02/20/OKHttp-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://xiaoman.ren/2020/02/20/OKHttp-重定向拦截器/</id>
    <published>2020-02-20T09:05:21.000Z</published>
    <updated>2020-02-20T09:07:19.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-OKHttp-进行重定向拦截处理"><a href="#使用-OKHttp-进行重定向拦截处理" class="headerlink" title="使用 OKHttp 进行重定向拦截处理"></a>使用 OKHttp 进行重定向拦截处理</h1><p>okhttp重定向存在两个缺陷：</p><ol><li><p>okhttp处理301,302重定向时，会把请求方式设置为GET<br>这样会丢失原来Post请求中的参数。</p></li><li><p>okhttp默认不支持跨协议的重定向，比如http重定向到https</p></li></ol><p>为了解决这两个问题写了这个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedirectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        HttpUrl beforeUrl = request.url();</span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        HttpUrl afterUrl = response.request().url();</span><br><span class="line">        <span class="comment">//1.根据url判断是否是重定向</span></span><br><span class="line">        <span class="keyword">if</span>(!beforeUrl.equals(afterUrl)) &#123;</span><br><span class="line">            <span class="comment">//处理两种情况 1、跨协议 2、原先不是GET请求。</span></span><br><span class="line">            <span class="keyword">if</span> (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">                <span class="comment">//重新请求</span></span><br><span class="line">                Request newRequest = request.newBuilder().url(response.request().url()).build();</span><br><span class="line">                response = chain.proceed(newRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-OKHttp-进行重定向拦截处理&quot;&gt;&lt;a href=&quot;#使用-OKHttp-进行重定向拦截处理&quot; class=&quot;headerlink&quot; title=&quot;使用 OKHttp 进行重定向拦截处理&quot;&gt;&lt;/a&gt;使用 OKHttp 进行重定向拦截处理&lt;/h1&gt;&lt;p&gt;ok
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 常用工具和插件</title>
    <link href="http://xiaoman.ren/2020/02/20/Android-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://xiaoman.ren/2020/02/20/Android-常用工具和插件/</id>
    <published>2020-02-20T09:04:13.000Z</published>
    <updated>2020-09-16T16:40:31.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-开发必备插件和工具"><a href="#Android-开发必备插件和工具" class="headerlink" title="Android 开发必备插件和工具"></a>Android 开发必备插件和工具</h1><h2 id="Android-Studio-插件"><a href="#Android-Studio-插件" class="headerlink" title="Android Studio 插件"></a>Android Studio 插件</h2><table><thead><tr><th>插件名</th><th>注释</th></tr></thead><tbody><tr><td>Alibaba Java Coding Guidelines</td><td>阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；</td></tr><tr><td>Android Parcelable code generator</td><td>序列化 Po 类时，可以快速生成序列化代码</td></tr><tr><td>CodeGlance</td><td>代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码</td></tr><tr><td>DataBase Navigator</td><td>支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题</td></tr><tr><td>FindBugs-IDEA</td><td>可以分析现存代码中容易引起异常的部分，并提供修改建议</td></tr><tr><td>GsonFormater</td><td>将 xml 和 json 转换位 pojo 类，可以快速生成数据源</td></tr><tr><td>Markdown</td><td>语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档</td></tr><tr><td>Markdown Navigator</td><td>Markdown 预览工具，可以观察实时渲染的 HTML 文档</td></tr><tr><td>Android Resource Tools</td><td>1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码<br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    <br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度</td></tr><tr><td>Codota</td><td>模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示</td></tr><tr><td>GoodFormatter</td><td>保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；</td></tr><tr><td>ButterknifePlugin</td><td>快速生成 butternkife 的注入代码，前提需要引入 butterknife</td></tr><tr><td>JsonViewer</td><td>可以替换 postman 的插件，用来调试接口</td></tr><tr><td>Git Commit Template</td><td>Git 提交记录模版工具</td></tr><tr><td>Sql Android</td><td>数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便</td></tr><tr><td>—</td><td>—</td></tr></tbody></table><a id="more"></a><p><strong>codata</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(File srcFile, File zipFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFile))) &#123;</span><br><span class="line">      zos.putNextEntry(<span class="keyword">new</span> ZipEntry(srcFile.getName()));</span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">while</span> ((len = fis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        zos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br><span class="line">      zos.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AndroidResourceTools</strong><br><img src="https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true" alt></p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true" alt></p><p> <strong>JsonViewer</strong></p><p> <img src="https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true" alt></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>除必要 AS 之外，需要以下工具, Mac 用户可以通过 <a href="https://xclient.info/" target="_blank" rel="noopener">XClient</a> 下载破解版软件</p><table><thead><tr><th>工具</th><th>注释</th></tr></thead><tbody><tr><td>Sublime Text 3</td><td>文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br><strong>PrettyJson</strong> 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> <strong>Markdown</strong> 可以用来写 Markdown 文件，但不支持渲染<br><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3 下载地址</a></td></tr><tr><td>Postman</td><td>接口调试工具，也可以用上面推荐的 <strong>JsonViewer</strong><br><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman 下载地址</a></td></tr><tr><td>Fiddler、Charles</td><td>抓包调试工具，可抓包，修改参数调试接口，任选<br><a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler 下载地址</a><br><a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles 下载地址</a></td></tr><tr><td>Markdown</td><td>Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br><a href="https://typora.io/" target="_blank" rel="noopener">Typora 下载地址</a><br><a href="https://www.mweb.im/" target="_blank" rel="noopener">MWeb Pro 下载地址</a></td></tr><tr><td>Vysor</td><td>Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br><a href="https://www.vysor.io/" target="_blank" rel="noopener">Vysor 下载地址</a></td></tr><tr><td>XMind</td><td>脑图工具，用来写结构<br><a href="https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&amp;ci=737183467&amp;adgroupid=41332915427&amp;adpos=1t1&amp;ck=xminds&amp;targetid=kwd-642237838482&amp;match=p&amp;gnetwork=g&amp;creative=204109085004&amp;placement=&amp;placecat=&amp;accname=setapp&amp;gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB" target="_blank" rel="noopener">XMind 下载地址</a></td></tr><tr><td>Beyond Compare</td><td>文件比较器，比较两组文件的差异<br><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">BeyondCompare 下载地址</a></td></tr><tr><td>Dash</td><td>源码查看器， 也可以使用在线的 <a href="http://androidos.net.cn/sourcecode" target="_blank" rel="noopener">Android 社区</a></td></tr><tr><td>PxCook</td><td>云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。<a href="https://www.fancynode.com.cn/pxcook" target="_blank" rel="noopener">PxCook 下载地址</a></td></tr><tr><td>—</td><td>—</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-开发必备插件和工具&quot;&gt;&lt;a href=&quot;#Android-开发必备插件和工具&quot; class=&quot;headerlink&quot; title=&quot;Android 开发必备插件和工具&quot;&gt;&lt;/a&gt;Android 开发必备插件和工具&lt;/h1&gt;&lt;h2 id=&quot;Android-Studio-插件&quot;&gt;&lt;a href=&quot;#Android-Studio-插件&quot; class=&quot;headerlink&quot; title=&quot;Android Studio 插件&quot;&gt;&lt;/a&gt;Android Studio 插件&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;插件名&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Java Coding Guidelines&lt;/td&gt;
&lt;td&gt;阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android Parcelable code generator&lt;/td&gt;
&lt;td&gt;序列化 Po 类时，可以快速生成序列化代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CodeGlance&lt;/td&gt;
&lt;td&gt;代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataBase Navigator&lt;/td&gt;
&lt;td&gt;支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FindBugs-IDEA&lt;/td&gt;
&lt;td&gt;可以分析现存代码中容易引起异常的部分，并提供修改建议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GsonFormater&lt;/td&gt;
&lt;td&gt;将 xml 和 json 转换位 pojo 类，可以快速生成数据源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Markdown&lt;/td&gt;
&lt;td&gt;语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Markdown Navigator&lt;/td&gt;
&lt;td&gt;Markdown 预览工具，可以观察实时渲染的 HTML 文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android Resource Tools&lt;/td&gt;
&lt;td&gt;1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码&lt;br&gt;2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    &lt;br&gt;3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Codota&lt;/td&gt;
&lt;td&gt;模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GoodFormatter&lt;/td&gt;
&lt;td&gt;保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ButterknifePlugin&lt;/td&gt;
&lt;td&gt;快速生成 butternkife 的注入代码，前提需要引入 butterknife&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JsonViewer&lt;/td&gt;
&lt;td&gt;可以替换 postman 的插件，用来调试接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Git Commit Template&lt;/td&gt;
&lt;td&gt;Git 提交记录模版工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sql Android&lt;/td&gt;
&lt;td&gt;数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>清香木养殖（四）</title>
    <link href="http://xiaoman.ren/2019/10/17/%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://xiaoman.ren/2019/10/17/清香木养殖（四）/</id>
    <published>2019-10-17T09:11:50.000Z</published>
    <updated>2020-02-20T09:13:37.992Z</updated>
    
    <content type="html"><![CDATA[<p>丢了···································· T_T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;丢了···································· T_T&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 下配置 Android Studio 中文输入</title>
    <link href="http://xiaoman.ren/2019/08/23/Linux-%E4%B8%8B%E9%85%8D%E7%BD%AE-Android-Studio-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5/"/>
    <id>http://xiaoman.ren/2019/08/23/Linux-下配置-Android-Studio-中文输入/</id>
    <published>2019-08-23T02:26:28.000Z</published>
    <updated>2019-08-23T02:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。</p><p>虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。</p><p>最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。</p><p>首先，打开 Android Studio 的文件目录 <code>/android-stdio/bin/</code> ，使用 Vi 命令打开文件 <code>studio.sh</code>，</p><p>在文件的开头，输入下面这一串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export XMODIFIERS=@im=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export GTK_IM_MODULE=&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><p>然后 :wq 保存退出。</p><p>接着重启 Android Studio 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。&lt;/p&gt;
&lt;p&gt;虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。&lt;/p&gt;
&lt;p&gt;最近一直困扰我的一个问题就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 获取 View 的宽高</title>
    <link href="http://xiaoman.ren/2019/08/21/Android-%E8%8E%B7%E5%8F%96-View-%E7%9A%84%E5%AE%BD%E9%AB%98/"/>
    <id>http://xiaoman.ren/2019/08/21/Android-获取-View-的宽高/</id>
    <published>2019-08-21T13:54:08.000Z</published>
    <updated>2019-08-21T15:39:32.625Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中，获取一个 View 的宽高有很多中方法，最直接的就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 View 的宽高，单位是像素</span></span><br><span class="line"><span class="keyword">int</span> height = view.getHeight();</span><br><span class="line"><span class="keyword">int</span> width = view.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 View 的原始测量高度</span></span><br><span class="line"><span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line"><span class="keyword">int</span> width = view.getMeasuredWidth();</span><br></pre></td></tr></table></figure><p>有时需要在 onCreate 方法中获取某个 View 组件的宽度和高度信息，而直接调用 View 组件的 getWidth(), getHeight(), getMeasuredWidth(), getMeasuredHeight(), getTop(), getLeft() 等方法是无法获取到真实值，只会得到 0 ，这是因为 View 组件布局要在 onResume 后回调 。<br><a id="more"></a></p><p>因此，当我们需要 View 的宽高数据时，可以使用 <code>getViewTreeObserver().addOnGlobalLayoutListener()</code> 来获取 View 的宽度或者高度。这是获得一个 View 的宽度和高度的方法之一。</p><p><code>onGlobalLayoutListener()</code> 是 <code>ViewTreeObserver</code> 的内部类，当一个视图树的布局发生改变时，可以被 <code>ViewTreeObserver</code> 监听到，这是一个注册监听视图的观察者(observer)， 在视图树的全局事件改变时得到通知。 <code>ViewTreeObserver</code> 不能直接实例化，而是通过 <code>getViewTreeObserver()</code> 获得。</p><p>其中，我们可以利用 <code>OnGlobalLayoutListener</code> 来获取一个视图的真实高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line">imageView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        positionX = imageView.getX();</span><br><span class="line">        positionY = imageView.getY();</span><br><span class="line">        height = imageView.getHeight();</span><br><span class="line">        widht = imageView.getWidth();</span><br><span class="line">        imageView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>OnGlobalLayoutListener</code> 可能会被多次触发，因此在得到了高度之后，要将 <code>OnGlobalLayoutListener</code> 注销掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="ViewTreeObserver"><a href="#ViewTreeObserver" class="headerlink" title="ViewTreeObserver"></a>ViewTreeObserver</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class ViewTreeObserver extends Object</span><br><span class="line">java.lang.Object</span><br><span class="line">android.view.ViewTreeObserver</span><br></pre></td></tr></table></figure><p>是一个注册监听视图的观察者（Observer），在视图树全局事件改变时得到通知。这个全局事件不仅包括整个树的布局，从绘画过程开始，触摸模式的改变等。ViewTreeObserver 不能够被应用程序实例化，因为它是由视图提供 <code>getViewTreeObserver()</code></p><p><strong>基本常用的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当在一个视图书中的焦点状态发生改变时，所要调用的回调函数接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalFocusChangeListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在一个视图树中全局布局发生改变时或者视图树中的某个视图的可视化状态发生改变时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalLayoutListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树将要绘制时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树中的组件发生滚动时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnScrollChangedListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树中的触摸模式发生改变时，用于监听 touch 和非 touch 的转换</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnTouchModeChangeListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听布局的变化</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalLayoutLitener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 ViewTreeObserver 是否可用，不可用时，任何方法调用都会报错</span></span><br><span class="line">getViewTreeObserver().isAlive();</span><br><span class="line"></span><br><span class="line">addOnWindowAttachListener</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnGlobalFocusChangeListener</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnScrollChangedListener</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnTouchModeChangeListener</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当整个布局发生改变时通知相应的注册监听器。如果你强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者在GONE状态下，它可以被手动的调用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchOnGlobalLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当一个视图树将要绘制时通知相应的注册监听器，如果返回 true， 则这个绘制将被取消并重新计划。如果强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者一个在 gone 状态下，将被手动调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchOnPreDraw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发中，获取一个 View 的宽高有很多中方法，最直接的就是：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回 View 的宽高，单位是像素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height = view.getHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; width = view.getWidth();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回 View 的原始测量高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height = view.getMeasuredHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; width = view.getMeasuredWidth();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时需要在 onCreate 方法中获取某个 View 组件的宽度和高度信息，而直接调用 View 组件的 getWidth(), getHeight(), getMeasuredWidth(), getMeasuredHeight(), getTop(), getLeft() 等方法是无法获取到真实值，只会得到 0 ，这是因为 View 组件布局要在 onResume 后回调 。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java Reference</title>
    <link href="http://xiaoman.ren/2019/08/09/Java%20%E5%90%84%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xiaoman.ren/2019/08/09/Java 各引用之间的区别/</id>
    <published>2019-08-09T13:54:08.000Z</published>
    <updated>2019-08-12T02:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reference-引用"><a href="#Reference-引用" class="headerlink" title="Reference 引用"></a>Reference 引用</h2><p>继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。</p><p>三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：</p><ul><li>Referent： 被引用对象</li><li>ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>　</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"in Person finalize"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="StrongReference-强引用"><a href="#StrongReference-强引用" class="headerlink" title="StrongReference 强引用"></a>StrongReference 强引用</h2><p>Java 中使用的最多，普通的引用 <code>Object obj = new Object();  Person p = new Person();</code> 都属于<code>强引用</code> </p><p>强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。</p><p>一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。</p><h2 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference 软引用"></a>SoftReference 软引用</h2><p>软引用普通使用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;Person&gt;(person);</span><br></pre></td></tr></table></figure><p>强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSofeReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建强引用对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为"</span> + person);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建软引用对象</span></span><br><span class="line">    SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;Person&gt;(person);</span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)</span></span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br></pre></td></tr></table></figure><ul><li>当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。</li><li>我们继续执行 <code>System.gc()</code> 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。</li></ul><p><strong>软引用所指向的对象要进行回收，需要满足两个条件：</strong></p><ol><li>没有任何强引用指向软引用指向的对象（内存中的 Person 对象）</li><li>JVM 需要内存时，即在抛出 OOM 之前</li></ol><p><strong>总结：</strong> SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</p><p><strong>软引用还可以和一个 ReferenceQueue 一起使用，</strong> 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReferenceWithQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为："</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(person, queue);</span><br><span class="line">    </span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）</span></span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"加入 ReferenceQueue 的对象为："</span> + queue.poll());</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"加入 ReferenceQueue 的对象为： "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述例子，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">加入 ReferenceQueue 的对象为 null</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">加入 ReferenceQueue 的对象为 null</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p><p>而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</p><h2 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference 弱引用"></a>WeakReference 弱引用</h2><p>弱引用的一般使用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为： "</span> + person);</span><br><span class="line">    </span><br><span class="line">    WeakReference&lt;Person&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(person);</span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。</span></span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象进入 GC 流程</span><br><span class="line">in Person finalize</span><br></pre></td></tr></table></figure><ul><li><p>当执行 <code>person = null</code> 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。</p><p>此时调用 <code>wr.get()</code> 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 <code>wr.get()</code> 方法返回不为空。</p></li><li><p>继续执行 <code>System.gc()</code> 强制执行垃圾回收，打印结果可以看到，<code>wr.get()</code> 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。</p></li></ul><p><strong>弱引用所指向的对象要进行回收，只需要满足条件：</strong></p><p>​    没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）</p><p><strong>总结：</strong></p><p>​    WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。</p><p><strong>其主要使用场景见于：</strong> </p><p>​    当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 <code>WeakReference</code> 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。</p><p>与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReferenceWithQueue</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为 "</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    WeakReference&lt;Person&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(person, queue);</span><br><span class="line">    System.out.println(<span class="string">"wr 对象为 "</span> + wr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Whether or not this reference has been enqueued:"</span> + wr.isEnqueued());</span><br><span class="line">    System.out.println(<span class="string">"Queue item: "</span> + queue.pull());</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;<span class="comment">// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</span></span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确保垃圾回收线程能够执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Whether or not this reference has been enqueued: "</span> + wr.isEnqueued());</span><br><span class="line">    System.out.println(<span class="string">"queue item: "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">wr 对象为 java.lang.ref.WeakReference@603828d2</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">Whether or not this reference has been enqueued: false</span><br><span class="line">queue item: null</span><br><span class="line">person 对象进入回收流程</span><br><span class="line">in Person finalize</span><br><span class="line">Whether or not this reference has been enqueued: true</span><br><span class="line">queue item: java.lang.ref.WeakReference@603828d2</span><br></pre></td></tr></table></figure><p>从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。</p><p><strong>注意：</strong></p><p>​     当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p><p>​    而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。</p><h2 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference 虚引用"></a>PhantomReference 虚引用</h2><p>虚引用源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhantomReference</span><span class="params">(T var1, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PhantomReference 只有一个构造函数 <code>PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q)</code>  因此，PhantomReference 使用必须结合 ReferenceQueue；</li><li>不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPhantomReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为"</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;Person&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(person, queue);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"pr 对象为"</span> + pr);</span><br><span class="line">    System.out.println(<span class="string">"pr.get() = "</span> + pr.get());</span><br><span class="line">    </span><br><span class="line">    person = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 确保垃圾回收线程执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"queue item: "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">pr 对象为 java.lang.ref.PhantomReference@60e35b53</span><br><span class="line">pr.get() = null</span><br><span class="line">in Person finalize</span><br><span class="line">queue ite: java.lang.ref.PhantomReference@60e35b53</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>​    与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并才去必要的行动）</p><p><strong>用途：</strong></p><p>​    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p>​    程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。</p><p>​    程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reference-引用&quot;&gt;&lt;a href=&quot;#Reference-引用&quot; class=&quot;headerlink&quot; title=&quot;Reference 引用&quot;&gt;&lt;/a&gt;Reference 引用&lt;/h2&gt;&lt;p&gt;继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。&lt;/p&gt;
&lt;p&gt;三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Referent： 被引用对象&lt;/li&gt;
&lt;li&gt;ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceTest&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;　&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finalize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;in Person finalize&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 内存管理</title>
    <link href="http://xiaoman.ren/2019/08/04/Android%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://xiaoman.ren/2019/08/04/Android 内存管理/</id>
    <published>2019-08-04T13:54:08.000Z</published>
    <updated>2019-08-12T08:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。</p><h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。</p><ul><li>静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li><li>栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。</li></ul><a id="more"></a><h2 id="堆与栈的区别："><a href="#堆与栈的区别：" class="headerlink" title="堆与栈的区别："></a>堆与栈的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p><p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊变量，这个变量的取值等于数组或者对象在内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">    Sample sample1 = <span class="keyword">new</span> Sample();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">        Sample sample2 = <span class="keyword">new</span> Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sample sample3 = <span class="keyword">new</span> Sample();</span><br></pre></td></tr></table></figure><p>Sample 类的局部变量 s2 和引用变量 sample2 都是存在于栈中，但 smaple2 指向的对象是存在于堆中。 sample3 指向的对象存放在堆中，包括这个对象的所有成员变量 s1 和 sample1， 而它自己存在与栈中。</p><p><strong>结论：</strong></p><ul><li>局部变量的脚本数据类型和引用存储在栈中，引用的对象实体存储于堆中。—— 因为他们属于方法中的变量，生命周期随方法而结束</li><li>成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。—— 因为他们属于类，类对象终究是要被 new 出来使用的。</li></ul><h2 id="Java-是如何管理内存"><a href="#Java-是如何管理内存" class="headerlink" title="Java 是如何管理内存"></a>Java 是如何管理内存</h2><p>Java 的内存管理就是对象的分配和释放的问题。在 Java 中，coder 需要通过关键字 new 为每一个对象申请新的存储空间（基本类型除外），所有的对象都在 堆（Heap）中分配空间。另外对象的释放是由 GC 决定和执行的，在 Java 中，内存分配是由 coder 完成的，而内存释放是由 GC 完成的。这种收支两条线的方法简化了 coder 的工作。同时也加重了 JVM 的工作。也是 Java 程序运行速度慢的原因之一。因为 GC 为了能够正确释放对象， GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要监控。</p><p>监控对象状态是为了更准确、及时地释放对象，而释放对象的根本原则就是该对象不在被引用。</p><p><img src="https://camo.githubusercontent.com/ba01b8ae9af4a5e588251316c826bf3e0e695f35/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f312e676966" alt></p><p>Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要他们和根进程不可达，那么 GC 就可以回收他。这种管理方式的有点是管理内存的精度高，但是效率低。</p><h2 id="什么是-Java-中的内存泄露"><a href="#什么是-Java-中的内存泄露" class="headerlink" title="什么是 Java 中的内存泄露"></a>什么是 Java 中的内存泄露</h2><p>在 Java 中，内存泄露就是存在一些被分配的对象，这些对象有两个特点。</p><ul><li>这些对象是可达的，即在有向图中，存在通路与其相连</li><li>这些对象是无用的，即程序以后不会在使用这些对象。</li></ul><p>如果满足这两个条件，这些对象就可以判定为 Java 中的内存泄露，这些对象不会被 GC 回收，但却是占用着内存。</p><p>对于程序猿来说， GC 基本是透明的，不可见的。虽然我们只有几个函数可以方位 GC， 例如运行 GC 的函数 <code>System.gc()</code>，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾回收器一定会执行。因为，不同的 JVM 实现着可能使用不同的算法管理 GC。 通常 GC 的线程优先级比较低。 JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定成都时， GC 才开始工作；也有定时执行，有的是平缓执行 GC， 有的是中断式执行 GC。 通常来说，我们不需要关心这些。除非在一些特定的场合， GC 的执行影响应用程序的性能，例如对于基于 Web 的实时系统，如网络游戏等，用户不希望 GC 突然终端应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行， Sun 提供了 HotSpot JVM 支持这一特性。</p><p>同样给出一个 Java 内存泄露的典型例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然应用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p><h2 id="详细的-Java-中的内存泄露"><a href="#详细的-Java-中的内存泄露" class="headerlink" title="详细的 Java 中的内存泄露"></a>详细的 Java 中的内存泄露</h2><h3 id="Java-内存回收机制"><a href="#Java-内存回收机制" class="headerlink" title="Java 内存回收机制"></a>Java 内存回收机制</h3><p>不论那种语言的内存分配方式，都需要返回所分配的真实地址，也就是返回一个指针到内存块的首地址。Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的。所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成。 GC 为了能够正确释放对象，会监控每个对象的运行状态，对他们的申请、引用、被引用、赋值等状况进行监控， Java 会使用有向图的方式进行管理内存，实时监控对象是否可以到达，如果不可以到达，则将其回收，这样也可以消除引用的循环问题。在 Java 语言中，判断一个内存空间是否符合垃圾回收标准有两个：</p><pre><code>1. 给对象赋予了空值 null   2. 给对象赋予了新值，这样重新分配了内存空间。</code></pre><h3 id="Java-内存泄漏引起的原因"><a href="#Java-内存泄漏引起的原因" class="headerlink" title="Java 内存泄漏引起的原因"></a>Java 内存泄漏引起的原因</h3><p>内存泄露是指无用对象（不再使用的对象）持续占有内存活无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄漏有时不严重，不易察觉，这样开发者就不知道存在内存泄漏，但有时也很严重，会提示 Out of memory。</p><p>Java 内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被释放回收，这就是 Java 中内存泄漏的发生场景，主要有一下几大类：</p><ol><li><p>静态集合类引起的内存泄漏：</p><p>像 HashMap、Vector 等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等引用着。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vercor(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，循环申请 <code>Object</code> 对象，并将所申请的对象放入一个 Vector 中，如果仅仅释放引用本身（o = null），那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可会说的。因此对象加入到 Vector 后， 还必须从 Vector 中删除，最简单的是将 Vector 设置为 null。</p></li><li><p>当集合里面的对象属性被修改后，再调用 remove() 方法时，不起作用</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>, <span class="string">"pwd1"</span>, <span class="number">25</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>, <span class="string">"pwd2"</span>, <span class="number">24</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>, <span class="string">"pwd3"</span>, <span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"总共有："</span> + set.size() + <span class="string">" 个元素"</span>);<span class="comment">// 结果： 总共有 3 个元素</span></span><br><span class="line">    p3.setAge(<span class="number">2</span>); <span class="comment">// 修改 p3 的年龄，此时 p3 元素对应的 hashcode 值发生改变</span></span><br><span class="line">    </span><br><span class="line">    set.remove(p3); <span class="comment">// remove 掉，造成内存泄露</span></span><br><span class="line">    </span><br><span class="line">    set.add(p3); <span class="comment">// 重新添加，成功</span></span><br><span class="line">    </span><br><span class="line">   System.out.println(<span class="string">"总共有："</span> + set.size() + <span class="string">" 个元素"</span>); <span class="comment">// 结果：总共有 4 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : set) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监听器</p><p>在 Java 变成中，我们需要和监听器打交道，通常一个应用当中会有多个监听器，我们会调用一个控件的例如<code>addXXXXListener()</code> 等方法来增加监听器，但往往在释放对象的时候，却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p></li><li><p>各种连接</p><p>比如数据库连接（dataSourse.getConnection()）、 网络连接(socket) 和 io 连接，除非其显示的调用了其 <code>close()</code> 方法将其连接关闭，否则是不会自动被 GC 回收的。对于 Resultset 和 Statement 对象可以不进行显示回收，但 Connection 一定要显示回收，因为 Connection 在任何时候都无法自动回收，而 Connection 一旦回收， Resultset 和 Statement 对象就会立即2为 NULL。 但是如果使用连接池，情况就不一样了，除了要显示地关闭链接，还必须显示地关闭 Resultset 和 Statement 对象（关闭其中一个， 另外一个也会关闭），否则就会造成大量的 Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在 try 里面去连接，在 finally 里面释放连接。</p></li><li><p>内部类和外部模块的引用</p><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后续类对象没有释放。此外 coder 还要小心外部模块不经意的引用，例如 coder A 负责 A 模块，调用了 B 模块的一个方法： <code>public void registerMsg(Object b);</code> 这种调用就要小心，传入了一个对象，很可能模块 B 就保持了对该对象的引用，这时候就需要注意模块 B 是否提供响应的操作去除引用。</p></li><li><p>单例模式</p><p>不正确的使用单例模式是引起内存泄漏的一个常见问题，单利对象在初始化后，将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B instance = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">b</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instacne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然 B 采用 singleton 模式， 它持有一个 A 对象的引用，而这个类的对象将不能被回收。想象下如果 A 是个比较复杂的对象或者集合类型会发生什么。</p></li></ol><h2 id="Android-中常见的内存泄漏汇总"><a href="#Android-中常见的内存泄漏汇总" class="headerlink" title="Android  中常见的内存泄漏汇总"></a>Android  中常见的内存泄漏汇总</h2><h3 id="集合类泄漏"><a href="#集合类泄漏" class="headerlink" title="集合类泄漏"></a>集合类泄漏</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的例子中就是其中一种情况，当然实际上我们在项目中肯定不会这样谢代码，但稍不注意还是很容易出现这种情况。</p><h3 id="单例造成的内存泄露"><a href="#单例造成的内存泄露" class="headerlink" title="单例造成的内存泄露"></a>单例造成的内存泄露</h3><p>由于单利的静态特性使得其生命周期跟应用一样长，所以如果使用不恰当的话，很容易造成内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connect = connect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context， 所以这个 Context 的生命周期的长短至关重要：</p><ol><li>如果此时传入的是 Application 的 Context， 因为 Application 的生命周期就是这个应用的生命周期，所以这将没有任何问题。</li><li>如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的应用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时，它的内存并不会被释放，就会造成泄漏。</li></ol><p><strong>正确的方式应修改为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span> <span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();<span class="comment">// 使用 Application 的 context</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样写，连 Context 都不用传进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在你的 Application 中添加一个静态方法， getContext() 返回 Application 的 context</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">context = getApplicationContext();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取全局的 Context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回全局的 context 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    reutnr context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = MyApplication.getContext();<span class="comment">// 使用 Application 的 context</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> staitc AppManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类-非静态内部类和异步线程"><a href="#匿名内部类-非静态内部类和异步线程" class="headerlink" title="匿名内部类/非静态内部类和异步线程"></a>匿名内部类/非静态内部类和异步线程</h3><p>非静态内部类创建静态实例造成的内存泄漏</p><p>有的时候我们可能会在启动频繁的 Activity 中，为了避免重复创建相同资源，可能会出现这种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> staitc TestResource mResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mResource = <span class="keyword">new</span> TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 都会使用该单利的数据，这样虽然避免了资源的重复创建，不过这种写法却造成了内存写泄漏，因为<strong>非静态内部类默认会持有外部类的引用</strong>，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法：</p><p>将该内部类设为静态内部类或者将该内部类抽取出来封装成单例，如果需要使用 Context， 按照上一个方法推荐使用 Application 中的 Context。 当然 Application 的 Context 不是万能的，所以也不能随便乱用，对于有些地方则是必须使用 Activity 的 Context ，对于 Application，Service， Activity 三者的 Context 的应用场景如下：</p><p><img src="https://camo.githubusercontent.com/dee4aecb8a80c4e73337b56ee01cbffa2a8049dd/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303135313132333134343232363334393f73706d3d353137362e3130303233392e626c6f67636f6e742e392e437455316334" alt="Application, Service, Activity 的 Context 使用场景"></p><p>其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>Android 开发经常会继承实现 Activity/Fragment/View， 此时如果你使用了匿名类，并被异步线程持有，如果没有任何措施这样一定会导致泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Runnable ref1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Runnable ref2 = <span class="keyword">new</span> Runnable ()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ....</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref1 和 ref2 的区别是， ref2 使用了匿名内部类。我们看一下运行时，这两个引用的内存：</p><p><img src="https://camo.githubusercontent.com/2b1a52551d828d9640f23ee7c2802476b02ccec3/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f666230356666366432653638663330396239346464383433353263383161636665306165383339653f73706d3d353137362e3130303233392e626c6f67636f6e742e31302e437455316334" alt></p><p>可以看到 ref1 没什么特别的。</p><p>但 ref2 这个匿名类的实现对象里面多了一个引用：</p><p>this$0 这个引用指向 MainActivity.this， 也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就会造成内存泄漏。</p><h3 id="Handler-造成的内存泄漏"><a href="#Handler-造成的内存泄漏" class="headerlink" title="Handler 造成的内存泄漏"></a>Handler 造成的内存泄漏</h3><p>Handler 的使用造成的内存泄漏问题应该说是最常见的，但很多时候我们为了避免 ANR 而不在主线程中进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写不规范就有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p><p>由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，很容易导致无法正确释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handerl()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundler savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// post a message and delay its execution for 10 minutes.</span></span><br><span class="line">        mLeakHandler.postDelayed(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">6</span> * <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// go back to the previous Activity</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该例中，生命了一个延时 10 分钟执行的消息 Message， mLeakyHandler 将其 push 进了消息队列 MessageQueue 中。当 Activity 被 finish() 掉，延时任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，此时 finish() 掉的 Activity 就不会被回收，从而造成内存泄漏（<strong>因 Handler 为非静态内部类，会持有外部类的引用，在这里就是 MainActivity</strong>）.</p><p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 生命为静态的，则其存活期和 Activity的 生命周期无关了，同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 Context 传入， 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Instence of static inner classes do not bold an implicit reference to their outer class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span> <span class="params">(SampleActivity activity)</span> </span>&#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            SampleActivity activity = mActivity.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Instance of anonymous classes do not hold an implicit </span></span><br><span class="line"><span class="comment">    * reference to their outer class when they are "static"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable ()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundler savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Post a message and delay its execution for 10 mintues.</span></span><br><span class="line">        mHandler.postDelay(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// go back to the previous Activity</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综述， 即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p><p>前面提到的 WeakReference，所以这里简单说下 Java 中对象的几种引用类型。</p><p>Java 对引用分为 StrongReference， SoftReference， WeakReference和 PhantomReference 四种。</p><table><thead><tr><th>级别</th><th>回收时机</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强(StrongReference)</td><td>从来不会</td><td>对象的一般状态</td><td>JVM 停止运行时终止</td></tr><tr><td>软(SoftReference)</td><td>在内存不足时</td><td>联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器(内存不足才清空)</td><td>内存不足时终止</td></tr><tr><td>弱（WeakReference）</td><td>在垃圾回收时</td><td>联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器(系统发生 gc 则清空)</td><td>gc 运行后终止</td></tr><tr><td>虚（PhantomReference）</td><td>在垃圾回收时</td><td>联合 ReferenceQueue 来跟踪对象被垃圾回收器回收的活动</td><td>gc 运行后终止</td></tr></tbody></table><p>在 Android 应用开发中，为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p><p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联得的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清楚已失效的软/弱引用。</p><p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次去读取图片，由于读取文件需要硬件操作，速度很慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是由于图片占用空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生 OutOfMemery 异常。这时我们可以考虑使用软/弱引用技术来避免这个问题发生。以下是高速缓冲器的雏形：</p><p>首先定义一个 HashMap，保存软引用对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><p>再定义一个方法，保存 bitmap 的软引用到 HashMap。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CacheBySoftRef &#123;</span><br><span class="line">    // 先定义一个 HashMap，保存软引用对象</span><br><span class="line">    private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    // 再定义一个方法，保存 bitmap 的软引用到 HashMap。</span><br><span class="line">    public void addBitmapToCache(String path) &#123;</span><br><span class="line">        // 强引用的 Bitmap 对象</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">        // 软引用的 bitmap 对象</span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">        imageCache.put(path, softBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取的时候，可以通过 SoftReference 的 get() 方法得到 bitmap 对象</span><br><span class="line">    public Bitmap getBitmapByPath(String path) &#123;</span><br><span class="line">        // 从缓存中取软引用的 bitmap 对象</span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line">        // 判断是否存在软引用</span><br><span class="line">        if (softBitmap == null)  return;</span><br><span class="line">        // 通过软引用取出 bitmap 对象，如果由于内存不足 Bitmap 被回收，将取到空，如果未被回收，则可重复使用，提高速度</span><br><span class="line">        Bitmap bitmap = softBitmap.get();</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用软引用以后，在 OutOfMemory 异常发生之前，这些缓存的图片资源的内存空间可以被释放掉，从而避免内存达到上线，避免 Crash 发生。</p><p>如果只是想避免 OutOfMemory 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><p>另外可以根据对象<strong>是否经常使用</strong>来判断选择软引用还是弱引用。如果对象可能会经常使用，就尽可能的使用软引用。如果对象不被使用的可能性更大，就用弱引用。</p><p>前面所说，创建一个静态的 Handler 内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 的泄漏，不过 Looper 线程的消息队列中，还是可能会有待处理的消息，所以我们在 Activity 的 onDestory() 时，或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p><p>移除消息队列中 Message 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r, Objject token)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="尽量避免使用-static-成员变量"><a href="#尽量避免使用-static-成员变量" class="headerlink" title="尽量避免使用 static 成员变量"></a>尽量避免使用 static 成员变量</h3><p>如果成员变量被声明为 static, 那我们都知道其生命周期将与整个 APP 进程生命周期一样。</p><p>这会导致一些列问题，如果你的 APP 进程设计上是常驻内存的，那即使 APP 切到后台，这部分内存也不会被释放。按照现在手机 APP 内存管理机制，占内存较大的后台集成将优先回收，因为如果此 APP 做过进程互相保活，那会造成 APP 在后台频繁重启。当手机安装了你参与开发的 APP 以后一夜时间手机被消耗空了电量、流量，你的 APP 不得不被用户卸载或者静默。</p><p>修复方法是：</p><p>不要在类初始化时初始化静态成员。可以考虑 lazy 初始化。架构设计上要死好是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p><h3 id="避免-Override-finalize"><a href="#避免-Override-finalize" class="headerlink" title="避免 Override finalize()"></a>避免 Override finalize()</h3><ol><li><p>finalize 方法被执行的时间不确定，不能依赖它来释放紧缺的资源，时间不确定的原因是：虚拟机调用 GC 的时间不确定 finalize daemon 线程被调度到的时间不确定。</p></li><li><p>finalize 方法只会被执行一次，及时对象被复活，如果已经执行过 finalize 方法，再次被 GC 时，也不会再执行，原因是：</p><p>含有 finalize 方法的 Object 是在 new 的时候，由虚拟机生成了一个 finalize reference 在来引用到该 Object的，而在finalize 方法执行的时候，该 Object 所对应的 finalize Reference 会被释放掉。即使在这个时候把该Object 复活（即用强引用引用住该 Object），再第二次被 GC 的时候，由于没有了 finalize Reference 与之对应，所以 finalize 方法不会再执行。</p></li><li><p>含有 finalize 方法的 Object 需要至少经过两轮 GC 才有可能被释放。</p></li></ol><h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h3><p>对于使用了 BroadcastRevicer, ContentObserver, File， 游标 Cursor， Stream， Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p><h3 id="一些不良代码造成的内存压力"><a href="#一些不良代码造成的内存压力" class="headerlink" title="一些不良代码造成的内存压力"></a>一些不良代码造成的内存压力</h3><p>有些代码并不造成内存泄漏，但是他们， 或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p><p>比如: Bitmap 没有调用 recycle(), 对于 Bitmap 对象在不使用时，我们应该先调用  recycle(), 释放内存，然后设置为 null。 因为加载 bitmap 对象的内存空间，一部分是 Java 的， 一部分是 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的）。而这个 recycle() 就是针对 C 部分的内存释放。构造 Adapter 时，没有使用缓存的 convertView， 每次都在创建新的 converView。 这里推荐使用 ViewHolder。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对 Activity 等组件的引用应该控制在 Activity 的生命周期内；如果不能就考虑使用 <code>getApplicationContext</code> 或者 <code>getApplication</code> ,以避免 Activity 被外部长生命周期的对象引用而泄漏。</p><p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括 context），即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p><p>对生命周期比 Activity 长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样避免内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将内部类改为静态内部类</span><br><span class="line">静态内部类中使用弱引用来引用外部成员的成员变量</span><br></pre></td></tr></table></figure><p>Handler 的持有的引用对象最好使用弱引用，资源释放时，也可以清空 Handler 中的消息，比如在 Activity onStop 或者 onDestory 的时候，取消掉该 Handler 对象的 Message 和 Runnable。</p><p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象是，显式地将此对象赋值为 null, 比如使用完 Bitmap 后，先调用 recycle()， 再赋 null， 清空对图片等资源有直接引用或简洁引用的数组（使用 array.clear(); array=null）等，最好遵循谁创建谁释放的原则。</p><p>正确关闭资源，对于使用了 BroadcastReceived， ContentObserver, File, Cursor, Stream, Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销。</p><p>保持对对象生命周期的敏感，特别注意单例，静态对象，全局性集合等的生命周期。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。&lt;/p&gt;
&lt;h2 id=&quot;Java-内存分配策略&quot;&gt;&lt;a href=&quot;#Java-内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;Java 内存分配策略&quot;&gt;&lt;/a&gt;Java 内存分配策略&lt;/h2&gt;&lt;p&gt;Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。&lt;/li&gt;
&lt;li&gt;栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。&lt;/li&gt;
&lt;li&gt;堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
</feed>
