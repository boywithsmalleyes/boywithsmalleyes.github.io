<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶白</title>
  <icon>https://www.gravatar.com/avatar/f27b936c2ac428d82177b6d3626c8e3a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaoman.ren/"/>
  <updated>2020-09-16T16:15:50.578Z</updated>
  <id>http://xiaoman.ren/</id>
  
  <author>
    <name>茶白</name>
    <email>zhuangbudong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lifecycle 源码分析</title>
    <link href="http://xiaoman.ren/2020/09/17/Lifecycle-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2020/09/17/Lifecycle-源码分析/</id>
    <published>2020-09-16T16:00:39.000Z</published>
    <updated>2020-09-16T16:15:50.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始是废话（翻译自源码）"><a href="#开始是废话（翻译自源码）" class="headerlink" title="开始是废话（翻译自源码）"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 </span></span><br><span class="line">Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME</span><br><span class="line"><span class="comment">// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。</span></span><br><span class="line">Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">DefaultLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStopped</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_CREATE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreated</span><span class="params">(LifecycleOwner source)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_ANY)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onAny</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p><h2 id="那我能做什么呢"><a href="#那我能做什么呢" class="headerlink" title="那我能做什么呢"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p><p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p><p>干货~~~来了</p><p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p><p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Lifecycle-UML"><a href="#Lifecycle-UML" class="headerlink" title="Lifecycle UML"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true" alt="Lifecycle UML"></p><p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p><p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p><h3 id="ComponentActivity-amp-ReportFragment"><a href="#ComponentActivity-amp-ReportFragment" class="headerlink" title="ComponentActivity &amp; ReportFragment"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleOwner 接口，提供了一个 getLifecycle() 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComponentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lifecycle lifecycle = getLifecycle();</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"getLifecycle() returned null in ComponentActivity's "</span></span><br><span class="line">                                        + <span class="string">"constructor. Please make sure you are lazily constructing your Lifecycle "</span></span><br><span class="line">                                        + <span class="string">"in the first call to getLifecycle() rather than relying on field "</span></span><br><span class="line">                                        + <span class="string">"initialization."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">                    Window window = getWindow();</span><br><span class="line">                    <span class="keyword">final</span> View decor = window != <span class="keyword">null</span> ? window.peekDecorView() : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (decor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        decor.cancelPendingInputEvents();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">19</span> &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= <span class="number">23</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> ImmLeaksCleaner(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p><p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If your ComponentActivity is annotated with &#123;<span class="doctag">@link</span> ContentView&#125;, this will</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> #setContentView(int)&#125; for you.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">        setContentView(mContentLayoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p><p>别慌，进去看。</p><h4 id="ReportFragment"><a href="#ReportFragment" class="headerlink" title="ReportFragment"></a><code>ReportFragment</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">    <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p><p>按照 <code>Fragment</code> 的生命周期，我们继续看</p><h5 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a><code>dispatch()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatchStart(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatchResume(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">    mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p><h5 id="handleLifecycleEvent"><a href="#handleLifecycleEvent" class="headerlink" title="handleLifecycleEvent()"></a><code>handleLifecycleEvent()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p><p>你跑，那我就追！</p><h3 id="LifecycleRegister"><a href="#LifecycleRegister" class="headerlink" title="LifecycleRegister"></a><strong><code>LifecycleRegister</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current state and notifies the observers.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that if the &#123;<span class="doctag">@code</span> currentState&#125; is the same state as the last call to this method,</span></span><br><span class="line"><span class="comment">     * calling this method has no effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event The event that was received</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法，我们翻译下注释</p><blockquote><p>设置当前状态，并通知观察者</p><p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p></blockquote><h4 id="getStateAfter"><a href="#getStateAfter" class="headerlink" title="getStateAfter()"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p><p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync()"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">    <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"><span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line"><span class="comment">// so it doesn't have to take in account parents</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"LifecycleOwner of this LifecycleRegistry is already"</span></span><br><span class="line">                                        + <span class="string">"garbage collected. It is too late to change lifecycle state."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p><p>继续分析源码</p><p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p><p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p><h4 id="Lifecycle-State-Sequence"><a href="#Lifecycle-State-Sequence" class="headerlink" title="Lifecycle State Sequence"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_STOP;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_START;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true" alt="Lifecycle State Sequence"></p><p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p><h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a><code>dispatchEvent</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">        mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">        mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            Event event = downEvent(observer.mState);</span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p><p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p><h4 id="ReflectiveGenericLifecycleObserver"><a href="#ReflectiveGenericLifecycleObserver" class="headerlink" title="ReflectiveGenericLifecycleObserver"></a><code>ReflectiveGenericLifecycleObserver</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An internal implementation of &#123;<span class="doctag">@link</span> LifecycleObserver&#125; that relies on reflection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p><p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p><p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p><p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p><p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p><h4 id="reflect-invoke-method"><a href="#reflect-invoke-method" class="headerlink" title="reflect invoke method"></a><code>reflect invoke method</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">                mMethod.invoke(target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">                mMethod.invoke(target, source);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                mMethod.invoke(target, source, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to call observer method"</span>, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p><p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p><p>但是！！！！！！！！！！！！！！！！</p><p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p><h4 id="addObserver"><a href="#addObserver" class="headerlink" title="addObserver()"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p><p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p><p>我们这里要逐行清点</p><p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p><p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p><p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p><p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p><p>总结一下，分析源码我们从两方面入手</p><ol><li><p><code>addObserver()</code></p><p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p><ol><li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li><li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li><li>立即进行状态判断，决定是否处理生命周期变化</li></ol></li><li><p><code>ReportFragment</code></p><p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p></li><li><p><strong>反射</strong></p><p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p></li><li><p><code>sync()</code></p><p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;a href=&quot;#开始是废话（翻译自源码）&quot; class=&quot;headerlink&quot; title=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;/a&gt;开始是废话（翻译自源码）&lt;/h2&gt;&lt;p&gt;定义了一个 Android 生命周期的对象。 &lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;FragmentActivity&lt;/code&gt;类实现&lt;code&gt;LifecycleOwner&lt;/code&gt;接口， 并可以通过 &lt;code&gt;getLifecycle()&lt;/code&gt; 方法来访问生命周期。 我们也可以实现&lt;code&gt;LifecycleOwner&lt;/code&gt;在自己的类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android,Jetpack" scheme="http://xiaoman.ren/tags/Android-Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView</title>
    <link href="http://xiaoman.ren/2020/07/09/RecyclerView/"/>
    <id>http://xiaoman.ren/2020/07/09/RecyclerView/</id>
    <published>2020-07-09T12:33:30.000Z</published>
    <updated>2020-07-09T12:36:43.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RechclerView-总结"><a href="#RechclerView-总结" class="headerlink" title="RechclerView 总结"></a>RechclerView 总结</h1><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true" alt="image-20200709164241306"></p><p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p><p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p><p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p><p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p><p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p><p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p><a id="more"></a><h2 id="RecyclerView-的绘制"><a href="#RecyclerView-的绘制" class="headerlink" title="RecyclerView 的绘制"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p><ul><li><p>自动测量原理：</p><p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p><p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p><p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p><ul><li>STEP_START</li><li>STEP_LAYOUT</li><li>STEP_ANIMATIONS</li></ul><p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p><ul><li>dispatchLayoutStep1:  负责记录状态</li><li>dispatchLayoutStep2：负责布局</li><li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li></ul><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mAdapterHelper.hasUpdates() </span><br><span class="line">              || mLayout.getWidth() != getWidth() </span><br><span class="line">              || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// first 2 steps are done in onMeasure but looks like we have to run again due to changed size</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p><h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p><h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    </span><br><span class="line">    mState.mLayoutStep = State.STATE_ANIMATIONS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!mAnchorInfo.mValid </span><br><span class="line">      || mPendingScrollPosition != NO_POSITION </span><br><span class="line">      || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTIONTAIL</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayouStateToFillEnd(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  流程很负责，大致流程如下</p><ul><li>找到 anchor点</li><li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li><li><p>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</p><p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p><p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">        recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="keyword">while</span>((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start-layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>recycleViewsFromStart</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="keyword">int</span> dt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> limit = dt;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">if</span>(mShouldReverseLayout) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++)&#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span>(mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">              || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">        recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAndRecycleViewAt</span><span class="params">(<span class="keyword">int</span> index, Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = getChildAt(index);</span><br><span class="line">    removeViewAt(index);</span><br><span class="line">    recycler.recycleView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((layoutState.mInfinite || remainningSpace &gt; <span class="number">0</span>) </span><br><span class="line">     &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">    layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要又剩余空间，就会执行 layoutChunk 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)</span></span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    </span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p><p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123;</span><br><span class="line">    addView(view);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addView(view, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p><p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p><h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>最后一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);</span><br><span class="line">            mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span>(record == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;record.flags |= FLAT_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p></li></ul><h3 id="缓存逻辑"><a href="#缓存逻辑" class="headerlink" title="缓存逻辑"></a>缓存逻辑</h3><p>  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> fromScrap = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">fromScrap = holder != <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(hoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="keyword">if</span>(mAdapter.hasStableIds())&#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fallback to recycler</span></span><br><span class="line">            holder = getRecyclerViewPool().getRecyclerView(type);</span><br><span class="line">            <span class="keyword">if</span>(holder != <span class="keyword">null</span>)&#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span>(FORCE_INVALIDATE_DISPLAY_LIST)&#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 LayoutParams 的代码</span></span><br><span class="line">    <span class="keyword">return</span> holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 View 的逻辑可以整理为</p><ul><li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li><li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li><li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li><li>搜索 mRecyclerPool, 如果找到则返回 Holder</li><li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li></ul><p>对于 View 的回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder.isRecyclable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123;</span><br><span class="line">            <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                cachedViewSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">                mCachedViews.add(holder);</span><br><span class="line">                cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder);</span><br><span class="line">            recycled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p><h2 id="与-AdapterView-比较"><a href="#与-AdapterView-比较" class="headerlink" title="与 AdapterView 比较"></a>与 AdapterView 比较</h2><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">AdapterView</th><th style="text-align:center">RecyclerView</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Simple click listener</td><td style="text-align:center">OnItemTouchListener</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Simple Divider</td><td style="text-align:center">ItemDecoration</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ListView and GridView</td><td style="text-align:center">LinearLayoutManager<br>GridLayoutManager..</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">RecyclerBin</td><td style="text-align:center">Recycler</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Header and Footer</td><td style="text-align:center">Partial refresh</td></tr></tbody></table><ul><li><p>点击事件</p><p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p></li><li><p>分割线</p><p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p><p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p></li><li><p>布局类型</p><p>AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。</p></li><li><p>缓存方式</p><p>ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致</p></li></ul><p><strong>不同点</strong></p><ul><li><p>局部刷新</p><p>ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 <code>notifyItemChanged(position)</code> 来完成，甚至可以通过 <code>notifyItemChanged(position, payload)</code> 传入一个 payload 信息来刷新单个 item 中的特定内容。</p></li><li><p>动画</p><p>RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难</p></li><li><p>嵌套布局</p><p>RecyclerView 实现了 <code>NestedScrollingChild</code> 接口，可以和一切嵌套组件很好的工作</p></li></ul><p><strong>ListView 原生特点</strong></p><ul><li><p>头部与尾部支持</p><p>ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、</p></li><li><p>多选</p><p>支持多选和单选的 ListView 更方便</p></li><li><p>多数据源支持</p><p>ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。</p></li></ul><p><strong>总结</strong></p><p>RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RechclerView-总结&quot;&gt;&lt;a href=&quot;#RechclerView-总结&quot; class=&quot;headerlink&quot; title=&quot;RechclerView 总结&quot;&gt;&lt;/a&gt;RechclerView 总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true&quot; alt=&quot;image-20200709164241306&quot;&gt;&lt;/p&gt;
&lt;p&gt;Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View&lt;/p&gt;
&lt;p&gt;Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示&lt;/p&gt;
&lt;p&gt;ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView&lt;/p&gt;
&lt;p&gt;LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成&lt;/p&gt;
&lt;p&gt;Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误&lt;/p&gt;
&lt;p&gt;ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Q 文件权限适配</title>
    <link href="http://xiaoman.ren/2020/03/11/Android-Q-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D/"/>
    <id>http://xiaoman.ren/2020/03/11/Android-Q-文件权限适配/</id>
    <published>2020-03-11T12:11:41.000Z</published>
    <updated>2020-03-11T12:37:13.921Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；<br>Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。</p><p>“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为<br><code>Context.getExternalFilesDir()</code> 下的文件夹。需要传入以下参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Environment.DIRECTORY_MUSIC</span><br><span class="line">Environment.DIRECTORY_PODCASTS</span><br><span class="line">Environment.DIRECTORY_RINGTONES</span><br><span class="line">Environment.DIRECTORY_ALARMS</span><br><span class="line">Environment.DIRECTORY_NOTIFICATIONS</span><br><span class="line">Environment.DIRECTORY_PICUTRES</span><br><span class="line">Environment.DIRECTORY_MOVIES</span><br></pre></td></tr></table></figure><p>可根据具体需要，传入不通的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个文件通过文件夹类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> boxType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> File <span class="title">getFile</span><span class="params">(String fileName, String boxType, String defaultPath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        file = <span class="keyword">new</span> File(defaultPath + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="keyword">null</span> || !file.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码未经测试，忘见谅</strong></p><p>接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：</p><p>访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，<code>Manifest.permission.READ_EXTERNAL_STORAGE</code> 和 <code>Manifest.permission.WRITE_EXTERNAL_STORAGE</code> </p><p>我们来看一下获取相册资源的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Uri contentUri = MediaStore.Files.getContentUri(<span class="string">"external"</span>);</span><br><span class="line">            <span class="keyword">final</span> String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + <span class="string">" DESC"</span>;</span><br><span class="line">            <span class="keyword">final</span> String selection =</span><br><span class="line">                    <span class="string">"("</span> + MediaStore.Files.FileColumns.MEDIA_TYPE + <span class="string">"=?"</span></span><br><span class="line">                            + <span class="string">" OR "</span></span><br><span class="line">                            + MediaStore.Files.FileColumns.MEDIA_TYPE + <span class="string">"=?)"</span></span><br><span class="line">                            + <span class="string">" AND "</span></span><br><span class="line">                            + MediaStore.MediaColumns.SIZE + <span class="string">"&gt;0"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String[] selectionAllArgs = &#123;String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)&#125;;</span><br><span class="line"></span><br><span class="line">            ContentResolver contentResolver = mContext.getContentResolver();</span><br><span class="line">            String[] projections;</span><br><span class="line">            projections = <span class="keyword">new</span> String[]&#123;MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA,</span><br><span class="line">                    MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED,</span><br><span class="line">                    MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore</span><br><span class="line">                    .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE&#125;;</span><br><span class="line"></span><br><span class="line">            Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);</span><br><span class="line">                        <span class="keyword">int</span> mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE);</span><br><span class="line">                        <span class="keyword">int</span> sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE);</span><br><span class="line">                        <span class="keyword">int</span> widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH);</span><br><span class="line">                        <span class="keyword">int</span> heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> size = cursor.getLong(sizeIndex);</span><br><span class="line">                            <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            String type = cursor.getString(mimeTypeIndex);</span><br><span class="line">                            String path = cursor.getString(pathIndex);</span><br><span class="line">                            <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">int</span> width = cursor.getInt(widthIndex);</span><br><span class="line">                            <span class="keyword">int</span> height = cursor.getInt(heightIndex);</span><br><span class="line">                            <span class="keyword">if</span> (width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            File file = <span class="keyword">new</span> File(path);</span><br><span class="line">                            <span class="keyword">if</span> (!file.exists() || !file.isFile()) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            File parentFile = file.getParentFile();</span><br><span class="line">                            <span class="keyword">if</span> (parentFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                images.add(path);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line"></span><br><span class="line">                        cursor.close();</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在<code>AndroidManifest.xml</code> 中的 <code>&lt;application&gt;</code> 标签中加入 <code>android:requestLegacyExternalStorage=&quot;true&quot;</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；&lt;br&gt;Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ASpectJ 初识</title>
    <link href="http://xiaoman.ren/2020/03/06/ASpectJ-%E5%88%9D%E8%AF%86/"/>
    <id>http://xiaoman.ren/2020/03/06/ASpectJ-初识/</id>
    <published>2020-03-06T02:41:22.000Z</published>
    <updated>2020-03-06T08:45:31.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先我们先来了解一下-AOP"><a href="#首先我们先来了解一下-AOP" class="headerlink" title="首先我们先来了解一下 AOP"></a>首先我们先来了解一下 AOP</h2><blockquote><p>AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能</p></blockquote><p>面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。</p><h2 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h2><table><thead><tr><th style="text-align:center">key</th><th style="text-align:center">别名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">Advice</td><td style="text-align:center">通知</td><td>切面的具体行为，要执行的代码</td></tr><tr><td style="text-align:center">PointCut</td><td style="text-align:center">切点</td><td>通知被应用的具体位置</td></tr><tr><td style="text-align:center">Join Point</td><td style="text-align:center">连接点</td><td>程序运行时，能够应用通知的所有点</td></tr><tr><td style="text-align:center">Aspect</td><td style="text-align:center">切面</td><td>什么时候在什么地方做什么事情，是切点和通知的结合</td></tr><tr><td style="text-align:center">Target</td><td style="text-align:center">目标对象</td><td>被切入功能的目标对象</td></tr><tr><td style="text-align:center">Introduction</td><td style="text-align:center">引入</td><td>将新的方法或属性引入到现有的类中</td></tr><tr><td style="text-align:center">Weaving</td><td style="text-align:center">织入</td><td>将切面应用到目标对象并创建新的代理对象的过程</td></tr></tbody></table><p>AOP 底层通过使用动态代理实现，包含两种方式：</p><ol><li>使用 JDK 动态代理实现</li><li>使用 cglib 实现</li></ol><p><strong>通知类型</strong></p><ol><li>前置通知(Befor)：在方法之前执行</li><li>后置通知(After)：在方法之后执行</li><li>异常通知(AfterThrowing)：方法出现异常执行</li><li>最终通知(AfterReturning)：在后置之后执行</li><li>环绕通知(Around)：在方法之前和之后执行</li></ol><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>AspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。</p><p>先写到这里！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先我们先来了解一下-AOP&quot;&gt;&lt;a href=&quot;#首先我们先来了解一下-AOP&quot; class=&quot;headerlink&quot; title=&quot;首先我们先来了解一下 AOP&quot;&gt;&lt;/a&gt;首先我们先来了解一下 AOP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AOP(面向切面编
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OKHttp 重定向拦截器</title>
    <link href="http://xiaoman.ren/2020/02/20/OKHttp-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://xiaoman.ren/2020/02/20/OKHttp-重定向拦截器/</id>
    <published>2020-02-20T09:05:21.000Z</published>
    <updated>2020-02-20T09:07:19.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-OKHttp-进行重定向拦截处理"><a href="#使用-OKHttp-进行重定向拦截处理" class="headerlink" title="使用 OKHttp 进行重定向拦截处理"></a>使用 OKHttp 进行重定向拦截处理</h1><p>okhttp重定向存在两个缺陷：</p><ol><li><p>okhttp处理301,302重定向时，会把请求方式设置为GET<br>这样会丢失原来Post请求中的参数。</p></li><li><p>okhttp默认不支持跨协议的重定向，比如http重定向到https</p></li></ol><p>为了解决这两个问题写了这个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedirectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        HttpUrl beforeUrl = request.url();</span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        HttpUrl afterUrl = response.request().url();</span><br><span class="line">        <span class="comment">//1.根据url判断是否是重定向</span></span><br><span class="line">        <span class="keyword">if</span>(!beforeUrl.equals(afterUrl)) &#123;</span><br><span class="line">            <span class="comment">//处理两种情况 1、跨协议 2、原先不是GET请求。</span></span><br><span class="line">            <span class="keyword">if</span> (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">                <span class="comment">//重新请求</span></span><br><span class="line">                Request newRequest = request.newBuilder().url(response.request().url()).build();</span><br><span class="line">                response = chain.proceed(newRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-OKHttp-进行重定向拦截处理&quot;&gt;&lt;a href=&quot;#使用-OKHttp-进行重定向拦截处理&quot; class=&quot;headerlink&quot; title=&quot;使用 OKHttp 进行重定向拦截处理&quot;&gt;&lt;/a&gt;使用 OKHttp 进行重定向拦截处理&lt;/h1&gt;&lt;p&gt;ok
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 常用工具和插件</title>
    <link href="http://xiaoman.ren/2020/02/20/Android-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://xiaoman.ren/2020/02/20/Android-常用工具和插件/</id>
    <published>2020-02-20T09:04:13.000Z</published>
    <updated>2020-02-20T10:27:58.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-开发必备插件和工具"><a href="#Android-开发必备插件和工具" class="headerlink" title="Android 开发必备插件和工具"></a>Android 开发必备插件和工具</h1><h2 id="Android-Studio-插件"><a href="#Android-Studio-插件" class="headerlink" title="Android Studio 插件"></a>Android Studio 插件</h2><table><thead><tr><th>插件名</th><th>注释</th></tr></thead><tbody><tr><td>Alibaba Java Coding Guidelines</td><td>阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；</td></tr><tr><td>Android Parcelable code generator</td><td>序列化 Po 类时，可以快速生成序列化代码</td></tr><tr><td>CodeGlance</td><td>代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码</td></tr><tr><td>DataBase Navigator</td><td>支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题</td></tr><tr><td>FindBugs-IDEA</td><td>可以分析现存代码中容易引起异常的部分，并提供修改建议</td></tr><tr><td>GsonFormater</td><td>将 xml 和 json 转换位 pojo 类，可以快速生成数据源</td></tr><tr><td>Markdown</td><td>语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档</td></tr><tr><td>Markdown Navigator</td><td>Markdown 预览工具，可以观察实时渲染的 HTML 文档</td></tr><tr><td>Android Resource Tools</td><td>1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码<br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    <br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度</td></tr><tr><td>Codota</td><td>模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示</td></tr><tr><td>GoodFormatter</td><td>保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；</td></tr><tr><td>ButterknifePlugin</td><td>快速生成 butternkife 的注入代码，前提需要引入 butterknife</td></tr><tr><td>JsonViewer</td><td>可以替换 postman 的插件，用来调试接口</td></tr><tr><td>Git Commit Template</td><td>Git 提交记录模版工具</td></tr><tr><td>—</td><td>—</td></tr></tbody></table><a id="more"></a><p><strong>codata</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(File srcFile, File zipFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFile))) &#123;</span><br><span class="line">      zos.putNextEntry(<span class="keyword">new</span> ZipEntry(srcFile.getName()));</span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">while</span> ((len = fis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        zos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br><span class="line">      zos.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AndroidResourceTools</strong><br><img src="https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true" alt></p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true" alt></p><p> <strong>JsonViewer</strong></p><p> <img src="https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true" alt></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>除必要 AS 之外，需要以下工具, Mac 用户可以通过 <a href="https://xclient.info/" target="_blank" rel="noopener">XClient</a> 下载破解版软件</p><table><thead><tr><th>工具</th><th>注释</th></tr></thead><tbody><tr><td>Sublime Text 3</td><td>文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br><strong>PrettyJson</strong> 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> <strong>Markdown</strong> 可以用来写 Markdown 文件，但不支持渲染<br><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3 下载地址</a></td></tr><tr><td>Postman</td><td>接口调试工具，也可以用上面推荐的 <strong>JsonViewer</strong><br><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman 下载地址</a></td></tr><tr><td>Fiddler、Charles</td><td>抓包调试工具，可抓包，修改参数调试接口，任选<br><a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler 下载地址</a><br><a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles 下载地址</a></td></tr><tr><td>Markdown</td><td>Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br><a href="https://typora.io/" target="_blank" rel="noopener">Typora 下载地址</a><br><a href="https://www.mweb.im/" target="_blank" rel="noopener">MWeb Pro 下载地址</a></td></tr><tr><td>Vysor</td><td>Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br><a href="https://www.vysor.io/" target="_blank" rel="noopener">Vysor 下载地址</a></td></tr><tr><td>XMind</td><td>脑图工具，用来写结构<br><a href="https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&amp;ci=737183467&amp;adgroupid=41332915427&amp;adpos=1t1&amp;ck=xminds&amp;targetid=kwd-642237838482&amp;match=p&amp;gnetwork=g&amp;creative=204109085004&amp;placement=&amp;placecat=&amp;accname=setapp&amp;gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB" target="_blank" rel="noopener">XMind 下载地址</a></td></tr><tr><td>Beyond Compare</td><td>文件比较器，比较两组文件的差异<br><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">BeyondCompare 下载地址</a></td></tr><tr><td>Dash</td><td>源码查看器， 也可以使用在线的 <a href="http://androidos.net.cn/sourcecode" target="_blank" rel="noopener">Android 社区</a></td></tr><tr><td>PxCook</td><td>云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。<a href="https://www.fancynode.com.cn/pxcook" target="_blank" rel="noopener">PxCook 下载地址</a></td></tr><tr><td>—</td><td>—</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-开发必备插件和工具&quot;&gt;&lt;a href=&quot;#Android-开发必备插件和工具&quot; class=&quot;headerlink&quot; title=&quot;Android 开发必备插件和工具&quot;&gt;&lt;/a&gt;Android 开发必备插件和工具&lt;/h1&gt;&lt;h2 id=&quot;Android-Studio-插件&quot;&gt;&lt;a href=&quot;#Android-Studio-插件&quot; class=&quot;headerlink&quot; title=&quot;Android Studio 插件&quot;&gt;&lt;/a&gt;Android Studio 插件&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;插件名&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Java Coding Guidelines&lt;/td&gt;
&lt;td&gt;阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android Parcelable code generator&lt;/td&gt;
&lt;td&gt;序列化 Po 类时，可以快速生成序列化代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CodeGlance&lt;/td&gt;
&lt;td&gt;代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataBase Navigator&lt;/td&gt;
&lt;td&gt;支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FindBugs-IDEA&lt;/td&gt;
&lt;td&gt;可以分析现存代码中容易引起异常的部分，并提供修改建议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GsonFormater&lt;/td&gt;
&lt;td&gt;将 xml 和 json 转换位 pojo 类，可以快速生成数据源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Markdown&lt;/td&gt;
&lt;td&gt;语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Markdown Navigator&lt;/td&gt;
&lt;td&gt;Markdown 预览工具，可以观察实时渲染的 HTML 文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android Resource Tools&lt;/td&gt;
&lt;td&gt;1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码&lt;br&gt;2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    &lt;br&gt;3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Codota&lt;/td&gt;
&lt;td&gt;模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GoodFormatter&lt;/td&gt;
&lt;td&gt;保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ButterknifePlugin&lt;/td&gt;
&lt;td&gt;快速生成 butternkife 的注入代码，前提需要引入 butterknife&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JsonViewer&lt;/td&gt;
&lt;td&gt;可以替换 postman 的插件，用来调试接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Git Commit Template&lt;/td&gt;
&lt;td&gt;Git 提交记录模版工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>清香木养殖（四）</title>
    <link href="http://xiaoman.ren/2019/10/17/%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://xiaoman.ren/2019/10/17/清香木养殖（四）/</id>
    <published>2019-10-17T09:11:50.000Z</published>
    <updated>2020-02-20T09:13:37.992Z</updated>
    
    <content type="html"><![CDATA[<p>丢了···································· T_T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;丢了···································· T_T&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 下配置 Android Studio 中文输入</title>
    <link href="http://xiaoman.ren/2019/08/23/Linux-%E4%B8%8B%E9%85%8D%E7%BD%AE-Android-Studio-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5/"/>
    <id>http://xiaoman.ren/2019/08/23/Linux-下配置-Android-Studio-中文输入/</id>
    <published>2019-08-23T02:26:28.000Z</published>
    <updated>2019-08-23T02:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。</p><p>虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。</p><p>最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。</p><p>首先，打开 Android Studio 的文件目录 <code>/android-stdio/bin/</code> ，使用 Vi 命令打开文件 <code>studio.sh</code>，</p><p>在文件的开头，输入下面这一串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export XMODIFIERS=@im=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export GTK_IM_MODULE=&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><p>然后 :wq 保存退出。</p><p>接着重启 Android Studio 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。&lt;/p&gt;
&lt;p&gt;虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。&lt;/p&gt;
&lt;p&gt;最近一直困扰我的一个问题就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 获取 View 的宽高</title>
    <link href="http://xiaoman.ren/2019/08/21/Android-%E8%8E%B7%E5%8F%96-View-%E7%9A%84%E5%AE%BD%E9%AB%98/"/>
    <id>http://xiaoman.ren/2019/08/21/Android-获取-View-的宽高/</id>
    <published>2019-08-21T13:54:08.000Z</published>
    <updated>2019-08-21T15:39:32.625Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中，获取一个 View 的宽高有很多中方法，最直接的就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 View 的宽高，单位是像素</span></span><br><span class="line"><span class="keyword">int</span> height = view.getHeight();</span><br><span class="line"><span class="keyword">int</span> width = view.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 View 的原始测量高度</span></span><br><span class="line"><span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line"><span class="keyword">int</span> width = view.getMeasuredWidth();</span><br></pre></td></tr></table></figure><p>有时需要在 onCreate 方法中获取某个 View 组件的宽度和高度信息，而直接调用 View 组件的 getWidth(), getHeight(), getMeasuredWidth(), getMeasuredHeight(), getTop(), getLeft() 等方法是无法获取到真实值，只会得到 0 ，这是因为 View 组件布局要在 onResume 后回调 。<br><a id="more"></a></p><p>因此，当我们需要 View 的宽高数据时，可以使用 <code>getViewTreeObserver().addOnGlobalLayoutListener()</code> 来获取 View 的宽度或者高度。这是获得一个 View 的宽度和高度的方法之一。</p><p><code>onGlobalLayoutListener()</code> 是 <code>ViewTreeObserver</code> 的内部类，当一个视图树的布局发生改变时，可以被 <code>ViewTreeObserver</code> 监听到，这是一个注册监听视图的观察者(observer)， 在视图树的全局事件改变时得到通知。 <code>ViewTreeObserver</code> 不能直接实例化，而是通过 <code>getViewTreeObserver()</code> 获得。</p><p>其中，我们可以利用 <code>OnGlobalLayoutListener</code> 来获取一个视图的真实高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line">imageView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        positionX = imageView.getX();</span><br><span class="line">        positionY = imageView.getY();</span><br><span class="line">        height = imageView.getHeight();</span><br><span class="line">        widht = imageView.getWidth();</span><br><span class="line">        imageView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>OnGlobalLayoutListener</code> 可能会被多次触发，因此在得到了高度之后，要将 <code>OnGlobalLayoutListener</code> 注销掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="ViewTreeObserver"><a href="#ViewTreeObserver" class="headerlink" title="ViewTreeObserver"></a>ViewTreeObserver</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class ViewTreeObserver extends Object</span><br><span class="line">java.lang.Object</span><br><span class="line">android.view.ViewTreeObserver</span><br></pre></td></tr></table></figure><p>是一个注册监听视图的观察者（Observer），在视图树全局事件改变时得到通知。这个全局事件不仅包括整个树的布局，从绘画过程开始，触摸模式的改变等。ViewTreeObserver 不能够被应用程序实例化，因为它是由视图提供 <code>getViewTreeObserver()</code></p><p><strong>基本常用的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当在一个视图书中的焦点状态发生改变时，所要调用的回调函数接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalFocusChangeListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在一个视图树中全局布局发生改变时或者视图树中的某个视图的可视化状态发生改变时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalLayoutListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树将要绘制时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树中的组件发生滚动时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnScrollChangedListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个视图树中的触摸模式发生改变时，用于监听 touch 和非 touch 的转换</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnTouchModeChangeListener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听布局的变化</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnGlobalLayoutLitener</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 ViewTreeObserver 是否可用，不可用时，任何方法调用都会报错</span></span><br><span class="line">getViewTreeObserver().isAlive();</span><br><span class="line"></span><br><span class="line">addOnWindowAttachListener</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnGlobalFocusChangeListener</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnScrollChangedListener</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnTouchModeChangeListener</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当整个布局发生改变时通知相应的注册监听器。如果你强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者在GONE状态下，它可以被手动的调用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchOnGlobalLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当一个视图树将要绘制时通知相应的注册监听器，如果返回 true， 则这个绘制将被取消并重新计划。如果强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者一个在 gone 状态下，将被手动调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchOnPreDraw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发中，获取一个 View 的宽高有很多中方法，最直接的就是：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回 View 的宽高，单位是像素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height = view.getHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; width = view.getWidth();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回 View 的原始测量高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height = view.getMeasuredHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; width = view.getMeasuredWidth();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时需要在 onCreate 方法中获取某个 View 组件的宽度和高度信息，而直接调用 View 组件的 getWidth(), getHeight(), getMeasuredWidth(), getMeasuredHeight(), getTop(), getLeft() 等方法是无法获取到真实值，只会得到 0 ，这是因为 View 组件布局要在 onResume 后回调 。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java Reference</title>
    <link href="http://xiaoman.ren/2019/08/09/Java%20%E5%90%84%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xiaoman.ren/2019/08/09/Java 各引用之间的区别/</id>
    <published>2019-08-09T13:54:08.000Z</published>
    <updated>2019-08-12T02:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reference-引用"><a href="#Reference-引用" class="headerlink" title="Reference 引用"></a>Reference 引用</h2><p>继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。</p><p>三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：</p><ul><li>Referent： 被引用对象</li><li>ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>　</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"in Person finalize"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="StrongReference-强引用"><a href="#StrongReference-强引用" class="headerlink" title="StrongReference 强引用"></a>StrongReference 强引用</h2><p>Java 中使用的最多，普通的引用 <code>Object obj = new Object();  Person p = new Person();</code> 都属于<code>强引用</code> </p><p>强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。</p><p>一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。</p><h2 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference 软引用"></a>SoftReference 软引用</h2><p>软引用普通使用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;Person&gt;(person);</span><br></pre></td></tr></table></figure><p>强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSofeReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建强引用对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为"</span> + person);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建软引用对象</span></span><br><span class="line">    SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;Person&gt;(person);</span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)</span></span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br></pre></td></tr></table></figure><ul><li>当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。</li><li>我们继续执行 <code>System.gc()</code> 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。</li></ul><p><strong>软引用所指向的对象要进行回收，需要满足两个条件：</strong></p><ol><li>没有任何强引用指向软引用指向的对象（内存中的 Person 对象）</li><li>JVM 需要内存时，即在抛出 OOM 之前</li></ol><p><strong>总结：</strong> SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</p><p><strong>软引用还可以和一个 ReferenceQueue 一起使用，</strong> 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReferenceWithQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为："</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    SoftReference&lt;Person&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(person, queue);</span><br><span class="line">    </span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）</span></span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"加入 ReferenceQueue 的对象为："</span> + queue.poll());</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"加入 ReferenceQueue 的对象为： "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述例子，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">加入 ReferenceQueue 的对象为 null</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">加入 ReferenceQueue 的对象为 null</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p><p>而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</p><h2 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference 弱引用"></a>WeakReference 弱引用</h2><p>弱引用的一般使用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为： "</span> + person);</span><br><span class="line">    </span><br><span class="line">    WeakReference&lt;Person&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(person);</span><br><span class="line">    person = <span class="keyword">null</span>; <span class="comment">// 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。</span></span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c</span><br><span class="line">person 对象进入 GC 流程</span><br><span class="line">in Person finalize</span><br></pre></td></tr></table></figure><ul><li><p>当执行 <code>person = null</code> 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。</p><p>此时调用 <code>wr.get()</code> 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 <code>wr.get()</code> 方法返回不为空。</p></li><li><p>继续执行 <code>System.gc()</code> 强制执行垃圾回收，打印结果可以看到，<code>wr.get()</code> 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。</p></li></ul><p><strong>弱引用所指向的对象要进行回收，只需要满足条件：</strong></p><p>​    没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）</p><p><strong>总结：</strong></p><p>​    WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。</p><p><strong>其主要使用场景见于：</strong> </p><p>​    当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 <code>WeakReference</code> 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。</p><p>与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReferenceWithQueue</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为 "</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    WeakReference&lt;Person&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(person, queue);</span><br><span class="line">    System.out.println(<span class="string">"wr 对象为 "</span> + wr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Whether or not this reference has been enqueued:"</span> + wr.isEnqueued());</span><br><span class="line">    System.out.println(<span class="string">"Queue item: "</span> + queue.pull());</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wr.get() == <span class="keyword">null</span>) &#123;<span class="comment">// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</span></span><br><span class="line">        System.out.println(<span class="string">"person 对象进入 GC 流程"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person 对象尚未被回收"</span> + wr.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确保垃圾回收线程能够执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Whether or not this reference has been enqueued: "</span> + wr.isEnqueued());</span><br><span class="line">    System.out.println(<span class="string">"queue item: "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">wr 对象为 java.lang.ref.WeakReference@603828d2</span><br><span class="line">person 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">Whether or not this reference has been enqueued: false</span><br><span class="line">queue item: null</span><br><span class="line">person 对象进入回收流程</span><br><span class="line">in Person finalize</span><br><span class="line">Whether or not this reference has been enqueued: true</span><br><span class="line">queue item: java.lang.ref.WeakReference@603828d2</span><br></pre></td></tr></table></figure><p>从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。</p><p><strong>注意：</strong></p><p>​     当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p><p>​    而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。</p><h2 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference 虚引用"></a>PhantomReference 虚引用</h2><p>虚引用源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhantomReference</span><span class="params">(T var1, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PhantomReference 只有一个构造函数 <code>PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q)</code>  因此，PhantomReference 使用必须结合 ReferenceQueue；</li><li>不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPhantomReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">"person 对象为"</span> + person);</span><br><span class="line">    </span><br><span class="line">    ReferenceQueue&lt;Person&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;Person&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(person, queue);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"pr 对象为"</span> + pr);</span><br><span class="line">    System.out.println(<span class="string">"pr.get() = "</span> + pr.get());</span><br><span class="line">    </span><br><span class="line">    person = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 确保垃圾回收线程执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"queue item: "</span> + queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person 对象为 com.example.ReferenceTEst$Person@522d9d8c</span><br><span class="line">pr 对象为 java.lang.ref.PhantomReference@60e35b53</span><br><span class="line">pr.get() = null</span><br><span class="line">in Person finalize</span><br><span class="line">queue ite: java.lang.ref.PhantomReference@60e35b53</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>​    与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并才去必要的行动）</p><p><strong>用途：</strong></p><p>​    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p>​    程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。</p><p>​    程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reference-引用&quot;&gt;&lt;a href=&quot;#Reference-引用&quot; class=&quot;headerlink&quot; title=&quot;Reference 引用&quot;&gt;&lt;/a&gt;Reference 引用&lt;/h2&gt;&lt;p&gt;继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。&lt;/p&gt;
&lt;p&gt;三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Referent： 被引用对象&lt;/li&gt;
&lt;li&gt;ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceTest&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;　&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finalize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;in Person finalize&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 内存管理</title>
    <link href="http://xiaoman.ren/2019/08/04/Android%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://xiaoman.ren/2019/08/04/Android 内存管理/</id>
    <published>2019-08-04T13:54:08.000Z</published>
    <updated>2019-08-12T08:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。</p><h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。</p><ul><li>静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li><li>栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。</li></ul><a id="more"></a><h2 id="堆与栈的区别："><a href="#堆与栈的区别：" class="headerlink" title="堆与栈的区别："></a>堆与栈的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p><p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊变量，这个变量的取值等于数组或者对象在内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">    Sample sample1 = <span class="keyword">new</span> Sample();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">        Sample sample2 = <span class="keyword">new</span> Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sample sample3 = <span class="keyword">new</span> Sample();</span><br></pre></td></tr></table></figure><p>Sample 类的局部变量 s2 和引用变量 sample2 都是存在于栈中，但 smaple2 指向的对象是存在于堆中。 sample3 指向的对象存放在堆中，包括这个对象的所有成员变量 s1 和 sample1， 而它自己存在与栈中。</p><p><strong>结论：</strong></p><ul><li>局部变量的脚本数据类型和引用存储在栈中，引用的对象实体存储于堆中。—— 因为他们属于方法中的变量，生命周期随方法而结束</li><li>成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。—— 因为他们属于类，类对象终究是要被 new 出来使用的。</li></ul><h2 id="Java-是如何管理内存"><a href="#Java-是如何管理内存" class="headerlink" title="Java 是如何管理内存"></a>Java 是如何管理内存</h2><p>Java 的内存管理就是对象的分配和释放的问题。在 Java 中，coder 需要通过关键字 new 为每一个对象申请新的存储空间（基本类型除外），所有的对象都在 堆（Heap）中分配空间。另外对象的释放是由 GC 决定和执行的，在 Java 中，内存分配是由 coder 完成的，而内存释放是由 GC 完成的。这种收支两条线的方法简化了 coder 的工作。同时也加重了 JVM 的工作。也是 Java 程序运行速度慢的原因之一。因为 GC 为了能够正确释放对象， GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要监控。</p><p>监控对象状态是为了更准确、及时地释放对象，而释放对象的根本原则就是该对象不在被引用。</p><p><img src="https://camo.githubusercontent.com/ba01b8ae9af4a5e588251316c826bf3e0e695f35/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f312e676966" alt></p><p>Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要他们和根进程不可达，那么 GC 就可以回收他。这种管理方式的有点是管理内存的精度高，但是效率低。</p><h2 id="什么是-Java-中的内存泄露"><a href="#什么是-Java-中的内存泄露" class="headerlink" title="什么是 Java 中的内存泄露"></a>什么是 Java 中的内存泄露</h2><p>在 Java 中，内存泄露就是存在一些被分配的对象，这些对象有两个特点。</p><ul><li>这些对象是可达的，即在有向图中，存在通路与其相连</li><li>这些对象是无用的，即程序以后不会在使用这些对象。</li></ul><p>如果满足这两个条件，这些对象就可以判定为 Java 中的内存泄露，这些对象不会被 GC 回收，但却是占用着内存。</p><p>对于程序猿来说， GC 基本是透明的，不可见的。虽然我们只有几个函数可以方位 GC， 例如运行 GC 的函数 <code>System.gc()</code>，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾回收器一定会执行。因为，不同的 JVM 实现着可能使用不同的算法管理 GC。 通常 GC 的线程优先级比较低。 JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定成都时， GC 才开始工作；也有定时执行，有的是平缓执行 GC， 有的是中断式执行 GC。 通常来说，我们不需要关心这些。除非在一些特定的场合， GC 的执行影响应用程序的性能，例如对于基于 Web 的实时系统，如网络游戏等，用户不希望 GC 突然终端应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行， Sun 提供了 HotSpot JVM 支持这一特性。</p><p>同样给出一个 Java 内存泄露的典型例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然应用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p><h2 id="详细的-Java-中的内存泄露"><a href="#详细的-Java-中的内存泄露" class="headerlink" title="详细的 Java 中的内存泄露"></a>详细的 Java 中的内存泄露</h2><h3 id="Java-内存回收机制"><a href="#Java-内存回收机制" class="headerlink" title="Java 内存回收机制"></a>Java 内存回收机制</h3><p>不论那种语言的内存分配方式，都需要返回所分配的真实地址，也就是返回一个指针到内存块的首地址。Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的。所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成。 GC 为了能够正确释放对象，会监控每个对象的运行状态，对他们的申请、引用、被引用、赋值等状况进行监控， Java 会使用有向图的方式进行管理内存，实时监控对象是否可以到达，如果不可以到达，则将其回收，这样也可以消除引用的循环问题。在 Java 语言中，判断一个内存空间是否符合垃圾回收标准有两个：</p><pre><code>1. 给对象赋予了空值 null   2. 给对象赋予了新值，这样重新分配了内存空间。</code></pre><h3 id="Java-内存泄漏引起的原因"><a href="#Java-内存泄漏引起的原因" class="headerlink" title="Java 内存泄漏引起的原因"></a>Java 内存泄漏引起的原因</h3><p>内存泄露是指无用对象（不再使用的对象）持续占有内存活无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄漏有时不严重，不易察觉，这样开发者就不知道存在内存泄漏，但有时也很严重，会提示 Out of memory。</p><p>Java 内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被释放回收，这就是 Java 中内存泄漏的发生场景，主要有一下几大类：</p><ol><li><p>静态集合类引起的内存泄漏：</p><p>像 HashMap、Vector 等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等引用着。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vercor(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，循环申请 <code>Object</code> 对象，并将所申请的对象放入一个 Vector 中，如果仅仅释放引用本身（o = null），那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可会说的。因此对象加入到 Vector 后， 还必须从 Vector 中删除，最简单的是将 Vector 设置为 null。</p></li><li><p>当集合里面的对象属性被修改后，再调用 remove() 方法时，不起作用</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>, <span class="string">"pwd1"</span>, <span class="number">25</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>, <span class="string">"pwd2"</span>, <span class="number">24</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>, <span class="string">"pwd3"</span>, <span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"总共有："</span> + set.size() + <span class="string">" 个元素"</span>);<span class="comment">// 结果： 总共有 3 个元素</span></span><br><span class="line">    p3.setAge(<span class="number">2</span>); <span class="comment">// 修改 p3 的年龄，此时 p3 元素对应的 hashcode 值发生改变</span></span><br><span class="line">    </span><br><span class="line">    set.remove(p3); <span class="comment">// remove 掉，造成内存泄露</span></span><br><span class="line">    </span><br><span class="line">    set.add(p3); <span class="comment">// 重新添加，成功</span></span><br><span class="line">    </span><br><span class="line">   System.out.println(<span class="string">"总共有："</span> + set.size() + <span class="string">" 个元素"</span>); <span class="comment">// 结果：总共有 4 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : set) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监听器</p><p>在 Java 变成中，我们需要和监听器打交道，通常一个应用当中会有多个监听器，我们会调用一个控件的例如<code>addXXXXListener()</code> 等方法来增加监听器，但往往在释放对象的时候，却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p></li><li><p>各种连接</p><p>比如数据库连接（dataSourse.getConnection()）、 网络连接(socket) 和 io 连接，除非其显示的调用了其 <code>close()</code> 方法将其连接关闭，否则是不会自动被 GC 回收的。对于 Resultset 和 Statement 对象可以不进行显示回收，但 Connection 一定要显示回收，因为 Connection 在任何时候都无法自动回收，而 Connection 一旦回收， Resultset 和 Statement 对象就会立即2为 NULL。 但是如果使用连接池，情况就不一样了，除了要显示地关闭链接，还必须显示地关闭 Resultset 和 Statement 对象（关闭其中一个， 另外一个也会关闭），否则就会造成大量的 Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在 try 里面去连接，在 finally 里面释放连接。</p></li><li><p>内部类和外部模块的引用</p><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后续类对象没有释放。此外 coder 还要小心外部模块不经意的引用，例如 coder A 负责 A 模块，调用了 B 模块的一个方法： <code>public void registerMsg(Object b);</code> 这种调用就要小心，传入了一个对象，很可能模块 B 就保持了对该对象的引用，这时候就需要注意模块 B 是否提供响应的操作去除引用。</p></li><li><p>单例模式</p><p>不正确的使用单例模式是引起内存泄漏的一个常见问题，单利对象在初始化后，将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B instance = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">b</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instacne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然 B 采用 singleton 模式， 它持有一个 A 对象的引用，而这个类的对象将不能被回收。想象下如果 A 是个比较复杂的对象或者集合类型会发生什么。</p></li></ol><h2 id="Android-中常见的内存泄漏汇总"><a href="#Android-中常见的内存泄漏汇总" class="headerlink" title="Android  中常见的内存泄漏汇总"></a>Android  中常见的内存泄漏汇总</h2><h3 id="集合类泄漏"><a href="#集合类泄漏" class="headerlink" title="集合类泄漏"></a>集合类泄漏</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的例子中就是其中一种情况，当然实际上我们在项目中肯定不会这样谢代码，但稍不注意还是很容易出现这种情况。</p><h3 id="单例造成的内存泄露"><a href="#单例造成的内存泄露" class="headerlink" title="单例造成的内存泄露"></a>单例造成的内存泄露</h3><p>由于单利的静态特性使得其生命周期跟应用一样长，所以如果使用不恰当的话，很容易造成内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connect = connect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context， 所以这个 Context 的生命周期的长短至关重要：</p><ol><li>如果此时传入的是 Application 的 Context， 因为 Application 的生命周期就是这个应用的生命周期，所以这将没有任何问题。</li><li>如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的应用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时，它的内存并不会被释放，就会造成泄漏。</li></ol><p><strong>正确的方式应修改为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span> <span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();<span class="comment">// 使用 Application 的 context</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样写，连 Context 都不用传进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在你的 Application 中添加一个静态方法， getContext() 返回 Application 的 context</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">context = getApplicationContext();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取全局的 Context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回全局的 context 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    reutnr context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = MyApplication.getContext();<span class="comment">// 使用 Application 的 context</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> staitc AppManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类-非静态内部类和异步线程"><a href="#匿名内部类-非静态内部类和异步线程" class="headerlink" title="匿名内部类/非静态内部类和异步线程"></a>匿名内部类/非静态内部类和异步线程</h3><p>非静态内部类创建静态实例造成的内存泄漏</p><p>有的时候我们可能会在启动频繁的 Activity 中，为了避免重复创建相同资源，可能会出现这种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> staitc TestResource mResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mResource = <span class="keyword">new</span> TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 都会使用该单利的数据，这样虽然避免了资源的重复创建，不过这种写法却造成了内存写泄漏，因为<strong>非静态内部类默认会持有外部类的引用</strong>，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法：</p><p>将该内部类设为静态内部类或者将该内部类抽取出来封装成单例，如果需要使用 Context， 按照上一个方法推荐使用 Application 中的 Context。 当然 Application 的 Context 不是万能的，所以也不能随便乱用，对于有些地方则是必须使用 Activity 的 Context ，对于 Application，Service， Activity 三者的 Context 的应用场景如下：</p><p><img src="https://camo.githubusercontent.com/dee4aecb8a80c4e73337b56ee01cbffa2a8049dd/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303135313132333134343232363334393f73706d3d353137362e3130303233392e626c6f67636f6e742e392e437455316334" alt="Application, Service, Activity 的 Context 使用场景"></p><p>其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>Android 开发经常会继承实现 Activity/Fragment/View， 此时如果你使用了匿名类，并被异步线程持有，如果没有任何措施这样一定会导致泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Runnable ref1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Runnable ref2 = <span class="keyword">new</span> Runnable ()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ....</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref1 和 ref2 的区别是， ref2 使用了匿名内部类。我们看一下运行时，这两个引用的内存：</p><p><img src="https://camo.githubusercontent.com/2b1a52551d828d9640f23ee7c2802476b02ccec3/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f666230356666366432653638663330396239346464383433353263383161636665306165383339653f73706d3d353137362e3130303233392e626c6f67636f6e742e31302e437455316334" alt></p><p>可以看到 ref1 没什么特别的。</p><p>但 ref2 这个匿名类的实现对象里面多了一个引用：</p><p>this$0 这个引用指向 MainActivity.this， 也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就会造成内存泄漏。</p><h3 id="Handler-造成的内存泄漏"><a href="#Handler-造成的内存泄漏" class="headerlink" title="Handler 造成的内存泄漏"></a>Handler 造成的内存泄漏</h3><p>Handler 的使用造成的内存泄漏问题应该说是最常见的，但很多时候我们为了避免 ANR 而不在主线程中进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写不规范就有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p><p>由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，很容易导致无法正确释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handerl()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundler savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// post a message and delay its execution for 10 minutes.</span></span><br><span class="line">        mLeakHandler.postDelayed(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">6</span> * <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// go back to the previous Activity</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该例中，生命了一个延时 10 分钟执行的消息 Message， mLeakyHandler 将其 push 进了消息队列 MessageQueue 中。当 Activity 被 finish() 掉，延时任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，此时 finish() 掉的 Activity 就不会被回收，从而造成内存泄漏（<strong>因 Handler 为非静态内部类，会持有外部类的引用，在这里就是 MainActivity</strong>）.</p><p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 生命为静态的，则其存活期和 Activity的 生命周期无关了，同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 Context 传入， 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Instence of static inner classes do not bold an implicit reference to their outer class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span> <span class="params">(SampleActivity activity)</span> </span>&#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            SampleActivity activity = mActivity.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Instance of anonymous classes do not hold an implicit </span></span><br><span class="line"><span class="comment">    * reference to their outer class when they are "static"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable ()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundler savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Post a message and delay its execution for 10 mintues.</span></span><br><span class="line">        mHandler.postDelay(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// go back to the previous Activity</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综述， 即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p><p>前面提到的 WeakReference，所以这里简单说下 Java 中对象的几种引用类型。</p><p>Java 对引用分为 StrongReference， SoftReference， WeakReference和 PhantomReference 四种。</p><table><thead><tr><th>级别</th><th>回收时机</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强(StrongReference)</td><td>从来不会</td><td>对象的一般状态</td><td>JVM 停止运行时终止</td></tr><tr><td>软(SoftReference)</td><td>在内存不足时</td><td>联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器(内存不足才清空)</td><td>内存不足时终止</td></tr><tr><td>弱（WeakReference）</td><td>在垃圾回收时</td><td>联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器(系统发生 gc 则清空)</td><td>gc 运行后终止</td></tr><tr><td>虚（PhantomReference）</td><td>在垃圾回收时</td><td>联合 ReferenceQueue 来跟踪对象被垃圾回收器回收的活动</td><td>gc 运行后终止</td></tr></tbody></table><p>在 Android 应用开发中，为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p><p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联得的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清楚已失效的软/弱引用。</p><p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次去读取图片，由于读取文件需要硬件操作，速度很慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是由于图片占用空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生 OutOfMemery 异常。这时我们可以考虑使用软/弱引用技术来避免这个问题发生。以下是高速缓冲器的雏形：</p><p>首先定义一个 HashMap，保存软引用对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><p>再定义一个方法，保存 bitmap 的软引用到 HashMap。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CacheBySoftRef &#123;</span><br><span class="line">    // 先定义一个 HashMap，保存软引用对象</span><br><span class="line">    private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    // 再定义一个方法，保存 bitmap 的软引用到 HashMap。</span><br><span class="line">    public void addBitmapToCache(String path) &#123;</span><br><span class="line">        // 强引用的 Bitmap 对象</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">        // 软引用的 bitmap 对象</span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">        imageCache.put(path, softBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取的时候，可以通过 SoftReference 的 get() 方法得到 bitmap 对象</span><br><span class="line">    public Bitmap getBitmapByPath(String path) &#123;</span><br><span class="line">        // 从缓存中取软引用的 bitmap 对象</span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line">        // 判断是否存在软引用</span><br><span class="line">        if (softBitmap == null)  return;</span><br><span class="line">        // 通过软引用取出 bitmap 对象，如果由于内存不足 Bitmap 被回收，将取到空，如果未被回收，则可重复使用，提高速度</span><br><span class="line">        Bitmap bitmap = softBitmap.get();</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用软引用以后，在 OutOfMemory 异常发生之前，这些缓存的图片资源的内存空间可以被释放掉，从而避免内存达到上线，避免 Crash 发生。</p><p>如果只是想避免 OutOfMemory 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><p>另外可以根据对象<strong>是否经常使用</strong>来判断选择软引用还是弱引用。如果对象可能会经常使用，就尽可能的使用软引用。如果对象不被使用的可能性更大，就用弱引用。</p><p>前面所说，创建一个静态的 Handler 内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 的泄漏，不过 Looper 线程的消息队列中，还是可能会有待处理的消息，所以我们在 Activity 的 onDestory() 时，或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p><p>移除消息队列中 Message 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r, Objject token)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="尽量避免使用-static-成员变量"><a href="#尽量避免使用-static-成员变量" class="headerlink" title="尽量避免使用 static 成员变量"></a>尽量避免使用 static 成员变量</h3><p>如果成员变量被声明为 static, 那我们都知道其生命周期将与整个 APP 进程生命周期一样。</p><p>这会导致一些列问题，如果你的 APP 进程设计上是常驻内存的，那即使 APP 切到后台，这部分内存也不会被释放。按照现在手机 APP 内存管理机制，占内存较大的后台集成将优先回收，因为如果此 APP 做过进程互相保活，那会造成 APP 在后台频繁重启。当手机安装了你参与开发的 APP 以后一夜时间手机被消耗空了电量、流量，你的 APP 不得不被用户卸载或者静默。</p><p>修复方法是：</p><p>不要在类初始化时初始化静态成员。可以考虑 lazy 初始化。架构设计上要死好是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p><h3 id="避免-Override-finalize"><a href="#避免-Override-finalize" class="headerlink" title="避免 Override finalize()"></a>避免 Override finalize()</h3><ol><li><p>finalize 方法被执行的时间不确定，不能依赖它来释放紧缺的资源，时间不确定的原因是：虚拟机调用 GC 的时间不确定 finalize daemon 线程被调度到的时间不确定。</p></li><li><p>finalize 方法只会被执行一次，及时对象被复活，如果已经执行过 finalize 方法，再次被 GC 时，也不会再执行，原因是：</p><p>含有 finalize 方法的 Object 是在 new 的时候，由虚拟机生成了一个 finalize reference 在来引用到该 Object的，而在finalize 方法执行的时候，该 Object 所对应的 finalize Reference 会被释放掉。即使在这个时候把该Object 复活（即用强引用引用住该 Object），再第二次被 GC 的时候，由于没有了 finalize Reference 与之对应，所以 finalize 方法不会再执行。</p></li><li><p>含有 finalize 方法的 Object 需要至少经过两轮 GC 才有可能被释放。</p></li></ol><h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h3><p>对于使用了 BroadcastRevicer, ContentObserver, File， 游标 Cursor， Stream， Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p><h3 id="一些不良代码造成的内存压力"><a href="#一些不良代码造成的内存压力" class="headerlink" title="一些不良代码造成的内存压力"></a>一些不良代码造成的内存压力</h3><p>有些代码并不造成内存泄漏，但是他们， 或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p><p>比如: Bitmap 没有调用 recycle(), 对于 Bitmap 对象在不使用时，我们应该先调用  recycle(), 释放内存，然后设置为 null。 因为加载 bitmap 对象的内存空间，一部分是 Java 的， 一部分是 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的）。而这个 recycle() 就是针对 C 部分的内存释放。构造 Adapter 时，没有使用缓存的 convertView， 每次都在创建新的 converView。 这里推荐使用 ViewHolder。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对 Activity 等组件的引用应该控制在 Activity 的生命周期内；如果不能就考虑使用 <code>getApplicationContext</code> 或者 <code>getApplication</code> ,以避免 Activity 被外部长生命周期的对象引用而泄漏。</p><p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括 context），即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p><p>对生命周期比 Activity 长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样避免内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将内部类改为静态内部类</span><br><span class="line">静态内部类中使用弱引用来引用外部成员的成员变量</span><br></pre></td></tr></table></figure><p>Handler 的持有的引用对象最好使用弱引用，资源释放时，也可以清空 Handler 中的消息，比如在 Activity onStop 或者 onDestory 的时候，取消掉该 Handler 对象的 Message 和 Runnable。</p><p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象是，显式地将此对象赋值为 null, 比如使用完 Bitmap 后，先调用 recycle()， 再赋 null， 清空对图片等资源有直接引用或简洁引用的数组（使用 array.clear(); array=null）等，最好遵循谁创建谁释放的原则。</p><p>正确关闭资源，对于使用了 BroadcastReceived， ContentObserver, File, Cursor, Stream, Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销。</p><p>保持对对象生命周期的敏感，特别注意单例，静态对象，全局性集合等的生命周期。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。&lt;/p&gt;
&lt;h2 id=&quot;Java-内存分配策略&quot;&gt;&lt;a href=&quot;#Java-内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;Java 内存分配策略&quot;&gt;&lt;/a&gt;Java 内存分配策略&lt;/h2&gt;&lt;p&gt;Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。&lt;/li&gt;
&lt;li&gt;栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。&lt;/li&gt;
&lt;li&gt;堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler 线程通信基础流程</title>
    <link href="http://xiaoman.ren/2019/08/01/Handler%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/"/>
    <id>http://xiaoman.ren/2019/08/01/Handler 线程通信基础流程/</id>
    <published>2019-08-01T13:54:08.000Z</published>
    <updated>2019-08-15T12:31:50.813Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">// 传入的参数代表这个 Queue 是否能够被退出</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper 在构造函数里做了两件事儿：</p><ol><li>将线程对象指向了创建的 Looper 的线程</li><li>创建了一个新的  MessageQueue</li></ol><p>分析完构造函数后，看下面两个方法</p><ol><li>looper.loop()</li><li>looper.prepare()</li></ol><a id="more"></a><h3 id="looper-loop"><a href="#looper-loop" class="headerlink" title="looper.loop()"></a>looper.loop()</h3><p>在当前线程中启动一个 Message loop 机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">// 获取当前线程绑定的 Looper</span></span><br><span class="line">    <span class="keyword">if</span>(me == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn`t called on this thread"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue();<span class="comment">// 获取与 Looper 绑定的 MessageQueue</span></span><br><span class="line">    <span class="comment">// make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// And keep track of what that identity token actuall is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    fianl <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入死循环，不断获取对象，分发对象到 Handler 中去消费</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        Message msg = queue.next();<span class="comment">// 不断获取下一个 message 对象，这里可能会造成阻塞。</span></span><br><span class="line">        <span class="keyword">if</span>(msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message idicates that the message queue is quittig.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span>(logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> + msg.callback _ <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在这里开始分发 Message </span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the identity of the thread wasn`t corrupted.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span>(ident != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当分发完 Message 后，当然要标记将该 Message 为 “正在使用”</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，最重要的方法是：</p><ol><li><code>queue.next()</code></li><li><code>msg.target.dispatchMessage(msg)</code></li><li><code>msg.recycleUnchecked()</code></li></ol><p>其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下:</p><ol><li>MessageQueue： 装食物的容器</li><li>Message ：被装的食物</li><li>Handler （msg.target 实际上就是 Handler）：食物的消费者</li><li>Looper：负责分发食物的人</li></ol><h3 id="looper-prepare-在当前线程关联一个-Lopper-对象"><a href="#looper-prepare-在当前线程关联一个-Lopper-对象" class="headerlink" title="looper.prepare() 在当前线程关联一个 Lopper 对象"></a>looper.prepare() 在当前线程关联一个 Lopper 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Lopper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在当前线程绑定一个 looper</span></span><br><span class="line">    mThreadLocal.set(<span class="keyword">new</span> Looper(quiteAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，做了两件事儿：</p><ol><li>判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。</li><li>如果有的话，那么就设置一个新的 Looper 到当前线程。</li></ol><h3 id="Handler-的使用"><a href="#Handler-的使用" class="headerlink" title="Handler 的使用"></a>Handler 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler ()&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handle your message</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看下 Handler 的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空参构造与之对应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callbacck, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大姨泄漏提醒log</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取与创建 Handler 线程的 Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span>(mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RunntimeException(<span class="string">"Can`t create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 Looper 绑定的 MessageQueue</span></span><br><span class="line">    <span class="comment">// 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？</li><li>handler.handleMessage(msg) 在什么时候被回调的？</li></ol><p><strong>A1:</strong> Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg)  还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用 Handler 中的 MessageQueue</span></span><br><span class="line">    <span class="comment">// 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue</span></span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">        <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called withe no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 Message 加入到 MessageQueue 中</span></span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下 <code>enququeMessage(queue, msg, uptimeMillis)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enququeMessage</span><span class="params">(MessageQueue, queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">   msg.target = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">if</span>(mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A2</strong>:  handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">diapatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); <span class="comment">// 开始回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。</p><p>一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。&lt;/p&gt;
&lt;h2 id=&quot;Looper&quot;&gt;&lt;a href=&quot;#Looper&quot; class=&quot;headerlink&quot; title=&quot;Looper&quot;&gt;&lt;/a&gt;Looper&lt;/h2&gt;&lt;p&gt;在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; quitAllowed)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mQueue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MessageQueue(quitAllowed);&lt;span class=&quot;comment&quot;&gt;// 传入的参数代表这个 Queue 是否能够被退出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mThread = Thread.currentThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Looper 在构造函数里做了两件事儿：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将线程对象指向了创建的 Looper 的线程&lt;/li&gt;
&lt;li&gt;创建了一个新的  MessageQueue&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析完构造函数后，看下面两个方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;looper.loop()&lt;/li&gt;
&lt;li&gt;looper.prepare()&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Handler" scheme="http://xiaoman.ren/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>清香木养殖（三）</title>
    <link href="http://xiaoman.ren/2019/06/23/%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://xiaoman.ren/2019/06/23/清香木养殖（三）/</id>
    <published>2019-06-23T11:49:19.000Z</published>
    <updated>2019-06-23T14:34:03.441Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一次更新已经过去一个半月了，请不要担心，他还在！<br>作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。</p><p>这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。</p><p>绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。</p><p>这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。</p><p>现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：</p><a id="more"></a><ul><li>掉叶</li></ul><p>掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。</p><ul><li>黄叶</li></ul><p>黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。</p><ul><li>土壤</li></ul><p>起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。</p><p><strong>总结</strong></p><p>总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。</p><p>习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上一次更新已经过去一个半月了，请不要担心，他还在！&lt;br&gt;作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。&lt;/p&gt;
&lt;p&gt;这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。&lt;/p&gt;
&lt;p&gt;绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。&lt;/p&gt;
&lt;p&gt;这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。&lt;/p&gt;
&lt;p&gt;现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：&lt;/p&gt;
    
    </summary>
    
    
      <category term="绿植" scheme="http://xiaoman.ren/tags/%E7%BB%BF%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>清香木养殖（二）</title>
    <link href="http://xiaoman.ren/2019/05/08/%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://xiaoman.ren/2019/05/08/清香木养殖（二）/</id>
    <published>2019-05-08T03:02:23.000Z</published>
    <updated>2019-06-23T14:33:59.121Z</updated>
    
    <content type="html"><![CDATA[<p>心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.</p><p>记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去.</p><p>植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.</p><a id="more"></a><p>植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇.</p><p>昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根.</p><p>新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.&lt;/p&gt;
&lt;p&gt;记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去.&lt;/p&gt;
&lt;p&gt;植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.&lt;/p&gt;
    
    </summary>
    
    
      <category term="绿植" scheme="http://xiaoman.ren/tags/%E7%BB%BF%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>清香木养殖（一）</title>
    <link href="http://xiaoman.ren/2019/05/04/%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaoman.ren/2019/05/04/清香木养殖（一）/</id>
    <published>2019-05-04T13:54:08.000Z</published>
    <updated>2019-05-04T14:52:51.315Z</updated>
    
    <content type="html"><![CDATA[<p>激动的心，颤抖的手，京东上面动动手。<br>哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株<strong>清香木</strong>，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。</p><p><img src="https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg" alt="清香木"></p><p>其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。<br><a id="more"></a></p><p>那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。</p><p>自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。</p><p>OK，说正事儿，先来介绍一下<strong>清香木</strong>：</p><p>清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。</p><p>这里有一个养花的 APP，<a href="https://itunes.apple.com/cn/app/%E5%85%BB%E8%8A%B1%E5%A4%A7%E5%85%A8-%E5%85%BB%E8%8A%B1%E4%BA%BA%E7%9A%84%E5%9C%88%E5%AD%90/id1245612230?mt=8" target="_blank" rel="noopener">养花大全</a>，我就是在这上学习养花的技术及注意事项的。</p><p>虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。</p><p>虽然 APP 上介绍了<strong>清香木</strong>一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>见干见湿</td><td>见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。</td></tr><tr><td>浇水要浇透</td><td>浇水时，见到水从底部孔流出</td></tr></tbody></table><p>这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。<br>虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。</p><p>那么这里我在详细的说一下我的理解：</p><ul><li>见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。</li><li>浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm  我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。</li></ul><blockquote><p>小白在这献丑了，后续会持续更新</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;激动的心，颤抖的手，京东上面动动手。&lt;br&gt;哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株&lt;strong&gt;清香木&lt;/strong&gt;，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg&quot; alt=&quot;清香木&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。&lt;br&gt;
    
    </summary>
    
    
      <category term="绿植" scheme="http://xiaoman.ren/tags/%E7%BB%BF%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp Intercept</title>
    <link href="http://xiaoman.ren/2019/04/30/OkHttp-Intercept/"/>
    <id>http://xiaoman.ren/2019/04/30/OkHttp-Intercept/</id>
    <published>2019-04-30T12:42:02.000Z</published>
    <updated>2019-06-23T14:36:03.652Z</updated>
    
    <content type="html"><![CDATA[<p>OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子</p><p>要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.</p><p>这里介绍两种 Interceptor 的实例</p><a id="more"></a><h2 id="Log-日志-LogInterceptor"><a href="#Log-日志-LogInterceptor" class="headerlink" title="Log 日志 (LogInterceptor)"></a>Log 日志 (LogInterceptor)</h2><p>Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等.</p><p>这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等.</p><p>话不多说, 上代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义 log 拦截器,输入请求地址,请求参,请求结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 拦截请求信息,获取请求地址及请求参数</span></span><br><span class="line">            Request request = chain.request();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 获取请求方式</span></span><br><span class="line">            String method = request.method();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">                    FormBody body = (FormBody) request.body();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">                        sb.append(body.encodedName(i) + <span class="string">"="</span> + body.encodedValue(i) + <span class="string">","</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.delete(sb.length() - <span class="number">1</span>, sb.length());</span><br><span class="line">                    LogUtils.d(TAG, String.format(<span class="string">"Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;"</span>,</span><br><span class="line">                            request.url(), chain.connection(), request.headers(), sb.toString()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LogUtils.d(TAG, String.format(<span class="string">"Sending request %s on %s %n%s"</span>,</span><br><span class="line">                        request.url(), chain.connection(), request.headers()));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 获取响应信息</span></span><br><span class="line">            Response response = chain.proceed(request);</span><br><span class="line">            <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">            LogUtils.d(TAG, String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">                    response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">            MediaType contentType = response.body().contentType();</span><br><span class="line">            String content = response.body().string();</span><br><span class="line">            LogUtils.d(TAG, content);</span><br><span class="line">            ResponseBody wrappedBody = ResponseBody.create(contentType, content);</span><br><span class="line">            <span class="keyword">return</span> response.newBuilder().body(wrappedBody).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="加参"><a href="#加参" class="headerlink" title="加参"></a>加参</h2><p>加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为<strong>公参</strong>, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便.</p><p>因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数.</p><h3 id="公参拦截器"><a href="#公参拦截器" class="headerlink" title="公参拦截器"></a>公参拦截器</h3><p>在请求中,增加一些公共的参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonParamsInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; queryParamsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; headerParamsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; headerLinesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = request.newBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process header params inject</span></span><br><span class="line">        Headers.Builder headerBuilder = request.headers().newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (headerParamsMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator iterator = headerParamsMap.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">                headerBuilder.add((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (headerLinesList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String line : headerLinesList) &#123;</span><br><span class="line">                headerBuilder.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            requestBuilder.headers(headerBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process header params end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// process queryParams inject whatever it's GET or POST</span></span><br><span class="line">        <span class="keyword">if</span> (queryParamsMap.size() &gt; <span class="number">0</span> &amp;&amp; <span class="string">"GET"</span>.equals(request.method())) &#123;</span><br><span class="line"><span class="comment">//        if (queryParamsMap.size() &gt; 0) &#123;</span></span><br><span class="line">            request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process post body inject</span></span><br><span class="line">        <span class="keyword">if</span> (paramsMap != <span class="keyword">null</span> &amp;&amp; paramsMap.size() &gt; <span class="number">0</span> &amp;&amp; <span class="string">"POST"</span>.equals(request.method())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">                FormBody.Builder newFormBodyBuilder = <span class="keyword">new</span> FormBody.Builder();</span><br><span class="line">                <span class="keyword">if</span> (paramsMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Iterator iterator = paramsMap.entrySet().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">                        newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                FormBody oldFormBody = (FormBody) request.body();</span><br><span class="line">                <span class="keyword">int</span> paramSize = oldFormBody.size();</span><br><span class="line">                <span class="keyword">if</span> (paramSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramSize; i++) &#123;</span><br><span class="line">                        newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                requestBuilder.post(newFormBodyBuilder.build());</span><br><span class="line">                request = requestBuilder.build();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> MultipartBody) &#123;</span><br><span class="line">                MultipartBody.Builder multipartBuilder = <span class="keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM);</span><br><span class="line"></span><br><span class="line">                Iterator iterator = paramsMap.entrySet().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">                    multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts();</span><br><span class="line">                <span class="keyword">if</span> (oldParts != <span class="keyword">null</span> &amp;&amp; oldParts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MultipartBody.Part part : oldParts) &#123;</span><br><span class="line">                        multipartBuilder.addPart(part);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                requestBuilder.post(multipartBuilder.build());</span><br><span class="line">                request = requestBuilder.build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canInjectIntoBody</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.equals(request.method(), <span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestBody body = request.body();</span><br><span class="line">        <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MediaType mediaType = body.contentType();</span><br><span class="line">        <span class="keyword">if</span> (mediaType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.equals(mediaType.subtype(), <span class="string">"x-www-form-urlencoded"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func to inject params into url</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">injectParamsIntoUrl</span><span class="params">(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap)</span> </span>&#123;</span><br><span class="line">        HttpUrl.Builder httpUrlBuilder = request.url().newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (paramsMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator iterator = paramsMap.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">                httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            requestBuilder.url(httpUrlBuilder.build());</span><br><span class="line">            <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bodyToString</span><span class="params">(<span class="keyword">final</span> RequestBody request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RequestBody copy = request;</span><br><span class="line">            <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">            <span class="keyword">if</span> (copy != <span class="keyword">null</span>)</span><br><span class="line">                copy.writeTo(buffer);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">return</span> buffer.readUtf8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"did not work"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CommonParamsInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            interceptor = <span class="keyword">new</span> CommonParamsInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addParam</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">            interceptor.paramsMap.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addParamsMap</span><span class="params">(Map&lt;String, String&gt; paramsMap)</span> </span>&#123;</span><br><span class="line">            interceptor.paramsMap.putAll(paramsMap);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addHeaderParam</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">            interceptor.headerParamsMap.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addHeaderParamsMap</span><span class="params">(Map&lt;String, String&gt; headerParamsMap)</span> </span>&#123;</span><br><span class="line">            interceptor.headerParamsMap.putAll(headerParamsMap);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addHeaderLine</span><span class="params">(String headerLine)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index = headerLine.indexOf(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected header: "</span> + headerLine);</span><br><span class="line">            &#125;</span><br><span class="line">            interceptor.headerLinesList.add(headerLine);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addHeaderLinesList</span><span class="params">(List&lt;String&gt; headerLinesList)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String headerLine : headerLinesList) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = headerLine.indexOf(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected header: "</span> + headerLine);</span><br><span class="line">                &#125;</span><br><span class="line">                interceptor.headerLinesList.add(headerLine);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addQueryParam</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">            interceptor.queryParamsMap.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addQueryParamsMap</span><span class="params">(Map&lt;String, String&gt; queryParamsMap)</span> </span>&#123;</span><br><span class="line">            interceptor.queryParamsMap.putAll(queryParamsMap);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CommonParamsInterceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> interceptor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加签拦截器"><a href="#加签拦截器" class="headerlink" title="加签拦截器"></a>加签拦截器</h3><p>互联网是一个开放的环境,危险无处不在,加密通信是安全的基础.</p><p>加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签;</p><p>加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥.</p><p>这里介绍一种加签方式,</p><blockquote><p> 加密规则</p></blockquote><ol><li>根据请求参数 key 进行排序</li><li>按排好的顺序组装成 key=value&amp;key=value 形式的字符串</li><li>将上述字符串拼接  ,最终形成 key=value&amp;key=value的字符串</li><li>将字符串 md5, 生成 auth.</li></ol><p>一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AuthorizeInterceptor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 auth 的私钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String authKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前设备 mid,用来生成 auth</span></span><br><span class="line"><span class="comment">     * 数据由 Builder 类传入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mid = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AuthorizeInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = request.newBuilder();</span><br><span class="line">        String url = request.url().toString();</span><br><span class="line">        LogUtils.d(TAG, url);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(request.method())) &#123;</span><br><span class="line">            request = injectionParamIntoBody(request, requestBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"GET"</span>.equals(request.method())) &#123;</span><br><span class="line">            request = injectionAuthIntoUrl(request, requestBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET 请求方式, 生成授权和添加时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBuilder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">injectionAuthIntoUrl</span><span class="params">(Request request, Request.Builder requestBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到请求地址api</span></span><br><span class="line">        HttpUrl newHttpUrl = request.url();</span><br><span class="line">        TreeMap&lt;String, String&gt; authMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过请求地址(最初始的请求地址)获取到参数列表</span></span><br><span class="line">        Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : parameterNames) &#123;</span><br><span class="line">            <span class="comment">//循环参数列表,获取参数value,</span></span><br><span class="line">                String paramValue = newHttpUrl.queryParameter(key);</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(paramValue)) &#123;</span><br><span class="line">                    authMap.put(key, paramValue);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        HttpUrl.Builder newBuilder =</span><br><span class="line">                request.url().newBuilder()</span><br><span class="line">                        .addEncodedQueryParameter(<span class="string">"auth"</span>, assembleAuth(authMap, <span class="keyword">false</span>));</span><br><span class="line">        requestBuilder.url(newBuilder.build());</span><br><span class="line">        <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将参数注入到 POST 请求的 body 中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBuilder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">injectionParamIntoBody</span><span class="params">(Request request, Request.Builder requestBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">            <span class="comment">// 处理正常表单请求方式</span></span><br><span class="line">            FormBody oldFormBody = (FormBody) request.body();</span><br><span class="line">            <span class="keyword">return</span> assembleFormBody(request, oldFormBody, requestBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> MultipartBody) &#123;</span><br><span class="line">            <span class="keyword">return</span> assembleMultipartBody(request, requestBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建流媒体参数的 body</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">assembleMultipartBody</span><span class="params">(Request request, Request.Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理流的请求方式</span></span><br><span class="line">        MultipartBody body = (MultipartBody) request.body();</span><br><span class="line">        TreeMap&lt;String, String&gt; authMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span> &amp;&amp; body.parts().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MultipartBody.Part part : body.parts()) &#123;</span><br><span class="line">                <span class="comment">// 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (part.body().contentType() == <span class="keyword">null</span></span><br><span class="line">                        || !<span class="string">"image"</span>.equals(part.body().contentType().type())</span><br><span class="line">                        || <span class="string">"text"</span>.equals(part.body().contentType().type())) &#123;</span><br><span class="line">                    Headers headers = part.headers();</span><br><span class="line">                    <span class="comment">// 从 header 中获取 Key, form-data; name= 的字段过滤获取key</span></span><br><span class="line">                    <span class="comment">// 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value</span></span><br><span class="line">                    <span class="comment">// 将 key 和 value 填充到 TreeMap 中</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.names().size(); i++) &#123;</span><br><span class="line">                        String headerName = headers.value(i);</span><br><span class="line">                        <span class="keyword">if</span> (headerName.contains(<span class="string">"form-data; name="</span>)) &#123;</span><br><span class="line">                            String key = headerName.replace(<span class="string">"form-data; name="</span>, <span class="string">""</span>).replace(<span class="string">"\""</span>, <span class="string">""</span>);</span><br><span class="line">                                String value = body2String(part.body());</span><br><span class="line">                                <span class="keyword">if</span> (!TextUtils.isEmpty(value)) &#123;</span><br><span class="line">                                    authMap.put(key, body2String(part.body()));</span><br><span class="line">                                &#125;</span><br><span class="line">                                                   &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultipartBody.Builder multipartBuilder = <span class="keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM);</span><br><span class="line">        multipartBuilder.addFormDataPart(<span class="string">"auth"</span>, assembleAuth(authMap, <span class="keyword">false</span>));</span><br><span class="line">        List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts();</span><br><span class="line">        <span class="keyword">if</span> (oldParts != <span class="keyword">null</span> &amp;&amp; oldParts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MultipartBody.Part part : oldParts) &#123;</span><br><span class="line">                multipartBuilder.addPart(part);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.post(multipartBuilder.build());</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建 Auth 数据</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式,</span></span><br><span class="line"><span class="comment">     * Map 拼接完成后,在其后需要再次拼接上</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 最后将数据 MD5 转化为 32 位小写并返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeMap      构建 Auth 的具体数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isNeedDecode 是否需要解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 auth 数据 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">assembleAuth</span><span class="params">(TreeMap&lt;String, String&gt; treeMap, <span class="keyword">boolean</span> isNeedDecode)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (treeMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stringBuilder.append(stringStringEntry.getKey())</span><br><span class="line">                            .append(<span class="string">"="</span>)</span><br><span class="line">                            .append(isNeedDecode</span><br><span class="line">                                    ? URLDecoder.decode(stringStringEntry.getValue(), <span class="string">"UTF-8"</span>)</span><br><span class="line">                                    : stringStringEntry.getValue())</span><br><span class="line">                            .append(<span class="string">"&amp;"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        treeMap.clear();</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(authKey);</span><br><span class="line">        Log.d(TAG, stringBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span> MD5.MD5(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * body 转 string 获取实际参数值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body Part body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> part 中写如的参数数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">body2String</span><span class="params">(RequestBody body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                body.writeTo(buffer);</span><br><span class="line">                Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">                MediaType contentType = body.contentType();</span><br><span class="line">                <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    charset = contentType.charset(charset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> charset != <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> buffer.readString(charset);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 Form 表单请求数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldFormBody</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBuilder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">assembleFormBody</span><span class="params">(Request request, FormBody oldFormBody, Request.Builder requestBuilder)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;String, String&gt; authMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历请求参数,非空参数,添加到集合中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldFormBody.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123;</span><br><span class="line">                authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (authMap.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 生成 auth 数据</span></span><br><span class="line">            FormBody.Builder newFormBody = <span class="keyword">new</span> FormBody.Builder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldFormBody.size(); i++) &#123;</span><br><span class="line">                newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));</span><br><span class="line">            &#125;</span><br><span class="line">            newFormBody.add(<span class="string">"auth"</span>, assembleAuth(authMap, <span class="keyword">true</span>));</span><br><span class="line">            requestBuilder.method(request.method(), newFormBody.build());</span><br><span class="line">            <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        AuthorizeInterceptor authorizeInterceptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            authorizeInterceptor = <span class="keyword">new</span> AuthorizeInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMid</span><span class="params">(String mid)</span> </span>&#123;</span><br><span class="line">            authorizeInterceptor.mid = mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setAuthKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            authorizeInterceptor.authKey = key;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AuthorizeInterceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> authorizeInterceptor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该加签方式,讲请求参数拼接为 <code>key=value</code> 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 <code>contentType</code> 而又有所不同,这里介绍了<code>Form</code>表单提交和 <code>Multipart</code> 上传文件的参数获取方式,其他的请举一反三.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子&lt;/p&gt;
&lt;p&gt;要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.&lt;/p&gt;
&lt;p&gt;这里介绍两种 Interceptor 的实例&lt;/p&gt;
    
    </summary>
    
    
      <category term="OkHttp" scheme="http://xiaoman.ren/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>多个 ssh 公钥提交代码到不同平台</title>
    <link href="http://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/"/>
    <id>http://xiaoman.ren/2019/04/17/多个-ssh-公钥提交代码到不同平台/</id>
    <published>2019-04-17T14:09:21.000Z</published>
    <updated>2019-06-23T14:35:50.288Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个技术开发人员，免不了在 <code>github</code> 以及 <code>gitlab</code> 以及其他 <code>git</code> 平台上进行代码管理；<br>工作中您可能使用 <code>svn</code> （这不在我们的讨论范围）,也有可能使用 <code>git</code>, 生活中，您可能会将一些内容分享到你的 <code>github</code> 上， 供大家参阅。</p><p><code>git</code> 创建版本库很容易， <code>clone</code> 代码也仅仅是简单的一句 <code>git clone https://github.com/xxxx.git</code>，异或是 <code>git clone git@github.com:xxxxx.git</code>；当然，使用 <code>https</code> 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 <code>https</code> 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 <code>SSH</code> 的方式来处理 <code>git</code> 的版本管理。</p><a id="more"></a><h2 id="生成-SSH-密钥"><a href="#生成-SSH-密钥" class="headerlink" title="生成 SSH 密钥"></a>生成 SSH 密钥</h2><p>使用 <code>SSH</code> 创建一套公密钥，将公钥添加到你要使用的 <code>Git</code> 平台账户下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><code>-f</code> 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略</li><li>命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理）</li></ol><h2 id="添加生成的-SSH-公钥"><a href="#添加生成的-SSH-公钥" class="headerlink" title="添加生成的 SSH 公钥"></a>添加生成的 SSH 公钥</h2><p>添加 ssh 公钥到 <code>github</code> **</p><ol><li><p>打开 <code>https://github.com/settings/profile</code> ，选择 <code>SSH and GPG keys</code></p><p> <img src="https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190425135335.png" alt></p></li><li><p>点击 <code>New SSH key</code></p><ol><li>title 可以随便写，建议见名知意，能知道是哪台设备</li><li>key 通过刚刚通过 <code>SSH</code> 命令生成的 <code>.pub</code> 文件中复制即可。文件路径 <code>.ssh/id_rsa.pub</code> 异或是存在您 <code>-f</code> 之后指定的目录。</li><li>点击 <code>add SSH key</code></li></ol></li></ol><h2 id="配置多个-ssh"><a href="#配置多个-ssh" class="headerlink" title="配置多个 ssh"></a>配置多个 ssh</h2><p>配置多个 <code>ssh</code> 时，需要注意的是：</p><ol><li>如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 <code>ssh</code> 公钥到对应平台，否则，后续的 <code>ssh</code> 创建过程， 会覆盖掉之前创建的。</li><li><code>ssh-keygen</code> 会同时创建 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件， <code>.pub</code> 是公钥， 不带后缀的是你的私钥。</li><li>同时配置多个 <code>ssh</code> 时，需要您保留私钥在 <code>.ssh</code> 目录下，为保证多平台都可以使用，您需要手动修改一下 <code>id_rsa</code> 文件的名称，<code>.pub</code> 就随便了，配置完，就没用了。</li><li><p>将密钥添加到 <code>ssh-agent</code> 中</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看 agent 中的密钥</span><br><span class="line">ssh-add -l</span><br><span class="line"># 查看 agent 中的公钥</span><br><span class="line">ssh-add -L</span><br><span class="line"># 删除 agent 中的密钥</span><br><span class="line">ssh-add -d .ssh/id_xxx.pub</span><br></pre></td></tr></table></figure></code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>说了半天，终于到重点了</p><ol><li><p>在 <code>~/.ssh</code> 目录下新建一个 <code>config</code> 文件</p><p> 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 <code>ssh</code> 密钥。<br> <code>touch config</code></p></li><li><p>添加以下配置信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓</span><br><span class="line">HostName github.com # 同上</span><br><span class="line">PreferredAuthentications publickey # 这里不要修改</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥</span><br><span class="line"></span><br><span class="line"># gitlab</span><br><span class="line">Host 公司 gitlab 地址</span><br><span class="line">HostName 公司 gitlab 地址</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitlab</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>只需要替换后面的 <code>git</code>仓库地址, 其他版本库都可以进行测试。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说了半天， 还是要记住一点，既然要使用 <code>ssh</code> 的方式进行版本管理，那么在 <code>clone</code> 代码时，也要使用 <code>ssh</code> 方式， 不然我说了这么半天，都是白扯。</p><blockquote><p>文章内容有瑕疵，请给予指正批评</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个技术开发人员，免不了在 &lt;code&gt;github&lt;/code&gt; 以及 &lt;code&gt;gitlab&lt;/code&gt; 以及其他 &lt;code&gt;git&lt;/code&gt; 平台上进行代码管理；&lt;br&gt;工作中您可能使用 &lt;code&gt;svn&lt;/code&gt; （这不在我们的讨论范围）,也有可能使用 &lt;code&gt;git&lt;/code&gt;, 生活中，您可能会将一些内容分享到你的 &lt;code&gt;github&lt;/code&gt; 上， 供大家参阅。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt; 创建版本库很容易， &lt;code&gt;clone&lt;/code&gt; 代码也仅仅是简单的一句 &lt;code&gt;git clone https://github.com/xxxx.git&lt;/code&gt;，异或是 &lt;code&gt;git clone git@github.com:xxxxx.git&lt;/code&gt;；当然，使用 &lt;code&gt;https&lt;/code&gt; 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 &lt;code&gt;https&lt;/code&gt; 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 &lt;code&gt;SSH&lt;/code&gt; 的方式来处理 &lt;code&gt;git&lt;/code&gt; 的版本管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://xiaoman.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java 判断字符串是否是数字的方法</title>
    <link href="http://xiaoman.ren/2019/04/16/Java-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://xiaoman.ren/2019/04/16/Java-判断字符串是否是数字的方法/</id>
    <published>2019-04-16T09:47:06.000Z</published>
    <updated>2019-04-17T13:55:55.390Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用 Java自带的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric (String str) &#123;</span><br><span class="line">    for (int i = str.length(); --i &gt;=0) &#123;</span><br><span class="line">          if (!Character.isDigit(str.charAt(i))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>使用正则表达式</li></ul><p>方法一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric(String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;);</span><br><span class="line">    return pattern.matcher(str).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric(String str) &#123;</span><br><span class="line">    if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123;</span><br><span class="line">          return s.matches(&quot;^[0-9]*$&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static boolean isNumeric (String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;);</span><br><span class="line">    return pattern.matcher(str).matcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ASCII 码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric (String str) &#123;</span><br><span class="line">    for (int i = str.length(); --i&gt;=0;) &#123;</span><br><span class="line">        int chr = str.charAt(i);</span><br><span class="line">        if (chr &lt; 48 || chr &gt; 57) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是不是浮点型数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isDouble(String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;);</span><br><span class="line">    return pattern.matcher(str).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用 Java自带的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static boolean isNumeric (String str) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = str.length(); --i &amp;gt;=0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          if (!Character.isDigit(str.charAt(i))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 中设置全屏的方法</title>
    <link href="http://xiaoman.ren/2019/04/16/Android-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://xiaoman.ren/2019/04/16/Android-中设置全屏的方法/</id>
    <published>2019-04-16T09:46:31.000Z</published>
    <updated>2019-04-17T13:55:03.516Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置</p><h1 id="一-在代码中设置"><a href="#一-在代码中设置" class="headerlink" title="一. 在代码中设置"></a>一. 在代码中设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BaseActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(saveInstanceState);</span><br><span class="line">        // 无title</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        // 全屏</span><br><span class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强调一点: <strong> 设置全屏的两段代码,必须在 <code>setContentView()</code> 之前调用,不然会报错 </strong></p><h1 id="二-在配置文件中修改"><a href="#二-在配置文件中修改" class="headerlink" title="二. 在配置文件中修改"></a>二. 在配置文件中修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest </span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  package=&quot;com.android.test&quot;</span><br><span class="line">  android:versionCode=&quot;1&quot;</span><br><span class="line">  ndroid:versionName=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;application android:icon=&quot;@drawable/icon&quot;</span><br><span class="line">    android:lable=&quot;@string/app_name&gt;</span><br><span class="line">    &lt;activity android:name=&quot;.BaseActivity&quot; </span><br><span class="line">        android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot;</span><br><span class="line">        android:lable=&quot;@string/app_name&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">  &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置&lt;/p&gt;
&lt;h1 id=&quot;一-在代码中设置&quot;&gt;&lt;a href=&quot;#一-在代码中设置&quot; class=&quot;headerlink&quot; title=&quot;一. 在代码中设置&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 获取 IP 地址</title>
    <link href="http://xiaoman.ren/2019/04/16/Android-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80/"/>
    <id>http://xiaoman.ren/2019/04/16/Android-获取-IP-地址/</id>
    <published>2019-04-16T09:46:00.000Z</published>
    <updated>2019-04-17T13:54:55.501Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求,</p><p><strong>第一种方法: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);  </span><br><span class="line">WifiInfo wifiInfo = wifiManager.getConnectionInfo();  </span><br><span class="line"><span class="keyword">int</span> ipAddress = wifiInfo.getIpAddress();</span><br></pre></td></tr></table></figure><p>通过这种方式获取到的 IP 地址为一串数字,我们并不能看懂,因此我们需要通过下面的方法进行转换:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ip = (ipAddress &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;8 &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;16 &amp; 0xff) + &quot;.&quot; + (ipAddress &gt;&gt; 24 &amp; 0xff);</span><br></pre></td></tr></table></figure><p>这样转换之后,我们获取到的 IP 地址就是我们平时认识的, 比如: 192.168.1.108</p><p>这种方法在飞行模式下获取到的 IP 地址为 0.0.0.0</p><p><strong>第二种方法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  public String getLocalIpAddress() &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123;  </span><br><span class="line">            NetworkInterface intf = en.nextElement();  </span><br><span class="line">            for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123;  </span><br><span class="line">                InetAddress inetAddress = enumIpAddr.nextElement();  </span><br><span class="line">                if (!inetAddress.isLoopbackAddress()) &#123;  </span><br><span class="line">                    return inetAddress.getHostAddress().toString();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; catch (SocketException ex) &#123;  </span><br><span class="line">        Log.e(LOG_TAG, ex.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是比较通用的,在WiFi和3G/4G 状态下,都可以获取到正确的地址.比如: fe80::8e3a:e3ff:fe45:a018</p><p>这种方法在手机处于飞行状态下时, 获取到的 IP 地址为 null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种方法: &lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
</feed>
