<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶白生产空间</title>
  <icon>https://www.gravatar.com/avatar/f27b936c2ac428d82177b6d3626c8e3a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaoman.ren/"/>
  <updated>2021-01-30T08:30:11.009Z</updated>
  <id>http://xiaoman.ren/</id>
  
  <author>
    <name>茶白</name>
    <email>zhuangbudong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="http://xiaoman.ren/2021/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xiaoman.ren/2021/01/29/数据结构/数据结构/</id>
    <published>2021-01-29T15:54:28.359Z</published>
    <updated>2021-01-30T08:30:11.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>是一片物理上连续的大小确定的存储空间</p><p>数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。</p><p>利用索引进行查询速度快，无法真正的删除<br><a id="more"></a></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>具有连续有序性，可重复性，可扩容性，访问比较便捷</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>原理与特点</strong></p><p>实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">// 移位操作</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 移位操作</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>扩容机制：</strong></p><p><code>ArrayList</code> 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// oldCapacity >> 1 等价于  oldCapacity / 2</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 <code>node</code> 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。</p><p>因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。</p><p>因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从前面查找</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从后面查找</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    </code></pre><p>但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//插入数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 插入时，有时也需要遍历，这里可以忽略</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert succ != null;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移除数据</span>    <span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert f == first &amp;&amp; f != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Unlinks non-null last node l.     */</span>    <span class="token keyword">private</span> E <span class="token function">unlinkLast</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert l == last &amp;&amp; l != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> l<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 <code>synchronized</code>，因此性能比 <code>ArrayList</code> 差，每次扩容申请双倍空间也可以自定义。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>具有不可重复性，无序性，<em>不可查找的特点</em></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet</code> 的内部使用 <code>HashMap</code> 来存储数据，即 <code>add</code> 时，将元素当作 <code>HashMap</code> 的 <code>Key</code> 来使用，这也符合 <code>Set</code> 集合不可重复性的特点。</p><p>此类集合不可以直接获取容器中的 value， 可通过遍历 <em>迭代器</em>  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 <code>ConCurrentException</code> 。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。</p><p><strong>List 和 Set 的区别</strong></p><ul><li>是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许</li><li>元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合</li><li>List 可以通过下标来访问元素， 而 Set 不能</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>数组</strong> 和 <strong>单链表</strong> 的组合， 数组用来存储 key，链表用来存储实际的 value</p><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value);"></a>put(K key, V value);</h3><p>当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，</p><p>当链表为空时，通过 <code>resize()</code> 函数帮我创建一个新链表，默认长度为 16 （1 &lt;&lt; 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)</p><p>当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 装箱过程，计算 hash 值的过程。* */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p<span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// tab[i = (n - 1) &amp; hash] </span>        <span class="token comment" spellcheck="true">// n 是数组的长度，经过 &amp; 和 hash 值的位运算（模运算：求余数的运算，等价于=> （hash % n）），获得该元素在数组中的索引</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>            K k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="Hash-碰撞-冲突"><a href="#Hash-碰撞-冲突" class="headerlink" title="Hash 碰撞/冲突"></a><strong>Hash 碰撞/冲突</strong></h3><p>在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值</p><p><strong>解决方案</strong>：</p><p><strong>链表法：</strong> 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 <code>get()</code> 函数获取数据时，拿到一个链表，就遍历，找到 <code>hash</code> 值相同的那个节点，并返回。</p><p><strong>避免冲突</strong>：</p><p>阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。</p><p><strong>扩容方案：</strong></p><p>加载因子：<code>loadFactor</code> 默认值是 0.75</p><p>阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。</p><p>HashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。</p><blockquote><p>比如：</p><p>length1 = 10，(非 2 的次幂)，对应的二进制数是 1001</p><p>length2 = 16(2 的 4 次幂)，对应的二进制数是 1111</p><p>当产生一个 hash 值，为 6（0110）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110</p><p>当产生一个 hash 值，为 7（0111）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111</p><p>由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞</p></blockquote><p>当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。</p><p>当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。</p><p>开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。</p><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p><strong>原理与特点</strong></p><p>由 <strong>双数组</strong> 构成，两个数组分别存储 <code>Key</code> 和  <code>Value</code> ，并一一对应。</p><p>查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）</p><p>通过获取 key 的索引找到其对应的 value 值，也就具备了 <strong>查询速度快</strong> 的特点（也是数组的特点）</p><p>删除元素时，仅将元素标记位 <strong>“DELETE”</strong> 状态，不发生移位等操作，因此速度上会比 <code>ArrayList</code> 快</p><p>因为是标记为 “DELETE” ，因此算法是可以达到复用，再利用二分查找，被标记为 “DELETE” 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。</p><p>缺点是，Key 只能是 <code>int</code> 类型数据。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> E value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分查找，快速定位传入的 key 所在位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> ContainerHelpers<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>mKeys<span class="token punctuation">,</span> mSize<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果存在，直接替换同位置数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mValues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值</span>            i <span class="token operator">=</span> <span class="token operator">~</span>i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> mSize <span class="token operator">&amp;&amp;</span> mValues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> DELETED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>                mValues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mGarbage <span class="token operator">&amp;&amp;</span> mSize <span class="token operator">>=</span> mKeys<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Search again because indices may have changed.</span>                i <span class="token operator">=</span> <span class="token operator">~</span>ContainerHelpers<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>mKeys<span class="token punctuation">,</span> mSize<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 扩容机制，2倍</span>            mKeys <span class="token operator">=</span> GrowingArrayUtils<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>mKeys<span class="token punctuation">,</span> mSize<span class="token punctuation">,</span> i<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            mValues <span class="token operator">=</span> GrowingArrayUtils<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>mValues<span class="token punctuation">,</span> mSize<span class="token punctuation">,</span> i<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            mSize<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> currentSize<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token function">growSize</span><span class="token punctuation">(</span>currentSize<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArray<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        newArray<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index<span class="token punctuation">,</span> newArray<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newArray<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">growSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> currentSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2 倍扩容机制</span>        <span class="token keyword">return</span> currentSize <span class="token operator">&lt;=</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token operator">:</span> currentSize <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除数据，仅标记 DELETE 状态</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> ContainerHelpers<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>mKeys<span class="token punctuation">,</span> mSize<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mValues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> DELETED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mValues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> DELETED<span class="token punctuation">;</span>                mGarbage <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>扩容机制：</strong></p><p>同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。</p><h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 <code>hashcode</code> 作为 key，弥补了 <code>SparseArray</code> 只能是 <code>int</code> 型。使用双数组的形式，又弥补了 <code>HashMap</code> 的对内存消耗的问题。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>是 <code>HashMap</code> 的子类， <code>put</code>  和 <code>remove</code> 函数使用的就是 <code>HashMap</code> 的，没有太大却别，主要区别在于 <code>get</code> 函数， <code>LinkedHashMap</code> 在每次 <code>get</code> 出一个数据后，会将这个数据放在链表的尾部。</p><p><code>LinkedHashMap</code> 的应用，在 <code>LRUCache</code> 和 <code>DiskLRUCache</code> 中使用，其算法名称 <em>最少/最小使用算法</em> ，也就是说，利用了 <code>LinkedHashMap</code> 的 <code>get</code> 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。</p><h2 id="队列-Queue-和-栈-Stack"><a href="#队列-Queue-和-栈-Stack" class="headerlink" title="队列 Queue 和 栈 Stack"></a>队列 Queue 和 栈 Stack</h2><ul><li>队列的特点是 <em>先入先出</em></li><li>栈的特点是 <em>先入后出</em> </li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p><p>算法的基本思想：</p><p>可以用一个单链表来实现</p><p>只关心上一次的操作</p><p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查找下一个比自己大的数的距离</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义一个栈，用来缓存当前的最大值的索引</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义一个数组，用来存储对应数据的间距</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interval <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 拿出栈顶数据的索引</span>                <span class="token keyword">int</span> topIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>topIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    interval<span class="token punctuation">[</span>topIndex<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> topIndex<span class="token punctuation">;</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span>        <span class="token comment" spellcheck="true">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p><p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p><p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;是一片物理上连续的大小确定的存储空间&lt;/p&gt;
&lt;p&gt;数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。&lt;/p&gt;
&lt;p&gt;利用索引进行查询速度快，无法真正的删除&lt;br&gt;
    
    </summary>
    
      <category term="基础知识" scheme="http://xiaoman.ren/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数据结构和算法" scheme="http://xiaoman.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://xiaoman.ren/2021/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    <id>http://xiaoman.ren/2021/01/29/数据结构/算法/</id>
    <published>2021-01-29T15:54:28.359Z</published>
    <updated>2021-01-30T08:24:22.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高频数据结构和算法"><a href="#高频数据结构和算法" class="headerlink" title="高频数据结构和算法"></a>高频数据结构和算法</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数组/字符串</li><li>链表</li><li>栈</li><li>队列</li><li>双端队列</li><li>树<a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></li></ul><p>优点： 可以在 O（1） 的时间里根据下标查询某个元素</p><p>缺点：</p><ul><li>构建时必须时一段连续的空间</li><li>查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间</li><li>删除和添加某个元素时，同样需要耗费O(n) 的时间</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>单链表：</strong> 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起</p><p><strong>双链表：</strong> 与单链表不同的时，双链表的每个节点中都含有<strong>两个引用字段</strong></p><p><strong>优点：</strong> </p><ul><li>灵活的内存空间</li><li>能在 O(1) 时间内删除或添加元素</li></ul><p><strong>缺点：</strong></p><ul><li>查询元素需要O(n)时间</li></ul><p><strong>解题技巧：</strong></p><ol><li>利用快慢指针（有时需要3个）</li><li>构建一个虚假的链表头</li></ol><p><strong>练习：</strong></p><p>eg: k 个一组反转链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 假设 k = 3</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>curr <span class="token operator">=</span> head<span class="token punctuation">;</span>n <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">&amp;&amp;</span> n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>    curr <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p><p>算法的基本思想：</p><p>可以用一个单链表来实现</p><p>只关心上一次的操作</p><p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查找下一个比自己大的数的距离</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义一个栈，用来缓存当前的最大值的索引</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义一个数组，用来存储对应数据的间距</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interval <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 拿出栈顶数据的索引</span>                <span class="token keyword">int</span> topIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>topIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    interval<span class="token punctuation">[</span>topIndex<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> topIndex<span class="token punctuation">;</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span>        <span class="token comment" spellcheck="true">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p><p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p><p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>可以利用双链表实现</p><p>队列</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>数据像鱼吐泡泡一样，从底部向上浮出</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">maopao</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> des<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> num<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>des<span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token punctuation">[</span>des<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向已排列好的数组中插入数据</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">charu</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录当前最小值的索引</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">xuanze</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已排序数组的最大值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到未排序部分的最小值索引</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 与已排序部分最大值比较，小则交换</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> minIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><p>利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果</p><p>利用二叉树，左右两边同时排序，最后将两部分合并再一起</p><p>递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">guibing</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界点判断，终止递归</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">+</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取中间值</span>    <span class="token function">guibing</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">guibing</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> start<span class="token punctuation">,</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充</span>            nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">></span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充</span>            nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>copy<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> copy<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 右侧数据比左侧数据小，将右侧数据填充</span>            nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 左侧数据比右侧数据小，将左侧数据填充</span>            nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>同样利用递归的思想。</p><p>先随机选择一个数，然后让比它小的放在左边，大的放在右边</p><p>然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">kuaisu</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kuaisu</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kuaisu</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 先随机一个索引，然后将他放在最后面。</span>    <span class="token comment" spellcheck="true">// 在定义两个指针</span>    <span class="token comment" spellcheck="true">// i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置</span>    <span class="token comment" spellcheck="true">// j: 当前第一个值</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先将最小值， copy 到最后一个位置</span>    <span class="token keyword">int</span> random <span class="token operator">=</span> <span class="token function">randRang</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> random<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// num[j] 当前值</span>            <span class="token comment" spellcheck="true">// num[high] 随机数，基准值</span>            <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将基准值还原到对应位置</span>    <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">randRang</span><span class="token punctuation">(</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>high<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> low<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高频数据结构和算法&quot;&gt;&lt;a href=&quot;#高频数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;高频数据结构和算法&quot;&gt;&lt;/a&gt;高频数据结构和算法&lt;/h2&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组/字符串&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;双端队列&lt;/li&gt;
&lt;li&gt;树
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://xiaoman.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Glide</title>
    <link href="http://xiaoman.ren/2021/01/29/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Glide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2021/01/29/三方框架/Glide 源码分析/</id>
    <published>2021-01-29T15:54:28.347Z</published>
    <updated>2021-01-29T16:02:08.236Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 <code>Picasso</code> 和 <code>ImageLoader</code> 两套框架。 都各有特色。这里主要还是讲一下 <code>Glide</code> 。<br><a id="more"></a><br><strong>基础用法：</strong></p><pre class=" language-java"><code class="language-java">Glide<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span>imageView<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 Android 开发中，我们通常最简单的使用 <code>Glide</code> 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。</p><p>从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，<code>with</code> <code>load</code> 和 <code>into</code>，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">主要功能</th></tr></thead><tbody><tr><td style="text-align:center">with</td><td style="text-align:center">1. 初始化Glide对象<br>2. 创建空白的 Fragment 管理生命周期机制<br>3. 创建一个 RequestManager 管理任务</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">最终构建出 RequestBuilder ，记录传入的数据</td></tr><tr><td style="text-align:center">into</td><td style="text-align:center">1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br>2. 活动缓存<br>3. 内存缓存<br>4. HttpUrlConnection</td></tr></tbody></table><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><code>Glide</code> 通过 <code>with</code> 函数，给自己的实例化，并创建一个空白的 <code>Fragment</code> 来管理生命周期并绑定 <code>ReqeustManager</code> 。继续通过 <code>load()</code> 函数构建一个 <code>RequestBuilder()</code> 并缓存我们的参数，继续通过 <code>into</code> 创建一个 <code>Request</code> 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 <code>ActivityResources</code> 有没有数据，再检查内存缓存 <code>LRUResourceCache</code> ，如果两级缓存都未命中，则启动一个异步任务 <code>DecodeJob</code>, 去检查 <code>DiskCache</code> 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 <code>HttpUrlConnection</code> ，解析 <code>InputStream</code> 进行采样，最终拿到 <code>Bitmap</code>，将 <code>Bitmap</code> 转换成 <code>Drawable</code> 并讲数据缓存到磁盘中。</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>从上面的表格中，我们可以看出来 <code>with</code> 函数，就是用来帮我创建 <code>Glide</code> 对象，并创建一个空白的 <code>Fragment</code> 来管理生命周期。其具体的工作流程如图：</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true" alt="Glide with 时序图"></p><p>由上面的时序图，我们可以顺序的分析，我们一步步去分析。</p><p><strong>Glide.with()</strong></p><p><code>Glide.with()</code> 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> FragmentActivity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Fragment fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>fragment<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Fragment fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>fragment<span class="token punctuation">.</span><span class="token function">getActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> RequestManager <span class="token function">with</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> View view<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getRetriever</span><span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>getRetriever</strong>()</p><p><code>getRetriever()</code> 通过 Glide 的 get 函数，帮我们初始化了一个 <code>Glide</code> 对象。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@NonNull</span><span class="token keyword">private</span> <span class="token keyword">static</span> RequestManagerRetriever <span class="token function">getRetriever</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Glide<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRequestManagerRetriever</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>get(context)</strong></p><p>可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Glide glide<span class="token punctuation">;</span><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> Glide <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>glide <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Glide<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>glide <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkAndInitializeGlide</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> annotationGeneratedModule<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> glide<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>checkAndInitializeGlide() &amp; initializeGlide()</strong></p><p>最终通过构造者模式，完成了对 <code>Glide</code> 对象的初始化，同时在构造者中，也对很多 <code>Glide</code> 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">checkAndInitializeGlide</span><span class="token punctuation">(</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isInitializing<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>            <span class="token string">"You cannot call Glide.get() in registerComponents(),"</span>            <span class="token operator">+</span> <span class="token string">" use the provided Glide instance instead"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    isInitializing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">initializeGlide</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> generatedAppGlideModule<span class="token punctuation">)</span><span class="token punctuation">;</span>    isInitializing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initializeGlide</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> GlideBuilder builder<span class="token punctuation">,</span> GeneratedAppGlideModule annotationGeneratedModule<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Glide glide <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    Glide<span class="token punctuation">.</span>glide <span class="token operator">=</span> glide<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>到这里， <code>Glide</code> 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。</p><p>并且代码按照流程，<code>get()</code> 的深度代码已经完成，程序会逐步回到 <code>getRetriever()</code> 函数中，去执行 <code>getRequestManagerRetriever</code> ， <code>getRequestManagerRetriever</code> <code>是通过</code>Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 <code>with()</code>函数 的 <code>get()</code> 去创建 <code>RequestManager</code></p><p><strong>get(Fragment fragment)</strong></p><p>这时候，我们发现，现在代码已经跳转到 <code>RequestManagerRetriever</code> 类中</p><p><strong>RequestManagerRetriever</strong></p><p><code>RequestManagerRetriever</code> 是一个管理类，负责生产 <code>Fragment</code> 对象，根据我们传入的 <code>Context</code> 上下文的定义不同，最终会帮我们创建不同的生命周期管理。</p><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@NonNull</span>  <span class="token keyword">public</span> RequestManager <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Fragment fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Util<span class="token punctuation">.</span><span class="token function">isOnBackgroundThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span>      <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>fragment<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      FragmentManager fm <span class="token operator">=</span> fragment<span class="token punctuation">.</span><span class="token function">getChildFragmentManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">supportFragmentGet</span><span class="token punctuation">(</span>fragment<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fm<span class="token punctuation">,</span> fragment<span class="token punctuation">,</span> fragment<span class="token punctuation">.</span><span class="token function">isVisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> RequestManager <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"You cannot start a load on a null Context"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Util<span class="token punctuation">.</span><span class="token function">isOnMainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">Application</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">FragmentActivity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FragmentActivity<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">Activity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Activity<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">ContextWrapper</span>          <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ContextWrapper<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBaseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ContextWrapper<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBaseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span>      <span class="token keyword">return</span> <span class="token function">getApplicationManager</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p><strong>Note:</strong></p><ol><li><p><strong>如果当前任务工作在后台线程或者传入的 <code>Context</code> 对象是一个 <code>Application</code> 级别的，那 <code>Glide</code> 就会帮我们创建一个和 <code>Application</code> 同生命周期的 <code>RequestManager</code> 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color="red">内存的泄漏</font></strong>。 因此我们使用时，尽量不要传入里类似的。</p></li><li><p>如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 <code>Glide</code> 就会帮我们创建个空白的 <code>Fragment</code>， <code>supportFragmentGet</code> 和  <code>fragmentGet</code> 两种方案是用来做 <code>androidX</code> 和 <code>android.app</code>中不同 <code>fragment</code> 的适配</p></li></ol></blockquote><p><strong>supportFragmentGet</strong></p><p>创建管理生命周期的 Fragment, <code>androidx</code> 对应的是 <code>supportFragmentGet()</code> ， <code>android.app</code> 对应的是 <code>fragmentGet()</code>， 这里以 <code>supportFragmentGet()</code> 为例：</p><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@NonNull</span>  <span class="token keyword">private</span> RequestManager <span class="token function">supportFragmentGet</span><span class="token punctuation">(</span>      <span class="token annotation punctuation">@NonNull</span> Context context<span class="token punctuation">,</span>      <span class="token annotation punctuation">@NonNull</span> FragmentManager fm<span class="token punctuation">,</span>      <span class="token annotation punctuation">@Nullable</span> Fragment parentHint<span class="token punctuation">,</span>      <span class="token keyword">boolean</span> isParentVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 创建/获取当前空白的 Fragment</span>    SupportRequestManagerFragment current <span class="token operator">=</span>        <span class="token function">getSupportRequestManagerFragment</span><span class="token punctuation">(</span>fm<span class="token punctuation">,</span> parentHint<span class="token punctuation">,</span> isParentVisible<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 获取空白 Fragment 中的 RequestManager 对象</span>      <span class="token comment" spellcheck="true">// 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中</span>    RequestManager requestManager <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">getRequestManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>requestManager <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Glide glide <span class="token operator">=</span> Glide<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>      requestManager <span class="token operator">=</span>          factory<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>              glide<span class="token punctuation">,</span> current<span class="token punctuation">.</span><span class="token function">getGlideLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> current<span class="token punctuation">.</span><span class="token function">getRequestManagerTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>      current<span class="token punctuation">.</span><span class="token function">setRequestManager</span><span class="token punctuation">(</span>requestManager<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 返回 reqeustManager 对象</span>    <span class="token keyword">return</span> requestManager<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@NonNull</span>  <span class="token keyword">private</span> SupportRequestManagerFragment <span class="token function">getSupportRequestManagerFragment</span><span class="token punctuation">(</span>      <span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> FragmentManager fm<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Fragment parentHint<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isParentVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment </span>    SupportRequestManagerFragment current <span class="token operator">=</span>        <span class="token punctuation">(</span>SupportRequestManagerFragment<span class="token punctuation">)</span> fm<span class="token punctuation">.</span><span class="token function">findFragmentByTag</span><span class="token punctuation">(</span>FRAGMENT_TAG<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 如果为空，说明空白的 Fragment 还没有被添加进去</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象</span>        <span class="token comment" spellcheck="true">// 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，</span>        <span class="token comment" spellcheck="true">// 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，</span>        <span class="token comment" spellcheck="true">// 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap</span>      current <span class="token operator">=</span> pendingSupportRequestManagerFragments<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一保障</span>        <span class="token comment" spellcheck="true">// 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 创建一个新的空白 Fragment</span>        current <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SupportRequestManagerFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current<span class="token punctuation">.</span><span class="token function">setParentFragmentHint</span><span class="token punctuation">(</span>parentHint<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isParentVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 调用生命周期方法，让所有的监听者开始任务（后面会说）</span>          current<span class="token punctuation">.</span><span class="token function">getGlideLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 将创建好的 Fragment 存入到集合中</span>        pendingSupportRequestManagerFragments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>fm<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// Handler 通知父容器，这里添加了一个 Fragment</span>        fm<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> FRAGMENT_TAG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commitAllowingStateLoss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）</span>        handler<span class="token punctuation">.</span><span class="token function">obtainMessage</span><span class="token punctuation">(</span>ID_REMOVE_SUPPORT_FRAGMENT_MANAGER<span class="token punctuation">,</span> fm<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sendToTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> current<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p><strong>Note:</strong></p><p>这里有一个比较困惑的地方就是，将已经创建好的 <code>Fragment</code> 添加到集合中去后，又通过 <code>Handler</code> 消息，将这个 <code>Fragment</code> 从集合中移除，这是为什么呢？</p><p>其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，<code>fragment</code> 的添加也是通过 <code>Handler</code> 来完成的，但 <code>Handler</code> 消息的执行时间不能保证，因此通过 <code>Handler</code> 再发一次消息，让移除操作在 <code>Fragment</code> 添加完成之后去执行，就一定能够得到保障。</p><p>只有当 <code>Fragment</code> 被添加进入父容器之后， <code>fm.findFragmentByTag</code> 才能获取到对象。这也是为了保证每个父容器都只有一个空白 <code>Fragment</code> 的两次保障。</p></blockquote><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p>至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true" alt="Glide lifecycle"></p><p><strong>SupportRequestManagerFragment</strong> </p><p>内部绑定了 <code>ActivityFragmentLifecycle</code> ，通过 Fragment 生生命周期变化，来引导 <code>RequestManager</code> 完成图片的请求和后续的显示</p><p>我们查看下源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SupportRequestManagerFragment</span> <span class="token keyword">extends</span> <span class="token class-name">Fragment</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TAG <span class="token operator">=</span> <span class="token string">"SupportRMFragment"</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> ActivityFragmentLifecycle lifecycle<span class="token punctuation">;</span>  <span class="token annotation punctuation">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"ValidFragment"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token function">SupportRequestManagerFragment</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> ActivityFragmentLifecycle lifecycle<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 构造器创建了 ActivityFramgentLifecycle</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lifecycle <span class="token operator">=</span> lifecycle<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lifecycle<span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lifecycle<span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lifecycle<span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unregisterFragmentWithRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@NonNull</span>  ActivityFragmentLifecycle <span class="token function">getGlideLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> lifecycle<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。</p><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true" alt="Glide load"></p><p>我们将 <code>Glide.with(this).load(url).into(view);</code> 拆分开来写，如下：</p><pre class=" language-java"><code class="language-java">RequestManager requestManager <span class="token operator">=</span> Glide<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RequestBuilder requestBuilder <span class="token operator">=</span> requestManager<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>requestBuilder<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看出， load 函数，我们传入了一个 <code>String</code> 类型的 <code>Url</code>， 最终返回给我们一个 <code>RequestBuilder</code> 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 <code>RequestBuilder</code> 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 <code>Drawable</code> 。</p><p><code>Glide</code> 也为我们提供了丰富的 <code>load api</code>， 我们可以传入 <code>url, bitmap, byte[], Drawable, Uri, File, Integer</code> 等等， <code>RequestBuilder</code> 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 <code>Drawable</code> 给图片容器，也就是后面我们要说的 <code>into</code> 函数。</p><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><p>into 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true" alt></p><p>但我们先按照这个残图先分析一下。</p><p>当 <code>into(imageview)</code> 被调用后</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ViewTarget<span class="token operator">&lt;</span>ImageView<span class="token punctuation">,</span> TranscodeType<span class="token operator">></span> <span class="token function">into</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> ImageView view<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Util<span class="token punctuation">.</span><span class="token function">assertMainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Preconditions<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span>    BaseRequestOptions<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> requestOptions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>requestOptions<span class="token punctuation">.</span><span class="token function">isTransformationSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> requestOptions<span class="token punctuation">.</span><span class="token function">isTransformationAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> view<span class="token punctuation">.</span><span class="token function">getScaleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getScaleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> CENTER_CROP<span class="token operator">:</span>          requestOptions <span class="token operator">=</span> requestOptions<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">optionalCenterCrop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> CENTER_INSIDE<span class="token operator">:</span>          requestOptions <span class="token operator">=</span> requestOptions<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">optionalCenterInside</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> FIT_CENTER<span class="token operator">:</span>        <span class="token keyword">case</span> FIT_START<span class="token operator">:</span>        <span class="token keyword">case</span> FIT_END<span class="token operator">:</span>          requestOptions <span class="token operator">=</span> requestOptions<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">optionalFitCenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> FIT_XY<span class="token operator">:</span>          requestOptions <span class="token operator">=</span> requestOptions<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">optionalCenterInside</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> CENTER<span class="token operator">:</span>        <span class="token keyword">case</span> MATRIX<span class="token operator">:</span>        <span class="token keyword">default</span><span class="token operator">:</span>          <span class="token comment" spellcheck="true">// Do nothing.</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>Glide 显示对图片进行了解析，获取图片的尺寸等信息。</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token operator">&lt;</span>Y <span class="token keyword">extends</span> <span class="token class-name">Target</span><span class="token operator">&lt;</span>TranscodeType<span class="token operator">>></span> Y <span class="token function">into</span><span class="token punctuation">(</span>      <span class="token annotation punctuation">@NonNull</span> Y target<span class="token punctuation">,</span>      <span class="token annotation punctuation">@Nullable</span> RequestListener<span class="token operator">&lt;</span>TranscodeType<span class="token operator">></span> targetListener<span class="token punctuation">,</span>      BaseRequestOptions<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> options<span class="token punctuation">,</span>      Executor callbackExecutor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Preconditions<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isModelSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"You must call #load() before calling #into()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Request request <span class="token operator">=</span> <span class="token function">buildRequest</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> targetListener<span class="token punctuation">,</span> options<span class="token punctuation">,</span> callbackExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>    Request previous <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    requestManager<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span><span class="token function">setRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestManager<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> target<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>继续，创建了一个 <code>Request</code> ，这个 <code>Request</code> 的真实对象是 <code>SingleRequest</code> ，并通过 <code>requestManager</code> 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 &lt;code&gt;Picasso&lt;/code&gt; 和 &lt;code&gt;ImageLoader&lt;/code&gt; 两套框架。 都各有特色。这里主要还是讲一下 &lt;code&gt;Glide&lt;/code&gt; 。&lt;br&gt;
    
    </summary>
    
    
      <category term="三方框架" scheme="http://xiaoman.ren/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 数学公式编辑</title>
    <link href="http://xiaoman.ren/2021/01/29/Tools/Markdown%20%E5%85%AC%E5%BC%8F/"/>
    <id>http://xiaoman.ren/2021/01/29/Tools/Markdown 公式/</id>
    <published>2021-01-29T15:54:28.321Z</published>
    <updated>2021-01-29T16:05:06.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown中公式编辑教程"><a href="#Markdown中公式编辑教程" class="headerlink" title="Markdown中公式编辑教程"></a>Markdown中公式编辑教程</h1><h1 id="markdown中公式编辑教程"><a href="#markdown中公式编辑教程" class="headerlink" title="markdown中公式编辑教程"></a>markdown中公式编辑教程</h1><p>标签： Mathjax 公式编辑 markdown</p><p>一般公式分为两种形式，行内公式和行间公式。</p><ul><li>行内公式：<img src="https://math.jianshu.com/math?formula=\Gamma(z" alt="\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,."> %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)</li><li>行间公式：<img src="https://math.jianshu.com/math?formula=\Gamma(z" alt="\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,."> %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)<a id="more"></a>  对应的代码块为：</li></ul><pre class=" language-ruby"><code class="language-ruby">$ \<span class="token function">Gamma</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> \int_0<span class="token operator">^</span>\infty t<span class="token operator">^</span><span class="token punctuation">{</span>z<span class="token number">-1</span><span class="token punctuation">}</span>e<span class="token operator">^</span><span class="token punctuation">{</span><span class="token operator">-</span>t<span class="token punctuation">}</span>dt\<span class="token punctuation">,</span><span class="token punctuation">.</span> $$$\<span class="token function">Gamma</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> \int_0<span class="token operator">^</span>\infty t<span class="token operator">^</span><span class="token punctuation">{</span>z<span class="token number">-1</span><span class="token punctuation">}</span>e<span class="token operator">^</span><span class="token punctuation">{</span><span class="token operator">-</span>t<span class="token punctuation">}</span>dt\<span class="token punctuation">,</span><span class="token punctuation">.</span>$$</code></pre><p>  行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。<br>  下面主要介绍数学公式中常用的一些符号。</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><strong>希腊字母</strong></h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大写</th><th style="text-align:center">code</th><th style="text-align:center">小写</th><th style="text-align:center">code</th></tr></thead><tbody><tr><td style="text-align:center">alpha</td><td style="text-align:center">A</td><td style="text-align:center">A</td><td style="text-align:center">α</td><td style="text-align:center">\alpha</td></tr><tr><td style="text-align:center">beta</td><td style="text-align:center">B</td><td style="text-align:center">B</td><td style="text-align:center">β</td><td style="text-align:center">\beta</td></tr><tr><td style="text-align:center">gamma</td><td style="text-align:center">Γ</td><td style="text-align:center">\Gamma</td><td style="text-align:center">γ</td><td style="text-align:center">\gamma</td></tr><tr><td style="text-align:center">delta</td><td style="text-align:center">Δ</td><td style="text-align:center">\Delta</td><td style="text-align:center">δ</td><td style="text-align:center">\delta</td></tr><tr><td style="text-align:center">epsilon</td><td style="text-align:center">E</td><td style="text-align:center">E</td><td style="text-align:center">ϵ</td><td style="text-align:center">\epsilon</td></tr><tr><td style="text-align:center">zeta</td><td style="text-align:center">Z</td><td style="text-align:center">Z</td><td style="text-align:center">ζ</td><td style="text-align:center">\zeta</td></tr><tr><td style="text-align:center">eta</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">η</td><td style="text-align:center">\eta</td></tr><tr><td style="text-align:center">theta</td><td style="text-align:center">Θ</td><td style="text-align:center">\Theta</td><td style="text-align:center">θ</td><td style="text-align:center">\theta</td></tr><tr><td style="text-align:center">iota</td><td style="text-align:center">I</td><td style="text-align:center">I</td><td style="text-align:center">ι</td><td style="text-align:center">\iota</td></tr><tr><td style="text-align:center">kappa</td><td style="text-align:center">K</td><td style="text-align:center">K</td><td style="text-align:center">κ</td><td style="text-align:center">\kappa</td></tr><tr><td style="text-align:center">lambda</td><td style="text-align:center">Λ</td><td style="text-align:center">\Lambda</td><td style="text-align:center">λ</td><td style="text-align:center">\lambda</td></tr><tr><td style="text-align:center">mu</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">μ</td><td style="text-align:center">\mu</td></tr><tr><td style="text-align:center">nu</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">ν</td><td style="text-align:center">\nu</td></tr><tr><td style="text-align:center">xi</td><td style="text-align:center">Ξ</td><td style="text-align:center">\Xi</td><td style="text-align:center">ξ</td><td style="text-align:center">\xi</td></tr><tr><td style="text-align:center">omicron</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">ο</td><td style="text-align:center">\omicron</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">Π</td><td style="text-align:center">\Pi</td><td style="text-align:center">π</td><td style="text-align:center">\pi</td></tr><tr><td style="text-align:center">rho</td><td style="text-align:center">P</td><td style="text-align:center">P</td><td style="text-align:center">ρ</td><td style="text-align:center">\rho</td></tr><tr><td style="text-align:center">sigma</td><td style="text-align:center">Σ</td><td style="text-align:center">\Sigma</td><td style="text-align:center">σ</td><td style="text-align:center">\sigma</td></tr><tr><td style="text-align:center">tau</td><td style="text-align:center">T</td><td style="text-align:center">T</td><td style="text-align:center">τ</td><td style="text-align:center">\tau</td></tr><tr><td style="text-align:center">upsilon</td><td style="text-align:center">Υ</td><td style="text-align:center">υ</td><td style="text-align:center">\upsilon</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">phi</td><td style="text-align:center">Φ</td><td style="text-align:center">\Phi</td><td style="text-align:center">ϕ</td><td style="text-align:center">\phi</td></tr><tr><td style="text-align:center">chi</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">χ</td><td style="text-align:center">\chi</td></tr><tr><td style="text-align:center">psi</td><td style="text-align:center">Ψ</td><td style="text-align:center">\Psi</td><td style="text-align:center">ψ</td><td style="text-align:center">\psi</td></tr><tr><td style="text-align:center">omega</td><td style="text-align:center">Ω</td><td style="text-align:center">\Omega</td><td style="text-align:center">ω</td><td style="text-align:center">\omega</td></tr></tbody></table><h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a><strong>上标与下标</strong></h2><p>  上标和下标分别使用<code>^</code> 与<code>_</code> ，例如<code>$x_i^2$</code>表示的是：<img src="https://math.jianshu.com/math?formula=x_i^2" alt="x_i^2">。<br>  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code> 表示的是<img src="https://math.jianshu.com/math?formula=10^10" alt="10^10">，而<code>$10^{10}$</code> 才是<img src="https://math.jianshu.com/math?formula=10^{10}" alt="10^{10}">。同时，大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code> ：<img src="https://math.jianshu.com/math?formula={x^5}^6" alt="{x^5}^6">或者<code>$x^{5^6}$</code> ：<img src="https://math.jianshu.com/math?formula=x^{5^6}" alt="x^{5^6}">。</p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a><strong>括号</strong></h2><h3 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h3><p>  使用原始的<code>( )</code> ，<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code> ：<img src="https://math.jianshu.com/math?formula=(2%2B3" alt="(2+3)">) <img src="https://math.jianshu.com/math?formula=[4%2B4]" alt="[4+4]"><br>  使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac{x}{y}\right)$</code> ：<img src="https://math.jianshu.com/math?formula=\left(\frac{x}{y}\right" alt="\left(\frac{x}{y}\right)">)</p><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\{</code>和<code>\}</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。如<code>$\{a\*b\}:a\∗b$</code> 或<code>$\lbrace a\*b\rbrace :a\*b$</code> 表示<img src="https://math.jianshu.com/math?formula=\{a*b\}%3Aa∗b" alt="\{a*b\}:a∗b">。</p><h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h3><p>  区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：<img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math" alt="\langle x \rangle">。</p><h3 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h3><p>  使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：<img src="https://math.jianshu.com/math?formula=\lceil x \rceil" alt="\lceil x \rceil">。</p><h3 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h3><p>  使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：<img src="https://math.jianshu.com/math?formula=\lfloor x \rfloor" alt="\lfloor x \rfloor">。</p><h2 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a><strong>求和与积分</strong></h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>  <code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>  <code>$\sum_{r=1}^n$</code>表示：<img src="https://math.jianshu.com/math?formula=\sum_{r%3D1}^n" alt="\sum_{r=1}^n">。<br>  <code>$$\sum_{r=1}^n$$</code>表示：<img src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" alt="\sum_{r=1}^n"></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>  <code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_{r=1}^\infty$</code>：<img src="https://math.jianshu.com/math?formula=\int_{r%3D1}^\infty" alt="\int_{r=1}^\infty">。<br>  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>  <code>$\iint$</code> ：<img src="https://math.jianshu.com/math?formula=\iint" alt="\iint"><br>  <code>$\iiint$</code> ：<img src="https://math.jianshu.com/math?formula=\iiint" alt="\iiint"><br>  <code>$\iiiint$</code> ：<img src="https://math.jianshu.com/math?formula=\iiiint" alt="\iiiint"></p><h3 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h3><p>  <code>$\prod {a+b}$</code>，输出：<img src="https://math.jianshu.com/math?formula=\prod {a%2Bb}" alt="\prod {a+b}">。<br>  <code>$\prod_{i=1}^{K}$</code>，输出：<img src="https://math.jianshu.com/math?formula=\prod_{i%3D1}^{K}" alt="\prod_{i=1}^{K}">。<br>  <code>$$\prod_{i=1}^{K}$$</code>，输出：<img src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" alt="\prod_{i=1}^{K}">。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>  与此类似的符号还有，<br>  <code>$\prod$</code> ：<img src="https://math.jianshu.com/math?formula=\prod" alt="\prod"><br>  <code>$\bigcup$</code> ：<img src="https://math.jianshu.com/math?formula=\bigcup" alt="\bigcup"><br>  <code>$\bigcap$</code> ：<img src="https://math.jianshu.com/math?formula=\bigcap" alt="\bigcap"><br>  <code>$arg\,\max_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=arg\%2C\max_{c_k}" alt="arg\,\max_{c_k}"><br>  <code>$arg\,\min_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=arg\%2C\min_{c_k}" alt="arg\,\min_{c_k}"><br>  <code>$\mathop {argmin}_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\mathop {argmin}_{c_k}" alt="\mathop {argmin}_{c_k}"><br>  <code>$\mathop {argmax}_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\mathop {argmax}_{c_k}" alt="\mathop {argmax}_{c_k}"><br>  <code>$\max_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\max_{c_k}" alt="\max_{c_k}"><br>  <code>$\min_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\min_{c_k}" alt="\min_{c_k}"></p><h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a><strong>分式与根式</strong></h2><h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><ul><li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img src="https://math.jianshu.com/math?formula=\frac ab" alt="\frac ab">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\frac {a+c+1}{b+c+2}$</code>表示<img src="https://math.jianshu.com/math?formula=\frac {a%2Bc%2B1}{b%2Bc%2B2}" alt="\frac {a+c+1}{b+c+2}">。</li><li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>{a+1\over b+1}</code>：<img src="https://math.jianshu.com/math?formula={a%2B1\over b%2B1}" alt="{a+1\over b+1}"></li></ul><h3 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h3><p>  书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br>  <code>\frac</code> 表示如下：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$</code></pre><p>  显示如下：<br><img src="https://math.jianshu.com/math?formula=x%3Da_0 %2B \frac {1^2}{a_1 %2B \frac {2^2}{a_2 %2B \frac {3^2}{a_3 %2B \frac {4^2}{a_4 %2B ...}}}}" alt="x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}"><br>  <code>\cfrac</code> 表示如下：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$</code></pre><p>  显示如下：<br><img src="https://math.jianshu.com/math?formula=x%3Da_0 %2B \cfrac {1^2}{a_1 %2B \cfrac {2^2}{a_2 %2B \cfrac {3^2}{a_3 %2B \cfrac {4^2}{a_4 %2B ...}}}}" alt="x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}"></p><h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>  根式使用<code>\sqrt</code> 来表示。<br>  如开4次方：<code>$\sqrt[4]{\frac xy}$</code> ：<img src="https://math.jianshu.com/math?formula=\sqrt[4]{\frac xy}" alt="\sqrt[4]{\frac xy}">。<br>  开平方：<code>$\sqrt {a+b}$</code>：<img src="https://math.jianshu.com/math?formula=\sqrt {a%2Bb}" alt="\sqrt {a+b}">。</p><h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a><strong>多行表达式</strong></h2><h3 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h3><p>  定义函数的时候经常需要分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code> 。其中：</p><ul><li>  使用<code>\\</code> 来分类，</li><li>  使用<code>&amp;</code> 指示需要对齐的位置，</li><li>  使用<code>\</code> +<code>空格</code>表示空格。</li></ul><pre class=" language-ruby"><code class="language-ruby">$$<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>\cfrac n2<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\ n\ is\ even\\3n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\  n\ is\ odd\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>$$</code></pre><p>  表示:<br><img src="https://math.jianshu.com/math?formula=f(n" alt="f(n) \begin{cases} \cfrac n2, &amp;if\ n\ is\ even\\ 3n + 1, &amp;if\ n\ is\ odd \end{cases}"> \begin{cases} \cfrac n2%2C %26if\ n\ is\ even\ 3n %2B 1%2C %26if\ n\ is\ odd \end{cases})</p><pre class=" language-ruby"><code class="language-ruby">$$<span class="token function">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  \\<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ <span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>$$</code></pre><p>  表示:<br><img src="https://math.jianshu.com/math?formula=L(Y%2Cf(X" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\ 1, &amp; \text{Y $\neq$ f(X)} \end{cases}">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)<br>  如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code> 代替<code>\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p><pre class=" language-ruby"><code class="language-ruby">$$<span class="token function">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span> \\<span class="token punctuation">[</span>5ex<span class="token punctuation">]</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ <span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>$$</code></pre><p>  表示：<br><img src="https://math.jianshu.com/math?formula=L(Y%2Cf(X" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\[5ex] 1, &amp; \text{Y $\neq$ f(X)} \end{cases}">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)</p><h3 id="多行表达式-1"><a href="#多行表达式-1" class="headerlink" title="多行表达式"></a>多行表达式</h3><p>  有时候需要将一行公式分多行进行显示。</p><pre class=" language-ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span> a<span class="token operator">&amp;</span><span class="token operator">=</span>b<span class="token operator">+</span>c<span class="token operator">-</span>d \\ <span class="token operator">&amp;</span>\quad <span class="token operator">+</span>e<span class="token operator">-</span>f\\ <span class="token operator">&amp;</span><span class="token operator">=</span>g<span class="token operator">+</span>h\\ <span class="token operator">&amp;</span> <span class="token operator">=</span>i \<span class="token keyword">end</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span>\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>$$</code></pre><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{equation}\begin{split} a%26%3Db%2Bc-d \\ %26\quad %2Be-f\\ %26%3Dg%2Bh\\ %26 %3Di \end{split}\end{equation}" alt="\begin{equation}\begin{split} a&amp;=b+c-d \\ &amp;\quad +e-f\\ &amp;=g+h\\ &amp; =i \end{split}\end{equation}"><br>  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><p>  使用<code>\begin{array}...\end{array}</code> 与<code>\left \{</code> 与<code>\right.</code> 配合表示方程组:</p><pre class=" language-ruby"><code class="language-ruby">$$\left \<span class="token punctuation">{</span> \<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span>a_1x<span class="token operator">+</span>b_1y<span class="token operator">+</span>c_1z<span class="token operator">=</span>d_1 \\ a_2x<span class="token operator">+</span>b_2y<span class="token operator">+</span>c_2z<span class="token operator">=</span>d_2 \\ a_3x<span class="token operator">+</span>b_3y<span class="token operator">+</span>c_3z<span class="token operator">=</span>d_3\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>\right<span class="token punctuation">.</span>$$</code></pre><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\left \{ \begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \end{array} \right." alt="\left \{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{array} \right."><br>  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\</code> ,增加些许间隙，<code>\;</code> 增加较宽的间隙，<code>\quad</code> 与<code>\qquad</code> 会增加更大的间隙。</p><h2 id="特殊函数与符号"><a href="#特殊函数与符号" class="headerlink" title="特殊函数与符号"></a><strong>特殊函数与符号</strong></h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>  <code>\snx$</code> : <img src="https://math.jianshu.com/math?formula=sinx" alt="sinx"><br>  <code>\arctanx</code> : <img src="https://math.jianshu.com/math?formula=arctanx" alt="arctanx"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>  小于(<code>\lt</code> )：<img src="https://math.jianshu.com/math?formula=\lt" alt="\lt"><br>  大于(<code>\gt</code> )：<img src="https://math.jianshu.com/math?formula=\gt" alt="\gt"><br>  小于等于(<code>\le</code> )：<img src="https://math.jianshu.com/math?formula=\le" alt="\le"><br>  大于等于(<code>\ge</code> )：<img src="https://math.jianshu.com/math?formula=\ge" alt="\ge"><br>  不等于(<code>\ne</code> ) : <img src="https://math.jianshu.com/math?formula=\ne" alt="\ne"><br>  可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> : <img src="https://math.jianshu.com/math?formula=\not\lt`" alt="\not\lt`"></p><h3 id="集合关系与运算"><a href="#集合关系与运算" class="headerlink" title="集合关系与运算"></a>集合关系与运算</h3><p>  并集(<code>\cup</code> ): <img src="https://math.jianshu.com/math?formula=\cup" alt="\cup"><br>  交集(<code>\cap</code> ): <img src="https://math.jianshu.com/math?formula=\cap" alt="\cap"><br>  差集(<code>\setminus</code> ): <img src="https://math.jianshu.com/math?formula=\setminus" alt="\setminus"><br>  子集(<code>\subset</code> ): <img src="https://math.jianshu.com/math?formula=\subset" alt="\subset"><br>  子集(<code>\subseteq</code> ): <img src="https://math.jianshu.com/math?formula=\subseteq" alt="\subseteq"><br>  非子集(<code>\subsetneq</code> ): <img src="https://math.jianshu.com/math?formula=\subsetneq" alt="\subsetneq"><br>  父集(<code>\supset</code> ): <img src="https://math.jianshu.com/math?formula=\supset" alt="\supset"><br>  属于(<code>\in</code> ): <img src="https://math.jianshu.com/math?formula=\in" alt="\in"><br>  不属于(<code>\notin</code> ): <img src="https://math.jianshu.com/math?formula=\notin" alt="\notin"><br>  空集(<code>\emptyset</code> ): <img src="https://math.jianshu.com/math?formula=\emptyset" alt="\emptyset"><br>  空(<code>\varnothing</code> ): <img src="https://math.jianshu.com/math?formula=\varnothing" alt="\varnothing"></p><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>  <code>\binom{n+1}{2k}</code> : <img src="https://math.jianshu.com/math?formula=\binom{n%2B1}{2k}" alt="\binom{n+1}{2k}"><br>  <code>{n+1 \choose 2k}</code> : <img src="https://math.jianshu.com/math?formula={n%2B1 \choose 2k}" alt="{n+1 \choose 2k}"></p><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p>  (<code>\to</code> ):<img src="https://math.jianshu.com/math?formula=\to" alt="\to"><br>  (<code>\rightarrow</code> ): <img src="https://math.jianshu.com/math?formula=\rightarrow" alt="\rightarrow"><br>  (<code>\leftarrow</code> ): <img src="https://math.jianshu.com/math?formula=\leftarrow" alt="\leftarrow"><br>  (<code>\Rightarrow</code> ): <img src="https://math.jianshu.com/math?formula=\Rightarrow" alt="\Rightarrow"><br>  (<code>\Leftarrow</code> ): <img src="https://math.jianshu.com/math?formula=\Leftarrow" alt="\Leftarrow"><br>  (<code>\mapsto</code> ): <img src="https://math.jianshu.com/math?formula=\mapsto" alt="\mapsto"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>  (<code>\land</code> ): <img src="https://math.jianshu.com/math?formula=\land" alt="\land"><br>  (<code>\lor</code> ): <img src="https://math.jianshu.com/math?formula=\lor" alt="\lor"><br>  (<code>\lnot</code> ): <img src="https://math.jianshu.com/math?formula=\lnot" alt="\lnot"><br>  (<code>\forall</code> ): <img src="https://math.jianshu.com/math?formula=\forall" alt="\forall"><br>  (<code>\exists</code> ): <img src="https://math.jianshu.com/math?formula=\exists" alt="\exists"><br>  (<code>\top</code> ): <img src="https://math.jianshu.com/math?formula=\top" alt="\top"><br>  (<code>\bot</code> ): <img src="https://math.jianshu.com/math?formula=\bot" alt="\bot"><br>  (<code>\vdash</code> ): <img src="https://math.jianshu.com/math?formula=\vdash" alt="\vdash"><br>  (<code>\vDash</code> ): <img src="https://math.jianshu.com/math?formula=\vDash" alt="\vDash"></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>  (<code>\star</code> ): <img src="https://math.jianshu.com/math?formula=\star" alt="\star"><br>  (<code>\ast</code> ): <img src="https://math.jianshu.com/math?formula=\ast" alt="\ast"><br>  (<code>\oplus</code> ): <img src="https://math.jianshu.com/math?formula=\oplus" alt="\oplus"><br>  (<code>\circ</code> ): <img src="https://math.jianshu.com/math?formula=\circ" alt="\circ"><br>  (<code>\bullet</code> ): <img src="https://math.jianshu.com/math?formula=\bullet" alt="\bullet"></p><h3 id="等于"><a href="#等于" class="headerlink" title="等于"></a>等于</h3><p>  (<code>\approx</code> ): <img src="https://math.jianshu.com/math?formula=\approx" alt="\approx"><br>  (<code>\sim</code> ): <img src="https://math.jianshu.com/math?formula=\sim" alt="\sim"><br>  (<code>\equiv</code> ): <img src="https://math.jianshu.com/math?formula=\equiv" alt="\equiv"><br>  (<code>\prec</code> ): <img src="https://math.jianshu.com/math?formula=\prec" alt="\prec"></p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>  (<code>\infty</code> ): <img src="https://math.jianshu.com/math?formula=\infty" alt="\infty"><br>  (<code>\aleph_o</code> ): <img src="https://math.jianshu.com/math?formula=\aleph_o" alt="\aleph_o"><br>  (<code>\nabla</code> ): <img src="https://math.jianshu.com/math?formula=\nabla" alt="\nabla"><br>  (<code>\Im</code> ): <img src="https://math.jianshu.com/math?formula=\Im" alt="\Im"><br>  (<code>\Re</code> ): <img src="https://math.jianshu.com/math?formula=\Re" alt="\Re"></p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>  (<code>\pmod</code> ): <img src="https://math.jianshu.com/math?formula=b \pmod n" alt="b \pmod n"><br>  如<code>a \equiv b \pmod n</code> : <img src="https://math.jianshu.com/math?formula=a \equiv b \pmod n" alt="a \equiv b \pmod n"></p><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>  (<code>\ldots</code> ): <img src="https://math.jianshu.com/math?formula=\ldots" alt="\ldots"><br>  (<code>\cdots</code> ): <img src="https://math.jianshu.com/math?formula=\cdots" alt="\cdots"><br>  (<code>\cdot</code> ): <img src="https://math.jianshu.com/math?formula=\cdot" alt="\cdot"><br>  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p><pre class=" language-ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\ldots<span class="token operator">+</span>a_n \\ a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\cdots<span class="token operator">+</span>a_n\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>$$</code></pre><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{equation} a_1%2Ba_2%2B\ldots%2Ba_n \\ a_1%2Ba_2%2B\cdots%2Ba_n \end{equation}" alt="\begin{equation} a_1+a_2+\ldots+a_n \\ a_1+a_2+\cdots+a_n \end{equation}"></p><h2 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a><strong>顶部符号</strong></h2><p>  对于单字符，<code>\hat x</code> ：<img src="https://math.jianshu.com/math?formula=\hat x" alt="\hat x"><br>  多字符可以使用<code>\widehat {xy}</code> ：<img src="https://math.jianshu.com/math?formula=\widehat {xy}" alt="\widehat {xy}"><br>  类似的还有:<br>  (<code>\overline x</code> ): <img src="https://math.jianshu.com/math?formula=\overline x" alt="\overline x"><br>  矢量(<code>\vec</code> ): <img src="https://math.jianshu.com/math?formula=\vec x" alt="\vec x"><br>  向量(<code>\overrightarrow {xy}</code> ): <img src="https://math.jianshu.com/math?formula=\overrightarrow {xy}" alt="\overrightarrow {xy}"><br>  (<code>\dot x</code> ): <img src="https://math.jianshu.com/math?formula=\dot x" alt="\dot x"><br>  (<code>\ddot x</code> ): <img src="https://math.jianshu.com/math?formula=\ddot x" alt="\ddot x"><br>  (<code>\dot {\dot x}</code> ): <img src="https://math.jianshu.com/math?formula=\dot {\dot x}" alt="\dot {\dot x}"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>  使用<code>\begin{array}{列样式}…\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p><pre class=" language-ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token operator">|</span>lcr<span class="token punctuation">}</span>n <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Left</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Center</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Right</span><span class="token punctuation">}</span> \\\hline<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">0.24</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">125</span> \\<span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">189</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">8</span> \\<span class="token number">3</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">20</span> <span class="token operator">&amp;</span> <span class="token number">2000</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token operator">+</span>10i \\\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>$$</code></pre><p>  得到：<br><img src="https://math.jianshu.com/math?formula=\begin{array}{c|lcr} n %26 \text{Left} %26 \text{Center} %26 \text{Right} \\ \hline 1 %26 0.24 %26 1 %26 125 \\ 2 %26 -1 %26 189 %26 -8 \\ 3 %26 -20 %26 2000 %26 1%2B10i \\ \end{array}" alt="\begin{array}{c|lcr} n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ 2 &amp; -1 &amp; 189 &amp; -8 \\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\ \end{array}"></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><strong>矩阵</strong></h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>  使用<code>\begin{matrix}…\end{matrix}</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p><pre class=" language-ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span><span class="token number">1</span> <span class="token operator">&amp;</span> x <span class="token operator">&amp;</span> x<span class="token operator">^</span><span class="token number">2</span> \\<span class="token number">1</span> <span class="token operator">&amp;</span> y <span class="token operator">&amp;</span> y<span class="token operator">^</span><span class="token number">2</span> \\<span class="token number">1</span> <span class="token operator">&amp;</span> z <span class="token operator">&amp;</span> z<span class="token operator">^</span><span class="token number">2</span> \\\<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>$$</code></pre><p>  得到：<br><img src="https://math.jianshu.com/math?formula=\begin{matrix} 1 %26 x %26 x^2 \\ 1 %26 y %26 y^2 \\ 1 %26 z %26 z^2 \\ \end{matrix}" alt="\begin{matrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \end{matrix}"></p><h3 id="括号-1"><a href="#括号-1" class="headerlink" title="括号"></a>括号</h3><p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin{matrix}…\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p><ol><li>pmatrix<code>$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{pmatrix}1 %26 2 \\ 3 %26 4\\ \end{pmatrix}" alt="\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}"></li><li>bmatrix<code>$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{bmatrix}1 %26 2 \\ 3 %26 4\\ \end{bmatrix}" alt="\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}"></li><li>Bmatrix<code>$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{Bmatrix}1 %26 2 \\ 3 %26 4\\ \end{Bmatrix}" alt="\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}"></li><li>vmatrix<code>$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{vmatrix}1 %26 2 \\ 3 %26 4\\ \end{vmatrix}" alt="\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}"></li><li>Vmatrix<code>$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{Vmatrix}1 %26 2 \\ 3 %26 4\\ \end{Vmatrix}" alt="\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}"></li></ol><h3 id="元素省略"><a href="#元素省略" class="headerlink" title="元素省略"></a>元素省略</h3><p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p><pre class=" language-ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span><span class="token number">1</span><span class="token operator">&amp;</span>a_1<span class="token operator">&amp;</span>a_1<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_1<span class="token operator">^</span>n\\<span class="token number">1</span><span class="token operator">&amp;</span>a_2<span class="token operator">&amp;</span>a_2<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_2<span class="token operator">^</span>n\\\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\ddots<span class="token operator">&amp;</span>\vdots\\<span class="token number">1</span><span class="token operator">&amp;</span>a_m<span class="token operator">&amp;</span>a_m<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_m<span class="token operator">^</span>n\\\<span class="token keyword">end</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>$$</code></pre><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{pmatrix} 1%26a_1%26a_1^2%26\cdots%26a_1^n\\ 1%26a_2%26a_2^2%26\cdots%26a_2^n\\ \vdots%26\vdots%26\vdots%26\ddots%26\vdots\\ 1%26a_m%26a_m^2%26\cdots%26a_m^n\\ \end{pmatrix}" alt="\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\ 1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\ \end{pmatrix}"></p><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\begin{array} ... \end{array}</code> 来实现。</p><pre class=" language-swift"><code class="language-swift">$$\<span class="token keyword">left</span><span class="token punctuation">[</span>  \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  <span class="token punctuation">{</span>c c <span class="token operator">|</span> c<span class="token punctuation">}</span> <span class="token operator">%</span>这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示<span class="token number">2</span>、<span class="token number">3</span>列间插入竖线<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\\hline <span class="token operator">%</span>插入横线，如果去掉\hline就是增广矩阵<span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token number">6</span>\end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  \<span class="token keyword">right</span><span class="token punctuation">]</span>$$</code></pre><p>显示为：<br><img src="https://math.jianshu.com/math?formula=\left[ \begin{array} {c c | c} 1 %26 2 %26 3 \\ \hline 4 %26 5 %26 6 \end{array} \right]" alt="\left[ \begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\ \hline 4 &amp; 5 &amp; 6 \end{array} \right]"></p><h2 id="公式标记与引用"><a href="#公式标记与引用" class="headerlink" title="公式标记与引用"></a><strong>公式标记与引用</strong></h2><p>  使用<code>\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code> 在<code>\tag</code> 之后，如<code>$$a = x^2 - y^3 \tag{1}\label{1}$$</code> 显示为：<br><img src="https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \tag{1}\label{311}" alt="a := x^2 - y^3 \tag{1}\label{311}"><br>  如果不需要被引用，只使用<code>\tag{yourtag}</code> ，<code>$$x+y=z\tag{1.1}$$</code>显示为：<br><img src="https://math.jianshu.com/math?formula=x%2By%3Dz\tag{1.1}" alt="x+y=z\tag{1.1}"><br>  <code>\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref{yourlabel}</code> ，如<code>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</code> 显示为：<br><img src="https://math.jianshu.com/math?formula=a %2B y^3 \stackrel{\eqref{1}}%3D x^2" alt="a + y^3 \stackrel{\eqref{1}}= x^2"></p><p>或者使用<code>\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \stackrel{\ref{111}}= x^2$$</code> 显示为:<br><img src="https://math.jianshu.com/math?formula=a %2B y^3 \stackrel{\ref{1}}%3D x^2" alt="a + y^3 \stackrel{\ref{1}}= x^2"></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><h3 id="黑板粗体字"><a href="#黑板粗体字" class="headerlink" title="黑板粗体字"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\mathbb ABCDEF$</code>：<img src="https://math.jianshu.com/math?formula=\mathbb ABCDEF" alt="\mathbb ABCDEF"><br><code>$\Bbb ABCDEF$</code>：<img src="https://math.jianshu.com/math?formula=\Bbb ABCDEF" alt="\Bbb ABCDEF"></p><h3 id="黑体字"><a href="#黑体字" class="headerlink" title="黑体字"></a>黑体字</h3><p><code>$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src="https://math.jianshu.com/math?formula=\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ" alt="\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ"><br><code>$\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img src="https://math.jianshu.com/math?formula=\mathbf abcdefghijklmnopqrstuvwxyz" alt="\mathbf abcdefghijklmnopqrstuvwxyz"></p><h3 id="打印机字体"><a href="#打印机字体" class="headerlink" title="打印机字体"></a>打印机字体</h3><p><code>$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src="https://math.jianshu.com/math?formula=\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ" alt="\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><strong>参考文档</strong></h2><table><thead><tr><th>#</th><th>链接地址</th><th>文档名称</th></tr></thead><tbody><tr><td>1</td><td><code>blog.csdn.net/dabokele/article/details/79577072</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYm9rZWxlL2FydGljbGUvZGV0YWlscy83OTU3NzA3Mg==" title="https://blog.csdn.net/dabokele/article/details/79577072">Mathjax公式教程<i class="fa fa-external-link"></i></span></td></tr><tr><td>2</td><td><code>blog.csdn.net/ethmery/article/details/50670297</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V0aG1lcnkvYXJ0aWNsZS9kZXRhaWxzLzUwNjcwMjk3" title="https://blog.csdn.net/ethmery/article/details/50670297">基本数学公式语法<i class="fa fa-external-link"></i></span></td></tr><tr><td>3</td><td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbG9uZ3N5L2FydGljbGUvZGV0YWlscy83OTM3ODYyMA==" title="https://blog.csdn.net/lilongsy/article/details/79378620">常用数学符号的LaTeX表示方法<i class="fa fa-external-link"></i></span></td></tr><tr><td>4</td><td><code>www.mathjax.org</code></td><td><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aGpheC5vcmcv" title="https://www.mathjax.org/">Beautiful math in all browsers<i class="fa fa-external-link"></i></span></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown中公式编辑教程&quot;&gt;&lt;a href=&quot;#Markdown中公式编辑教程&quot; class=&quot;headerlink&quot; title=&quot;Markdown中公式编辑教程&quot;&gt;&lt;/a&gt;Markdown中公式编辑教程&lt;/h1&gt;&lt;h1 id=&quot;markdown中公式编辑教程&quot;&gt;&lt;a href=&quot;#markdown中公式编辑教程&quot; class=&quot;headerlink&quot; title=&quot;markdown中公式编辑教程&quot;&gt;&lt;/a&gt;markdown中公式编辑教程&lt;/h1&gt;&lt;p&gt;标签： Mathjax 公式编辑 markdown&lt;/p&gt;
&lt;p&gt;一般公式分为两种形式，行内公式和行间公式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行内公式：&lt;img src=&quot;https://math.jianshu.com/math?formula=\Gamma(z&quot; alt=&quot;\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.&quot;&gt; %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)&lt;/li&gt;
&lt;li&gt;行间公式：&lt;img src=&quot;https://math.jianshu.com/math?formula=\Gamma(z&quot; alt=&quot;\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.&quot;&gt; %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)
    
    </summary>
    
    
      <category term="Tools" scheme="http://xiaoman.ren/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Typora 设置图床</title>
    <link href="http://xiaoman.ren/2021/01/29/Tools/Typora%20%E8%87%AA%E5%8A%A8%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/"/>
    <id>http://xiaoman.ren/2021/01/29/Tools/Typora 自动图床设置/</id>
    <published>2021-01-29T15:54:28.321Z</published>
    <updated>2021-01-29T16:15:09.950Z</updated>
    
    <content type="html"><![CDATA[<p>自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。<br><a id="more"></a></p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"picBed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"uploader"</span><span class="token operator">:</span> <span class="token string">"github"</span><span class="token punctuation">,</span>    <span class="token property">"github"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"repo"</span><span class="token operator">:</span> <span class="token string">"ximan/static_file"</span><span class="token punctuation">,</span> // 仓库名，格式时 username/reponame      <span class="token property">"token"</span><span class="token operator">:</span> <span class="token string">"xxxxxxxx"</span><span class="token punctuation">,</span> // github token      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"images/"</span><span class="token punctuation">,</span> // 自定义存储路径 如： image/      <span class="token property">"branch"</span><span class="token operator">:</span> <span class="token string">"master"</span> // 分支名，默认是 master    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"picgoPlugins"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li><p>首先您要有一个 Github 账号</p></li><li><p>新建一个仓库</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png" alt="image-20210128140803755"></p></li><li><p>生成一个 token 用于 Picgo 操作您的仓库， </p><ul><li><p>访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==" title="https://github.com/settings/tokens">https://github.com/settings/tokens<i class="fa fa-external-link"></i></span></p></li><li><p>然后点击 <code>Generate new token</code></p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png" alt="image-20210128141003873"></p></li><li><p>勾选 <code>repo</code> 并记录 token</p></li></ul></li><li><p>配置 Picgo， 如上 JSON</p></li></ol><h2 id="Typora-设置如下图"><a href="#Typora-设置如下图" class="headerlink" title="Typora 设置如下图"></a>Typora 设置如下图</h2><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png" alt="image-20210128141254331"></p><ul><li><p>下载或更新：大约 18m 的 Picgo 插件，点击安装即可</p></li><li><p>点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入</p></li><li><p>点击验证图片上传选项，验证 github 是否连通</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png" alt="image-20210128141827255"></p></li></ul><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><p>我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9waWNnby5naXRodWIuaW8vUGljR28tQ29yZS1Eb2MvemgvZ3VpZGUvY29uZmlnLmh0bWwjJUU5JUJCJTk4JUU4JUFFJUE0JUU5JTg1JThEJUU3JUJEJUFFJUU2JTk2JTg3JUU0JUJCJUI2" title="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">Typora 文件配置<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9VcGxvYWQtSW1hZ2Uv" title="https://support.typora.io/Upload-Image/">图片上传工具配置<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="http://xiaoman.ren/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>协程知识点</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程知识点/</id>
    <published>2021-01-29T15:54:28.320Z</published>
    <updated>2021-01-29T16:15:36.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><ol><li><strong>轻量级的线程</strong>，并不完全是线程</li><li>可以<strong>顺序的写异步代码</strong>， 降低异步编程带来的负担</li><li><strong>更高效</strong>，<strong>多个协程可以公用一个线程</strong>。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的</li><li><strong>运行在协程中的可中断的方法不会阻塞当前线程</strong><a id="more"></a><h2 id="可中断的方法（suspending-functions）"><a href="#可中断的方法（suspending-functions）" class="headerlink" title="可中断的方法（suspending functions）"></a>可中断的方法（suspending functions）</h2></li></ol><p><strong>可中断的方法有能力中断协程的执行</strong>， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> user <span class="token operator">=</span> suspend <span class="token punctuation">{</span> userService<span class="token punctuation">.</span><span class="token function">doLogin</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">val</span> currentFriends <span class="token operator">=</span> suspend <span class="token punctuation">{</span> userService<span class="token punctuation">.</span><span class="token function">requestCurrentFriends</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><ul><li>可中断方法可以运行在相同或不同的线程，取决于使用方式*</li><li>可中断的方法只能运行在协程中或其它可中断的方法中</li></ul><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">suspendingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do long things</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><h2 id="协程上下文（Coroutine-Context）"><a href="#协程上下文（Coroutine-Context）" class="headerlink" title="协程上下文（Coroutine Context）"></a>协程上下文（Coroutine Context）</h2><p><em>协程上下文是一系列规则和配置的集合，它决定了协程的运行方式</em>， 其内部结构是一个列表容器</p><h2 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h2><p><strong>在协程内部</strong>，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">suspendLogin</span><span class="token punctuation">(</span>username<span class="token operator">:</span> String<span class="token punctuation">,</span> password<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span>String <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    userService<span class="token punctuation">.</span><span class="token function">doLogin</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="调度器-dispatcher"><a href="#调度器-dispatcher" class="headerlink" title="调度器(dispatcher)"></a>调度器(dispatcher)</h3><ul><li><strong>Default</strong>： 未指定 <code>dispathcer</code> 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程</li><li><strong>IO</strong>：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。</li><li><strong>UnConfined</strong>： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议</li><li><strong>Main</strong>: 这个是 UI 相关的</li></ul><h2 id="协程构造器（Coroutine-Builders）"><a href="#协程构造器（Coroutine-Builders）" class="headerlink" title="协程构造器（Coroutine Builders）"></a>协程构造器（Coroutine Builders）</h2><p>根据实际情况，我们可以选择不同的协程构造器，也可以自己创建</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。</p><p><code>runBolcking</code> 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 <code>runBlocking</code> 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">testSuspendedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>    <span class="token keyword">val</span> res <span class="token operator">=</span> <span class="token function">suspendingTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>除了这个场景意外，几乎永不到</p><h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>这个构造器狠重要，因为它可以 <strong>很轻易的创建一个协程</strong>，经常使用。</p><p><code>launch</code> 不会阻塞当前线程（前期是我们使用了合适的 <code>dispatcher</code>）</p><p>这个构造器需要一个作用域（<code>scope</code>）</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">..</span><span class="token operator">..</span><span class="token punctuation">}</span></code></pre><p><code>launch</code> 方法返回一个 <code>Job</code> ，<code>Job</code>  继承了协程上下文(<code>CoroutineContext</code>)</p><p><code>Job</code> 提供了很多有用的方法，一个 <code>Job</code> 可以有一个父 <code>Job</code>，父 <code>Job</code> 可以控制子 <code>Job</code></p><h4 id="job-join"><a href="#job-join" class="headerlink" title="job.join"></a>job.join</h4><p>这个方法可以中断与当前 <code>Job</code> 关联的协程，直到所有子 <code>Job</code> 执行完成。协程内所有可中断的方法与当前 <code>Job</code> 关联。直到子 <code>Job</code> 全部执行完成，与当前 <code>Job</code> 关联的协程才能继续执行。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doCoroutineTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> res1 <span class="token operator">=</span> <span class="token function">suspendingTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> res2 <span class="token operator">=</span> <span class="token function">suspendingTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">process</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span><span class="token punctuation">}</span>job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><code>job.join()</code> 是一个可中断的方法，所以它应该在协程内部被调用。</p><h4 id="job-cancel"><a href="#job-cancel" class="headerlink" title="job.cancel()"></a>job.cancel()</h4><p>取消所有与其关联的子 <code>Job</code> ，加入 <code>suspendingTask1()</code> 正在执行的时候 <code>Job</code> 调用了取消，这个时候 <code>res1</code> 不会再返回， 而且 <code>suspendingTask2()</code> 也不会再执行</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doCoroutineTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> res1 <span class="token operator">=</span> <span class="token function">suspendingTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> res2 <span class="token operator">=</span> <span class="token function">suspendingTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">process</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span><span class="token punctuation">}</span>job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><code>job.cancel</code> 是一个普通方法，不必运行再协程内部</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code> <strong>允许并行地运行多个子线程任务</strong>， 它不是一个可中断方法，当调用 <code>async</code> 启动子协程的同事，后面的代码也会立即执行。 <code>async</code> 通常需要运行再另外一个协程内部，它会返回一个特殊的 <code>Job</code> -&gt; <code>Deferred</code></p><h4 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h4><p><code>Deferred</code> 有一个 <code>await()</code> 函数，它是一个可终端的方法，当需要获取 <code>async</code> 的结果是，需要调用 <code>await()</code> 方法等待。调用后，会中断当前线程，直到其返回结果</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispathcers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>userService<span class="token punctuation">.</span><span class="token function">doLogin</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">val</span> currendFriend <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>userService<span class="token punctuation">.</span><span class="token function">requestCurrentFriends</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token keyword">val</span> suggestedFriends <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span> userService<span class="token punctuation">.</span><span class="token function">requestSuggestedFriends</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">val</span> finalUser <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>friends <span class="token operator">=</span> currenFriends<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> suggestedFriends<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h3 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h3><p>全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>是否伴随 APP 整个生命周期</li><li>没有界面和组件绑定</li></ul><h3 id="自定义协程作用域"><a href="#自定义协程作用域" class="headerlink" title="自定义协程作用域"></a>自定义协程作用域</h3><p>任何类都可以继承 <code>CoroutineScope</code> 作为一个作用域，唯一需要做的事儿就是去重写 <code>coroutineContext</code> 属性</p><p>需要先明白两个概念 <code>dispathcer</code> 和 <code>Job</code></p><ul><li>dispathcer： 用于指定协程默认使用的 dispatcher</li><li>Job: 用在任何需要的时候取消协程</li></ul><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MainActivity<span class="token operator">:</span><span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CoroutineScope <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> coroutineContext<span class="token operator">:</span> CoroutineContext        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>Main <span class="token operator">+</span> job    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> job<span class="token operator">:</span> Job<span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是协程&quot;&gt;&lt;a href=&quot;#什么是协程&quot; class=&quot;headerlink&quot; title=&quot;什么是协程&quot;&gt;&lt;/a&gt;什么是协程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轻量级的线程&lt;/strong&gt;，并不完全是线程&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;顺序的写异步代码&lt;/strong&gt;， 降低异步编程带来的负担&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高效&lt;/strong&gt;，&lt;strong&gt;多个协程可以公用一个线程&lt;/strong&gt;。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行在协程中的可中断的方法不会阻塞当前线程&lt;/strong&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程调度器</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-调度器/</id>
    <published>2021-01-29T15:54:28.319Z</published>
    <updated>2021-01-29T16:16:02.061Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp" alt="img"></p><ul><li>调度器本质上就是协程上下文的实现</li><li>调度器的作用是用来实现线程的切换</li><li>过度使用线程，同样会造成线程安全问题</li><li>suspendMain 是有一个空的上下文，因此不会产生线程的调度</li><li>系统提供的调度器实现，Default, Main, Unconfined, IO<a id="more"></a><h2 id="协程上下文（CoroutineContext）"><a href="#协程上下文（CoroutineContext）" class="headerlink" title="协程上下文（CoroutineContext）"></a>协程上下文（CoroutineContext）</h2></li></ul><p>调度器本质上就是协程上下文的实现</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> CoroutineContext <span class="token punctuation">{</span>    <span class="token keyword">public</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>E<span class="token operator">:</span> Element<span class="token operator">></span> <span class="token keyword">get</span><span class="token punctuation">(</span>key<span class="token operator">:</span> Key<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span>E<span class="token operator">?</span>    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">fold</span><span class="token punctuation">(</span>initial<span class="token operator">:</span>  R<span class="token punctuation">,</span> operation<span class="token operator">:</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> Element<span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span>R    <span class="token keyword">public</span> operator <span class="token keyword">fun</span> <span class="token function">plus</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">)</span><span class="token operator">:</span> CorountineContext <span class="token operator">=</span> <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">minusKey</span><span class="token punctuation">(</span>key<span class="token operator">:</span> Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> CoroutineContext    <span class="token keyword">public</span> <span class="token keyword">interface</span> Key<span class="token operator">&lt;</span>E<span class="token operator">:</span> Element<span class="token operator">></span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> Element <span class="token operator">:</span> CoroutineContext <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">val</span> key<span class="token operator">:</span> Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span>    <span class="token punctuation">}</span>    <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>本质上，上下文就是一个以 <code>key</code> 为索引的  <code>List</code> </p><p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code> ， 每一个 <code>Element</code> 都有一个 <code>Key</code> ，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code>  的子接口，因此也可以作为集合出现。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token function">CombinedContext</span> <span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> left<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span><span class="token keyword">private</span> <span class="token keyword">val</span> element<span class="token operator">:</span> Element<span class="token punctuation">)</span> <span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p><code>CombinedContext</code> 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的<code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 <code>key</code> 来查找</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// “coroutine#1: StandaloneCoroutine{Active}@1ff5025</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span><span class="token punctuation">}</span></code></pre><p>这里的<code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> Job<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span><span class="token function">Element</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * Key for [job] instance in the coroutine context.    */</span>    <span class="token keyword">public</span> <span class="token keyword">companion</span> <span class="token keyword">object</span> Key<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span>Job<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>仿照<code>Thread.currentThread()</code> 来获取当前 <code>Job</code> 的方法 </p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">inline</span> <span class="token keyword">fun</span> Job<span class="token punctuation">.</span>Key<span class="token punctuation">.</span><span class="token function">currentJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span>suspend <span class="token keyword">fun</span> <span class="token function">coroutineJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span>Job<span class="token punctuation">.</span><span class="token function">currentJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">log</span><span class="token punctuation">(</span>Job<span class="token punctuation">.</span><span class="token function">currentJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>获取协程名字</strong></p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>如果有多个上下文，需要添加 <code>+</code> 就可以了</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatcher<span class="token punctuation">.</span>Main <span class="token operator">+</span> <span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> ContinuationInterception<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span><span class="token function">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> Key<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span>ContinuationInterceptor<span class="token operator">></span>    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">interceptContinuation</span><span class="token punctuation">(</span>continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">}</span></code></pre><p>拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，</p><p>协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的<code>Continuation</code>，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。</p><p>我们可以自己定义一个拦截器放到我们协程的上下问中。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyContinuationInterceptor<span class="token operator">:</span> ContinuationInterceptor <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> key <span class="token operator">=</span> ContinuationInterceptor    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">interceptContinuation</span><span class="token punctuation">(</span>continuation<span class="token operator">:</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">MyContinuation</span><span class="token punctuation">(</span>continuation<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> MyCOntinuation<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">val</span> continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> context <span class="token operator">=</span> continuation<span class="token punctuation">.</span>context    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span>Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"&lt;MyContinuation><span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>        continuation<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token function">MyContinuationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">val</span> job <span class="token operator">=</span> async <span class="token punctuation">{</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token string">"Hello"</span>        <span class="token punctuation">}</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"5.<span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>通过 <code>launch</code> 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用<code>async</code> 启动了一个协程，<code>async</code> 和 <code>launch</code>从功能上是同等类型的函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果。可以通过 <code>await</code> 方法获取。</p><pre class=" language-txt"><code class="language-txt">[main] <MyContinuation> Success(kotlin.Unit)[main] 1[main] <MyContinuation> Success(kotlin.Unit)[main] 2[main] 4[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit)[kotlinx.coroutines.DefaultExecutor] 3[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello)[kotlinx.coroutines.DefaultExecutor] 5.Hello[kotlinx.coroutines.DefaultExecutor] 6</code></pre><p>首先，所有协程启动的时候，都会有一次<code>Continuation.resumeWith</code> 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。</p><p>其次 <code>delay</code> 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。</p><p>最后，正是我们需要的结果。</p><p>而协程真正切换线程的逻辑源自于 <code>delay</code>  在 JVM 上，<code>delay</code> 实际上是一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> CoroutineDispatcher <span class="token operator">:</span> <span class="token function">AbstractCoroutineContextElement</span><span class="token punctuation">(</span>ContinuationInterceptor<span class="token punctuation">)</span><span class="token punctuation">,</span> ContinuationInterceptor <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">fun</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> block<span class="token operator">:</span> Runnable<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>调度器本身也是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类<code>AbstracoroutineContextElement</code> 就可以</p><ul><li>Default: 线程池</li><li>Main： UI 线程</li><li>Unconfined：直接执行</li><li>IO：线程池</li></ul><h3 id="UI-相关程序"><a href="#UI-相关程序" class="headerlink" title="UI  相关程序"></a>UI  相关程序</h3><p>Kotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI </p><pre class=" language-kotlin"><code class="language-kotlin">getUserBtn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{</span>    getUser<span class="token punctuation">{</span>user<span class="token operator">-></span> <span class="token punctuation">{</span>        handler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">{</span>            userNameView<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin">typealias Callback <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> Callback<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>因为 <code>getUser</code> 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 <code>handler.post</code> 切换到 UI 线程。</p><p>过度到协程的写法；</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>    continuation <span class="token operator">-></span>     getUser <span class="token punctuation">{</span>        continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>getUserBtn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispathcer<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userNameVite<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>suspendCoroutine</strong></p><p>它运行在协程当中，并且帮助我们获取当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方柏霓我们调用它的 <code>resume</code> 和 <code>resumeWithException</code> 来返回结果或者抛出异常</p><p><strong>Dispatchers.Main</strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">internal</span> <span class="token keyword">object</span> MainDispatcherLoader <span class="token punctuation">{</span>    <span class="token annotation builtin">@JvmField</span>    <span class="token keyword">val</span> dispatcher<span class="token operator">:</span>MainCoroutineDispatcher <span class="token operator">=</span> <span class="token function">loadMainDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">loadMainDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>MainCoroutineDispatcher <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">val</span> factories <span class="token operator">=</span> MainDispatcherFactory<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span>cle <span class="token operator">-></span>                 ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>clz<span class="token punctuation">,</span> clz<span class="token punctuation">.</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">}</span>            factories<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">{</span>it<span class="token punctuation">.</span>loadPriority<span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">tryCreateDispatcher</span><span class="token punctuation">(</span>factories<span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token function">MissingMainCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">MissingMainCoroutineDispatcher</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 是的 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例。</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度器本质上就是协程上下文的实现&lt;/li&gt;
&lt;li&gt;调度器的作用是用来实现线程的切换&lt;/li&gt;
&lt;li&gt;过度使用线程，同样会造成线程安全问题&lt;/li&gt;
&lt;li&gt;suspendMain 是有一个空的上下文，因此不会产生线程的调度&lt;/li&gt;
&lt;li&gt;系统提供的调度器实现，Default, Main, Unconfined, IO
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程/</id>
    <published>2021-01-29T15:54:28.319Z</published>
    <updated>2021-01-29T16:15:57.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 后台启动一个新的协程并继续， launch 协程的构建器</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 非阻塞的等待1s，</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 延时后，输出 </span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 协程已再等待时，主线程还在继续</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻塞主线程 2s 保证， JVM 存活</span><span class="token punctuation">}</span></code></pre><a id="more"></a><p>协程是轻量级的线程。 <code>CoroutineScope</code> 通常与 <code>launch</code> 协程构建器一起启动。</p><p><strong>GlobalScope</strong>： 意味着新协程的生命周期与应用程序的生命周期一致</p><p><code>delay</code> 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。</p><h2 id="桥接阻塞与非阻塞的世界"><a href="#桥接阻塞与非阻塞的世界" class="headerlink" title="桥接阻塞与非阻塞的世界"></a>桥接阻塞与非阻塞的世界</h2><p>使用<code>runBlocking</code> 协程构建器来阻塞，使用非阻塞函数<code>delay</code> 方便，不易与 <code>Thread.sleep()</code> 阻塞函数混淆</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world!"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello "</span><span class="token punctuation">)</span>    runBlocking<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这个表达式阻塞了主线程</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上例，只使用了非阻塞函数 <code>delay</code>, 调用 <code>runBlocking</code> 的主线程会一直阻塞，直到 <code>runBlocking</code> 内部的协程执行完毕</p><p>还可以使用 <code>runBlocking</code> 包裹 main 函数来执行：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">)</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>runBlicking&lt;Unit&gt; {}</code> 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型</p><h2 id="等待一个作业"><a href="#等待一个作业" class="headerlink" title="等待一个作业"></a>等待一个作业</h2><p>延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 启动一个新协程并持有这个作业的引用</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello "</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 等待直到子协程执行结束</span></code></pre><p>这里主协程与后台作业的持续时间没有任何关系了。</p><h2 id="结构化的并发"><a href="#结构化的并发" class="headerlink" title="结构化的并发"></a>结构化的并发</h2><p>当我们使用 <code>GlobalScope.launch</code> 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 <code>join</code> 很容易出错</p><p>结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 <code>GlobalScope</code> 中启动。</p><p>我们使用<code>runBlocking</code> 协程构建器将 <code>main</code> 函数转化为协程，包括 <code>runBlocking</code> 在内的每个协程构建器都将 <code>CoroutineScope</code> 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 <code>join</code> 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// this: CoroutineScope</span>    launch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 在 runBlocking 作用域中启动一个新的协程</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="作用域构建"><a href="#作用域构建" class="headerlink" title="作用域构建"></a>作用域构建</h2><p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束</p><p><code>runBlocking</code> 与 <code>coroutineScope</code>  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 <code>runBlocking</code> 方法会<strong>阻塞</strong>当前线程来等待，而 <code>coroutineScope</code> 只会挂起，会释放底层线程用于其他用途。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> main <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// coroutine scope</span>    launch <span class="token punctuation">{</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">200L</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task from runBlocking"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    coroutineScope <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 创建一个作用域协程</span>        launch <span class="token punctuation">{</span>            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task from nested launch"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100L</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task from coroutine scope"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这一行会在内嵌 launch 之前输出</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine scope is over"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 这一行在内嵌 launch 执行完毕后输出</span><span class="token punctuation">}</span></code></pre><h2 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h2><p>当将 <code>launch{}</code> 内部代码块提取到独立的函数体中时，需要 <code>suspend</code>  修饰新函数。这是一个挂起函数。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>    launch <span class="token punctuation">{</span><span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello "</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspend <span class="token keyword">fun</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="协程很轻量"><a href="#协程很轻量" class="headerlink" title="协程很轻量"></a>协程很轻量</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> main <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>    <span class="token function">repeat</span><span class="token punctuation">(</span>100_000<span class="token punctuation">)</span> <span class="token punctuation">{</span>        launch <span class="token punctuation">{</span>            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况</p><h2 id="全局协程像守护线程"><a href="#全局协程像守护线程" class="headerlink" title="全局协程像守护线程"></a>全局协程像守护线程</h2><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>         <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I`m sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>                  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1399L</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;kotlin&quot;&gt;fun main() {
    GlobalScope.launch {// 后台启动一个新的协程并继续， launch 协程的构建器
        delay(1000L) // 非阻塞的等待1s，
        println(&amp;quot;World!&amp;quot;) // 延时后，输出 
    }
    println(&amp;quot;Hello&amp;quot;) // 协程已再等待时，主线程还在继续
    Thread.sleep(2000L) // 阻塞主线程 2s 保证， JVM 存活
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程异常处理</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-异常处理/</id>
    <published>2021-01-29T15:54:28.318Z</published>
    <updated>2021-01-29T16:16:07.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>协程内部异常处理流程</strong>： </p><p><code>launch</code> 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 <code>CoroutineExceptionHandler</code> 中，如果没有配置，会查找全局（JVM）上的<code>CoroutineExceptionHandler</code> 处理，</p><a id="more"></a><p> <code>async</code> 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 <code>await</code> 时抛出</p></li><li><p><strong>异常在作用域内传播</strong></p><p>当协程出现异常时，会根据当前作用域触发异常传递</p><p><code>GlobalScope</code> 会创建一个独立的作用域，<strong>自成一派</strong></p><p><code>coroutineScope</code>  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 <code>coroutineScope</code> 整体进行捕获，也可以捕获到该异常，<strong>一损俱损</strong></p><p><code>supervisorScope</code> 子协程的异常不会向上传递， <strong>自作自受</strong></p></li><li><p><strong>join</strong> 和 <strong>await</strong></p><p><code>join</code>  只关心是否执行完， <code>await</code> 则关心运行的结果</p><p>因此 <code>join</code> 在协程出现异常时也不会抛出该异常，而 <code>await</code> 则会直接抛出异常；</p><p><strong>Note:</strong> 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 <code>join</code> 时，尽管不会对协程本身的异常进行抛出，但如果 <code>join</code> 调用所在的协程被取消，就会抛出 <em>取消异常</em></p></li></ol><p>当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Callback<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>t<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> Callback<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>suspend <span class="token keyword">fun</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>continuation<span class="token operator">-></span>    <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token operator">:</span> Callback<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>user<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token punctuation">{</span>            continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>resume<span class="token punctuation">)</span>        <span class="token punctuation">}</span>         <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>                                                        <span class="token punctuation">}</span>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        userNameView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token operator">:</span>Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userNameView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Get user error: <span class="token interpolation variable">$e</span>"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>线程也好，RxJava 也好，都会有全局处理异常的方式</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">setDefaultUncaughtExceptionHandler</span><span class="token punctuation">{</span>t<span class="token operator">:</span> Thread<span class="token punctuation">,</span> e<span class="token operator">:</span> Throwable <span class="token operator">-></span>        <span class="token comment" spellcheck="true">// handle exception here</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread '<span class="token interpolation"><span class="token delimiter variable">${</span>t<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>' throws an exception with mesage '<span class="token interpolation"><span class="token delimiter variable">${</span>e<span class="token punctuation">.</span>message<span class="token delimiter variable">}</span></span>'"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"Hey!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>RxJava 设置全局异常捕获</p><pre class=" language-java"><code class="language-java">RxJavaPlugins<span class="token punctuation">.</span><span class="token function">setErrorHandler</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Throws an exception with message '${e.message}'"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>协程也可以设置</strong>，类似于通过 <code>Thread.setUnCaughtExceptionHandler</code> 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code> 这样协程内未捕获的异常既可以通过它来捕获</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> suspend <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">val</span> exceptionHandler <span class="token operator">=</span> CoroutineExceptionHandler<span class="token punctuation">{</span> coroutineContext<span class="token punctuation">,</span> throwable <span class="token operator">-></span>         <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Throws an exception with message: '<span class="token interpolation"><span class="token delimiter variable">${</span>throwable<span class="token punctuation">.</span>message<span class="token delimiter variable">}</span></span>'"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>exceptionHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">ArithemticException</span><span class="token punctuation">(</span><span class="token string">"Hey!"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>ConroutineExceptionHandler</code> 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> GlobalCoroutineExceptionHandler<span class="token operator">:</span> CoroutineExceptionHandler <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> key<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> CoroutineExceptinHandler    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">handleException</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CoroutineContext<span class="token punctuation">,</span> exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"coroutine exceptino: <span class="token interpolation variable">$exception</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后在 <code>classpath</code> 中创建 <code>META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全名</p><pre class=" language-tex"><code class="language-tex">com.***.***.exceptions.GlobalCoroutineExceptionHandler</code></pre><h2 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h2><h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>当我们启动协程的时候，一直都在用 <code>GlobalScope</code> ，意味着这是要给独立的顶级协程作用域，此外还有<code>coroutineScope{}</code> 及 <code>supervisorScope{}</code></p><ul><li>通过 <code>GlobalScope</code> 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 <code>GlobalScope</code> 启动的协程自成一派</li><li><code>coroutineScope</code> 是继承外部 <code>Job</code> 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，<strong>任何一个子协程异常退出，那么整体都将退出</strong>， <strong>一损俱损</strong> ，同时这也是协程内部再启动子协程的默认作用域</li><li><code>supervisorScope</code> 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着<strong>子协程出现了异常并不会影响父协程以及其他兄弟协程</strong>，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，<strong>自作自受</strong>。<code>supervisorScope</code> 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，<strong>即<code>supervosorScope</code> 只作用其直接子协程</strong></li></ul><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        coroutineScope <span class="token punctuation">{</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>            launch <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                launch <span class="token punctuation">{</span>                    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>                    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>                job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"10 <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"12 <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-tex"><code class="language-tex">1263548710 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@695fd68b12 java.lang.ArithmeticException: Hello13</code></pre><p>从上面的程序和结果我们可以看出，<strong>10</strong>  这里，我们调用 <code>join</code> 收到了一个取消异常，在协程当中支持取消的操作的 <code>suspend</code> 函数在取消是抛出一个 <code>CancellationException</code>。</p><p>协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 <code>job.join()</code> 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。</p><p>我们将 <code>coroutineScope</code> 换成 <code>supervisorScope</code> ，其他不变</p><pre class=" language-tex"><code class="language-tex">12635487Exception in thread "DefaultDispatcher-worker-3" java.lang.ArithmeticException: Hello    at com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69)    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)    at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)    at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)    at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)91113</code></pre><p>我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。</p><p>我们为内部协程增加啊一个 <code>CoroutineExceptionHandler</code> 就可以证明我们一个结论</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> exceptionHandler <span class="token operator">=</span> CoroutineExceptioHandler <span class="token punctuation">{</span>coroutineContext<span class="token punctuation">,</span> throwable <span class="token operator">-></span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>coroutineContext<span class="token punctuation">[</span>CoroutineName<span class="token punctuation">]</span><span class="token delimiter variable">}</span></span> <span class="token interpolation variable">$throwable</span>"</span><span class="token punctuation">)</span>                                     <span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        superisorScope <span class="token punctuation">{</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">launch</span><span class="token punctuation">(</span>exceptionHandler <span class="token operator">+</span> <span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                <span class="token function">launch</span> <span class="token punctuation">(</span>exceptionHandler <span class="token operator">+</span> <span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>                    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>                job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"10 <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"12 <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-tex"><code class="language-tex">12635487CoroutineName(2) java.lang.ArithmeticException: Hello91113</code></pre><p>我们看到，触发<code>CoroutineExceptionHandler</code> 的是协程 2。</p><h3 id="如何使用-scope"><a href="#如何使用-scope" class="headerlink" title="如何使用 scope"></a>如何使用 scope</h3><ul><li>对于没有协程作用域，但需要启动协程的时候，适合用 <strong>GlobalScope</strong></li><li>对于已经由协程作用域的情况，直接用协程启动器启动</li><li>对于明确要求子协程之间互相独立不干扰时，使用 <strong>supervisorScope</strong></li><li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 <code>Job</code> 作用域等概念的支撑，例如 <code>suspernd main</code> ，有限考虑通过 <code>coroutineScope</code> 创建作用域</li></ul><h2 id="join-和-await"><a href="#join-和-await" class="headerlink" title="join 和 await"></a>join 和 await</h2><p>前面的例子一直是用 <code>launch</code> 启动协程常用的还有 <code>async</code>, <code>actor</code> <code>produce</code> 其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获异常出现以后，会抛出。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。</p><h3 id="什么是消费结果"><a href="#什么是消费结果" class="headerlink" title="什么是消费结果"></a>什么是消费结果</h3><p>两组协程启动器，我们可以分别认为是 <em>消费者</em> 和 <em>生产者</em> </p><p>消费者异常立即抛出；生产者只有结果异常时抛出</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a><strong>async 和 await</strong></h3><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> deferred <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span>async<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> value <span class="token operator">=</span> deferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1. <span class="token interpolation variable">$value</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"2. <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们</p><pre class=" language-tex"><code class="language-tex">2. java.lang.ArithmeticException</code></pre><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join</code> 则和 <code>await</code> 不同， <code>join</code> 只关心是否执行完，至于为什么完成，它不关心。将上面的 <code>await</code> 替换成 <code>join</code> 后 </p><pre class=" language-tex"><code class="language-tex">1. kotlin.Unit</code></pre><p>异常信息被吞掉了，用 <code>launch</code> 替换 <code>async</code> ，<code>join</code> 处仍然不会有任何响应。</p><p><code>launch</code> 中未捕获的异常与 <code>aysync</code> 的处理方式不同， <code>launch</code> 会直接抛出异常给父协程，如果没有父协程或者处于 <code>supervisorScope</code> 中父协程不响应，那么就会交给上下文中执行的 <code>CoroutineExceptionHandler</code> 处理，如果没有指定，那就传给全局的 <code>CoroutineExcetionHandler</code> 等等。而 <code>async</code>  则要等 <code>await</code> 来消费</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;协程内部异常处理流程&lt;/strong&gt;： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;launch&lt;/code&gt; 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; 中，如果没有配置，会查找全局（JVM）上的&lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; 处理，&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程挂起</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E6%8C%82%E8%B5%B7/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-挂起/</id>
    <published>2021-01-29T15:54:28.318Z</published>
    <updated>2021-01-29T16:16:05.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><ul><li><p>线程: <code>Thread.sleep()</code></p><p><code>sleep</code> 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行</p></li><li><p>协程: <code>delay</code> </p><p><code>delay</code> 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 <code>delay</code> 也可以要让协程休眠的一种手段</p><a id="more"></a><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> suspend <span class="token keyword">fun</span> <span class="token function">delay</span><span class="token punctuation">(</span>timeMillis<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>timeMillis <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">return</span> suspendCancellableCoroutine <span class="token label symbol">sc@</span> <span class="token punctuation">{</span>cont<span class="token operator">:</span> CancellableContinuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token operator">-></span>         cont<span class="token punctuation">.</span>context<span class="token punctuation">.</span>delay<span class="token punctuation">.</span><span class="token function">scheduleResumeAfterDelay</span><span class="token punctuation">(</span>timeMillis<span class="token punctuation">,</span> cont<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> <code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作,可以类比 Android 的 <code>handler.postDealy</code> ,本质上就是设置了一个延时回调,时间一到就调用 <code>resume</code> 方法让协程继续执行</p></li></ul><h2 id="SuspendCancellableCoroutine"><a href="#SuspendCancellableCoroutine" class="headerlink" title="SuspendCancellableCoroutine"></a>SuspendCancellableCoroutine</h2><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">override</span> suspend <span class="token keyword">fun</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">joinInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// fast-path no wait</span>            coroutineContext<span class="token punctuation">.</span><span class="token function">checkCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// do not suspend</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">joinSuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// slow-path wait</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> suspend <span class="token keyword">fun</span> <span class="token function">joinSuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCancellableCoroutine<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span> cont <span class="token operator">-></span>        <span class="token comment" spellcheck="true">// We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers</span>        cont<span class="token punctuation">.</span><span class="token function">disposeOnCancellation</span><span class="token punctuation">(</span><span class="token function">invokeOnCompletion</span><span class="token punctuation">(</span>handler <span class="token operator">=</span> <span class="token function">ResumeOnCompletion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cont<span class="token punctuation">)</span><span class="token punctuation">.</span>asHandler<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p><code>Job.join()</code> 这个方法会先检查调用者 <code>Job</code> 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 <code>joinSuspend</code> 。这里只注册了一个完成时的回调</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> suspend <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCancellableCoroutine</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>CancellableContinuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span>T <span class="token operator">=</span> suspendCoroutineUninterceptedOrReturn<span class="token punctuation">{</span> uCont<span class="token operator">-></span>    <span class="token keyword">val</span> cancelable <span class="token operator">=</span> <span class="token function">CancellableContinuationImpl</span><span class="token punctuation">(</span>uCont<span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> resumeMode <span class="token operator">=</span> MODE_CANCELLABLE<span class="token punctuation">)</span>    <span class="token function">block</span><span class="token punctuation">(</span>cancellable<span class="token punctuation">)</span>    cancellable<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法帮助我们拿到 <code>Continuation</code> 实例，<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 <code>cancellable.getResult()</code> 的类型。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">internal</span> <span class="token keyword">fun</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>Any<span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">trySuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> COROUTINE_SUSPEND <span class="token comment" spellcheck="true">// 触发挂起逻辑</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token keyword">is</span> CompletedExceptionally<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 异常立即抛出</span>        <span class="token keyword">throw</span> <span class="token function">recoverStackTrce</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>cause<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">getSuccessfulResult</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 正常结果立即返回</span><span class="token punctuation">}</span></code></pre><p><code>trySuspend()</code> 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。</p><p>然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> vla COROUTINE_SUSPEND<span class="token operator">:</span> Any <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> CoroutineSingletons<span class="token punctuation">.</span>COROUTINE_SUSPEND<span class="token keyword">internal</span> <span class="token keyword">enum</span> <span class="token keyword">class</span> CoroutineSingletons <span class="token punctuation">{</span>CONTINE_SUSPEND<span class="token punctuation">,</span> UNDECIDED<span class="token punctuation">,</span> RESUMED<span class="token punctuation">}</span></code></pre><p>而 <code>trySuspend()</code> 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。</p><h2 id="深入挂起操作"><a href="#深入挂起操作" class="headerlink" title="深入挂起操作"></a>深入挂起操作</h2><p>真正的挂起是什么？</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutineUninterceptedOrReturn<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>    continuation <span class="token operator">-></span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    thread <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    CONTROUTINE_SUSPEND<span class="token punctuation">}</span></code></pre><p>上面这一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回这个 <code>COROUTINE_SUSPEND</code></p><h2 id="协程的状态转移"><a href="#协程的状态转移" class="headerlink" title="协程的状态转移"></a>协程的状态转移</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContinuationImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Continuation</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> label <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> completion<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ContinuationImpl</span><span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> completion<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>completion <span class="token operator">=</span> completion<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> CoroutineContext <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> EmptyCoroutineContext<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Object resume <span class="token operator">=</span> o<span class="token punctuation">;</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>                     LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    result <span class="token operator">=</span> SuspendFunctionsKt<span class="token punctuation">.</span><span class="token function">returnSuspended</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    label<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isSuspended</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>               <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                    LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                    result <span class="token operator">=</span> DelayKt<span class="token punctuation">.</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    label<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isSuspended</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                    LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                        result <span class="token operator">=</span> SuspendedFunctionsKt<span class="token punctuation">.</span><span class="token function">returnImmediately</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    label<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isSuspended</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                    LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    LogKt<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completion<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>Unit<span class="token punctuation">.</span>INSTACNE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        completion<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSuspended</span><span class="token punctuation">(</span>Object result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> result <span class="token operator">==</span> IntrinsicsKt<span class="token punctuation">.</span><span class="token function">getCOROUTINE_SUSPENDED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>实际上，在 Kotlin 的标准库中，有一个 <code>ContinuationImpl</code> 的累，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code> 而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 <code>launch</code> 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code>  的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p></blockquote><p>仿照 <code>runSuspend</code> 类，我们实现一个 completion </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunSuspend</span> <span class="token keyword">implements</span> <span class="token class-name">Continuation</span><span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object result<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> CoroutineContext <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> EmptyCoroutineContext<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> Object result<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> result<span class="token punctuation">;</span>            <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 协程已结束，通知下面的 wait() 方法停止阻塞</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Object result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">Throwable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    RunSuspend runSuspend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunSuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ContinationImpl table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContinuationImpl</span><span class="token punctuation">(</span>runSuspend<span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>Unit<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>    runSuspend<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>这种写法，简直就是 <code>suspend main</code> 的真是面目。</p></blockquote><p><code>completion</code> 传入的 <code>runSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWith</code> 的最后才被调用，因为它的 <code>await()</code> 一旦进入阻塞状态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Delay&quot;&gt;&lt;a href=&quot;#Delay&quot; class=&quot;headerlink&quot; title=&quot;Delay&quot;&gt;&lt;/a&gt;Delay&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程: &lt;code&gt;Thread.sleep()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sleep&lt;/code&gt; 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程: &lt;code&gt;delay&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;delay&lt;/code&gt; 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 &lt;code&gt;delay&lt;/code&gt; 也可以要让协程休眠的一种手段&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程启动</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%90%AF%E5%8A%A8/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-启动/</id>
    <published>2021-01-29T15:54:28.317Z</published>
    <updated>2021-01-29T16:16:09.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程-启动"><a href="#协程-启动" class="headerlink" title="协程-启动"></a>协程-启动</h1><p><strong>启动模式</strong></p><ol><li>DEFAULT： 立即执行</li><li>LAZY： 需要时执行</li><li>ATOMIC： 立即执行，但开始前不会被取消</li><li>UNDISPATCHED： 立即执行，直到第一个 suspend 挂起</li></ol><a id="more"></a><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> thread <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上面是线程的启动方法，通常还会忘记去写 <code>start()</code> ，那再 kotlin 中</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> myThread <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>start <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//do you wang</span><span class="token punctuation">}</span></code></pre><p><code>start()</code> 方法是默认被开启自动会执行的，为我们省去了很多麻煩</p><h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do you want</span><span class="token punctuation">}</span></code></pre><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token keyword">class</span> CoroutineStart <span class="token punctuation">{</span>    DEFAULT<span class="token punctuation">,</span>    LAZY<span class="token punctuation">,</span>    <span class="token annotation builtin">@ExperimentalCoroutinesApi</span>    ATOMIC，    <span class="token annotation builtin">@ExperimentalCoroutinesApi</span>    UNDISPATCHED；<span class="token punctuation">}</span></code></pre><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>DEFAULT</td><td>立即执行协程体</td></tr><tr><td>ATOMIC</td><td>立即执行协程体，但在开始运行之前无法取消</td></tr><tr><td>UNDISPATCHED</td><td>立即在当前线程执行协程体，直到第一个 suspend 调用</td></tr><tr><td>LAZY</td><td>只有在需要的情况下运行</td></tr></tbody></table><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>四种启动模式中，常用的其实是<code>DEFAULT</code> 和 <code>LAZY</code></p><p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。</p><pre class=" language-KOTLIN"><code class="language-KOTLIN">suspend fun main() {    log(1)    val job = GlobalScope.launch{        log(2)    }    log(3)    job.join()    log(4)}</code></pre><p>采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是</p><pre class=" language-tex"><code class="language-tex">[main] 1[main] 3[DefaultDispatcher-worker-1] 2[main] 4</code></pre><p>它取决于 CPU 对于当前线程和后台线程的调度顺序</p><h3 id="LAZY"><a href="#LAZY" class="headerlink" title="LAZY"></a>LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。<code>launch</code> 后会返回一个 <code>job</code> 实例，因此我们可以通过 <code>job</code> 来实现</p><ul><li>调用 <code>Job.start()</code> 主动触发协程的调度</li><li>调用 <code>Job.join()</code> 隐式的触发协程的调度</li></ul><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p>其输出结果可能为</p><pre class=" language-tex"><code class="language-tex">[main] 1[main] 3[main] 4[DefaultDispatcher-worker-1] 2</code></pre><p>运气好话，2 也可能在 4  的前面，而对于 <code>join()</code></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p>因为要等待协程执行完毕，因此数据结果一定是</p><pre class=" language-tex"><code class="language-tex">[main] 1[main] 3[DefaultDispatcher-worker-1] 2[main] 4</code></pre><h3 id="ATOMIC"><a href="#ATOMIC" class="headerlink" title="ATOMIC"></a>ATOMIC</h3><p><code>ATOMIC</code> 只有涉及到 <code>cancel</code> 的时候才有意义， <code>cancel</code> 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 <code>cancel</code> 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>ATOMIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span>job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>我们创建写成后立即 <code>cancel</code> 但由于 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说</p><p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时，如果 <code>cancel</code> 就已经调用，那么协程就会被直接 <code>cancel</code> 而不会有任何调度。</p><blockquote><p>需要注意， <code>cancel</code> 调用一定会将 job 的状态设置为 cancelling, 只不过 <code>ATOMIC</code> 模式的协程在启动时无视了这一状态。</p></blockquote><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>ATOMIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span>job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>2 和 3 之间加了一个 <code>delay</code> ，<code>delay</code> 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 <code>ATOMIC</code> 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 <code>suspend</code> 函数，此时程序迎来了第一个挂起点，恰好 <code>delay</code> 是支持 <code>cancel</code> 的，因此后面的 3 将不会打印。</p><h4 id="UNDISPATCHED"><a href="#UNDISPATCHED" class="headerlink" title="UNDISPATCHED"></a>UNDISPATCHED</h4><p>协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 <code>ATOMIC</code> 很像，不同在于 <code>DISPATCHED</code> 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>UNDISPATCHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协程-启动&quot;&gt;&lt;a href=&quot;#协程-启动&quot; class=&quot;headerlink&quot; title=&quot;协程-启动&quot;&gt;&lt;/a&gt;协程-启动&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;启动模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DEFAULT： 立即执行&lt;/li&gt;
&lt;li&gt;LAZY： 需要时执行&lt;/li&gt;
&lt;li&gt;ATOMIC： 立即执行，但开始前不会被取消&lt;/li&gt;
&lt;li&gt;UNDISPATCHED： 立即执行，直到第一个 suspend 挂起&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程取消</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%8F%96%E6%B6%88/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-取消/</id>
    <published>2021-01-29T15:54:28.316Z</published>
    <updated>2021-01-29T16:16:13.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样</p></blockquote><h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><p>当我们执行一个任务时,很快就后悔了,怎么办?<br><a id="more"></a></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> thread <span class="token operator">=</span> thread <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">:</span>Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"interrupted, do cleaning stuff"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当线程被标记为中断状态,就会抛出 <code>InterruptedException</code> ,我们可以进行捕获做资源清理.</p><p>所以,所谓的协作式任务种植,协程的取消也是<code>cancel</code>机制的设计思路.</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>    <span class="token keyword">val</span> job1 <span class="token operator">=</span> launch<span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    job1<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>delay</code> 与线程中的 <code>sleep</code> 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 <code>delay</code> 还没有回调的时候,协程就被取消了,因为 <code>delay</code> 可以影响取消,因此 <code>delay</code> 后面的代码就不会再次调度,直接抛出一个 <code>CancellationException</code></p><p><strong>完善前面的一个例子</strong></p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>continuation <span class="token operator">-></span>     <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token operator">:</span> Callback<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>value<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>            continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onFailed</span><span class="token punctuation">(</span>e<span class="token operator">:</span>Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>加上取消逻辑</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCancellableCoroutine<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span> continuation<span class="token operator">-></span>     <span class="token keyword">val</span> call <span class="token operator">=</span> <span class="token function">OkHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    continuation<span class="token punctuation">.</span><span class="token function">invokeOnCancellation</span><span class="token punctuation">{</span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         call<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>     call<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> okhttp3<span class="token punctuation">.</span><span class="token function">Callback</span><span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onFailure</span><span class="token punctuation">(</span>call<span class="token operator">:</span> Call<span class="token punctuation">,</span> e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"onFailure: <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>            continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResponse</span><span class="token punctuation">(</span>call<span class="token operator">:</span> Call<span class="token punctuation">,</span> response<span class="token operator">:</span> Response<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"onResponse: <span class="token interpolation"><span class="token delimiter variable">${</span>response<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>            response<span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token operator">?:</span> continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span><span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"ResponseBody is null"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>suspendCancellableCoroutine</code>  是为了让我们的挂起函数支持协程的取消.该方法将获取到的<code>Continuation</code> 包装成了一个<code>CacncellableContinuation</code> 通过调用 <code>invokeOnCancellation</code> 方法可以设置一个取消时间的回调,一旦被调用,意味着 <code>getUserCoroutine</code> 调用所在的协程将被取消,我们也应该相应的做出取消操作.</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> job1 <span class="token operator">=</span> launch <span class="token punctuation">{</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">getUserCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">delayt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>job1<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><pre class=" language-tex"><code class="language-tex">13invokeOnCancellation: cancel the request.4onFilure: java.io.IOException: Canceled</code></pre><p>取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用<code>continuation.resume</code> <code>continuation.resumeWithException</code> <code>continuation.resumtWith</code>  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 <code>continuation.resumeWithException(e)</code>  不会有任何副作用.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程的中断&quot;&gt;&lt;a href=&quot;#线程的中断&quot; class=&quot;headerlink&quot; title=&quot;线程的中断&quot;&gt;&lt;/a&gt;线程的中断&lt;/h2&gt;&lt;p&gt;当我们执行一个任务时,很快就后悔了,怎么办?&lt;br&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程入门</title>
    <link href="http://xiaoman.ren/2021/01/29/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaoman.ren/2021/01/29/Kotlin/协程/协程-入门/</id>
    <published>2021-01-29T15:54:28.315Z</published>
    <updated>2021-01-29T16:16:18.533Z</updated>
    
    <content type="html"><![CDATA[<ul><li>协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。</li><li>线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着</li><li>协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。</li><li>协程的三要素：上下文、启动模式、协程体</li><li><p>多个协程可以共用一个线程</p></li><li><p>协程的本质</p><ul><li>协程的挂起函数本质上就是一个回调，回调类型就是<code>Continuation</code></li><li>协程体的执行就是一个<em>状态机</em>，每一次遇到挂起函数，都是一次状态转移</li></ul></li></ul><a id="more"></a><h2 id="通过-Retrofit-请求"><a href="#通过-Retrofit-请求" class="headerlink" title="通过 Retrofit 请求"></a>通过 Retrofit 请求</h2><p>通过 <code>Retrofit</code> 发送一个网络请求</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> GitHubServiceApi <span class="token punctuation">{</span>    <span class="token annotation builtin">@GET</span><span class="token punctuation">(</span><span class="token string">"users/{login}"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation builtin">@Path</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span> login<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">:</span>Call<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">}</span><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> id<span class="token operator">:</span>String<span class="token punctuation">,</span> <span class="token keyword">val</span> name<span class="token operator">:</span>String<span class="token punctuation">,</span> <span class="token keyword">val</span> url<span class="token operator">:</span>String<span class="token punctuation">)</span></code></pre><p><code>Retrofit</code> 初始化如下</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> githubServiceApi <span class="token keyword">by</span> lazy <span class="token punctuation">{</span>    <span class="token keyword">val</span> retorfit <span class="token operator">=</span> retrofit2<span class="token punctuation">.</span>Retrofit<span class="token punctuation">.</span><span class="token function">Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">baseUrl</span><span class="token punctuation">(</span><span class="token string">"https//api.github.com"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">addConverterFacetory</span><span class="token punctuation">(</span>GsonConverterFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    retrofit<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>GitHUbServiceApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>发起网络请求</p><pre class=" language-kotlin"><code class="language-kotlin">githubServiceApi<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">"small"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token operator">:</span> Callback<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onFailure</span><span class="token punctuation">(</span>call<span class="token operator">:</span> Call<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">,</span> t<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        handler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">{</span><span class="token function">showError</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>call<span class="token operator">:</span> Call<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">,</span> response<span class="token operator">:</span> Response<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        handler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">(</span><span class="token operator">::</span>showUser<span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token function">showError</span><span class="token punctuation">(</span><span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="改造为携程"><a href="#改造为携程" class="headerlink" title="改造为携程"></a>改造为携程</h2><p>对于 <code>Retrofit</code> 改造为协程的方式有两种，分别通过 <code>CallAdapter</code> 和 <code>suspend</code> 函数</p><h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>该方法的本质是让接口的方法返回一个协程的 <code>Job</code></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> GitHubServiceApi <span class="token punctuation">{</span>    <span class="token annotation builtin">@GET</span><span class="token punctuation">(</span><span class="token string">"users/{login}"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation builtin">@Path</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span>login<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">:</span>Deferred<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">}</span></code></pre><blockquote><p>Deferred 是 Job 的子接口</p></blockquote><p>同时需要为 <code>Retrofit</code> 添加对 <code>Deferred</code> 的支持</p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></code></pre><p>对构造 <code>Retorfit</code> 的实例添加</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> githubServiceApi <span class="token keyword">by</span> lazy <span class="token punctuation">{</span>    <span class="token keyword">val</span> retorfit <span class="token operator">=</span> retrofit2<span class="token punctuation">.</span>Retrofit<span class="token punctuation">.</span><span class="token function">Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">baseUrl</span><span class="token punctuation">(</span><span class="token string">"https//api.github.com"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">addConverterFactory</span><span class="token punctuation">(</span>GsonConverterFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">addCallAdapterFactory</span><span class="token punctuation">(</span><span class="token function">CoroutineCallAdapterFactroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    retrofit<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>GitHubServiceApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>通过上面的修改，那么我们的请求就可以这样写</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">showUser</span><span class="token punctuation">(</span>githubServiceApi<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">"small"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">shwoError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Note:</strong>  我们首先通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个: 协程上下文、协程启动模式、协程体</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> CorountineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>    context<span class="token operator">:</span>CorountineContext <span class="token operator">=</span> EmptyCouroutineContext<span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 上下文</span>    start<span class="token operator">:</span> CoroutineStart <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>DEFGAULT<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 启动模式</span>    block<span class="token operator">:</span> suspend CorountineScope<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> UNit <span class="token comment" spellcheck="true">// 协程体</span><span class="token punctuation">)</span> <span class="token operator">:</span>Job</code></pre><p><strong>启动模式</strong> 不是一个复杂的概念，默认直接俄允许调度执行</p><p><strong>上下文</strong>可以有很多作用，包括<em>携带参数</em>、<em>拦截协程执行</em>等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保<code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己再 <code>launch</code> 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）</p><p>换句话说，在例子当中的整个 <code>launch</code> 内部，你看到的代码都是运行在UI线程中的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 <code>getUser</code> 返回了要给 <code>Deferred</code> 类型，他的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么<code>await</code> 不会阻塞 UI 线程嘛？</p><p>当然不会。不然 <code>Deferred</code> 于 <code>Future</code>  又有上面区别的，这里<code>await</code>  很可疑。因为实际上是要给 <code>suspend</code> 函数。整个函数只能在协程体或者其他 <code>suspend</code> 函数内部被调用，就像是回调的语法糖一样，通过一个叫 <code>Continuation</code> 的接口来实现返回结果<code></code></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span><span class="token string">"1.3"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">val</span> context<span class="token operator">:</span>CoroutineContext    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span>Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span><span class="token string">"1.1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">val</span> context<span class="token operator">:</span>CorouineContext    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>其实就是要给回调，有结果正常返回， <code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常。</p><p>因此，请求的代码执行流程本质上是一个异步回调</p><p>而之所以可以看起来是同步的，那就是编译器的黑魔法了</p><p>在虚拟机上 <code>await</code> 函数的真实样子是这样的</p><pre><code>kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object</code></pre><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 这么一个函数，所以前面的代码可以理解为</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 不是正确代码，仅用来理解协程使用</span>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispathcers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>    githubServiceApi<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">"small"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">showUser</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">showError</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在 <code>await</code> 当中大致就是：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 不是正确代码，仅用来理解协程使用</span><span class="token keyword">fun</span> <span class="token function">awiat</span><span class="token punctuation">(</span>continuation<span class="token operator">:</span>Continuation<span class="token operator">&lt;</span>user<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span>Any<span class="token punctuation">{</span>    <span class="token operator">..</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 切到非 UI 线程中执行，等待结果返回</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token operator">..</span><span class="token operator">..</span><span class="token comment" spellcheck="true">// 这里执行任务</span>        handler<span class="token punctuation">.</span><span class="token function">post</span> <span class="token punctuation">{</span>            continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        handler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">{</span>continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>从运行机制上来讲，协程和回调没有本质的区别</p></blockquote><h3 id="suspend-方式"><a href="#suspend-方式" class="headerlink" title="suspend  方式"></a>suspend  方式</h3><p><code>suspend</code> 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用</p><blockquote><p>Retrofit 在 release 2.5.0 之后才会支持 suspend 函数</p></blockquote><p>首先修改一下接口方法</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@GET</span><span class="token punctuation">(</span><span class="token string">"users/{login}"</span><span class="token punctuation">)</span>suspend <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation builtin">@Path</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span>login<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">:</span> User</code></pre><p>这种情况下， <code>Retrofit</code> 会根据接口方法的生命来构造<code>Continuation</code> ，并且在内部封装了一个 <code>Call</code> 的异步请求(使用 <code>enqueue</code>) ，进而得到 User 实例。</p><pre class=" language-kotlin"><code class="language-kotlin">GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">showUser</span><span class="token punctuation">(</span>githubServiceApi<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">"small"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">showError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="协程到底是什么"><a href="#协程到底是什么" class="headerlink" title="协程到底是什么"></a>协程到底是什么</h2><p>以前我们使用 Java 进行开发的时候，经常会遇到 <em>回调地域</em> ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。</p><p>而 <strong>协程</strong> 可以帮我们优雅的处理掉这些</p><p>协程本身是一个脱离语言实现的概念。简单来说就是：</p><p>协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> Job<span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span><span class="token function">Element</span> <span class="token punctuation">{</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">val</span> isActive<span class="token operator">:</span> Boolean    <span class="token keyword">public</span> <span class="token keyword">val</span> isCompleted<span class="token operator">:</span> Boolean    <span class="token keyword">public</span> <span class="token keyword">val</span> isCancelled<span class="token operator">:</span> Boolean    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>Boolean    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">cancel</span><span class="token punctuation">(</span>cause<span class="token operator">:</span> CancellationException<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> suspend <span class="token keyword">fun</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>我们看一下 <strong>Thread</strong> 的定义</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Deprecated</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。&lt;/li&gt;
&lt;li&gt;线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着&lt;/li&gt;
&lt;li&gt;协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。&lt;/li&gt;
&lt;li&gt;协程的三要素：上下文、启动模式、协程体&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多个协程可以共用一个线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程的本质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协程的挂起函数本质上就是一个回调，回调类型就是&lt;code&gt;Continuation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;协程体的执行就是一个&lt;em&gt;状态机&lt;/em&gt;，每一次遇到挂起函数，都是一次状态转移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android Lifecycle</title>
    <link href="http://xiaoman.ren/2021/01/29/Jetpack/Lifecycle%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2021/01/29/Jetpack/Lifecycle 源码分析/</id>
    <published>2021-01-29T15:54:28.314Z</published>
    <updated>2021-01-29T16:04:30.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始是废话（翻译自源码）"><a href="#开始是废话（翻译自源码）" class="headerlink" title="开始是废话（翻译自源码）"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。<br><a id="more"></a></p><pre class=" language-Java"><code class="language-Java">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY</code></pre><p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TestObserver</span> <span class="token keyword">implements</span> <span class="token class-name">DefaultLifecycleObserver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>LifecycleOwner owner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// your code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TestObserver</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleObserver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@OnLifecycleEvent</span><span class="token punctuation">(</span>ON_STOP<span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">onStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TestObserver</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleObserver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@OnLifecycleEvent</span><span class="token punctuation">(</span>ON_CREATE<span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">onCreated</span><span class="token punctuation">(</span>LifecycleOwner source<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@OnLifecycleEvent</span><span class="token punctuation">(</span>ON_ANY<span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">onAny</span><span class="token punctuation">(</span>LifecycleOwner source<span class="token punctuation">,</span> Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p><h2 id="那我能做什么呢"><a href="#那我能做什么呢" class="headerlink" title="那我能做什么呢"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p><p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p><p>干货~~~来了</p><p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p><p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Lifecycle-UML"><a href="#Lifecycle-UML" class="headerlink" title="Lifecycle UML"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true" alt="Lifecycle UML"></p><p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p><p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p><h3 id="ComponentActivity-amp-ReportFragment"><a href="#ComponentActivity-amp-ReportFragment" class="headerlink" title="ComponentActivity &amp; ReportFragment"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去</span><span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleRegistry mLifecycleRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// LifecycleOwner 接口，提供了一个 getLifecycle() 方法</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> mLifecycleRegistry<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ComponentActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lifecycle lifecycle <span class="token operator">=</span> <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//noinspection ConstantConditions</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycle <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"getLifecycle() returned null in ComponentActivity's "</span>                                        <span class="token operator">+</span> <span class="token string">"constructor. Please make sure you are lazily constructing your Lifecycle "</span>                                        <span class="token operator">+</span> <span class="token string">"in the first call to getLifecycle() rather than relying on field "</span>                                        <span class="token operator">+</span> <span class="token string">"initialization."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">>=</span> <span class="token number">19</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LifecycleEventObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span>                                       <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_STOP<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Window window <span class="token operator">=</span> <span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> View decor <span class="token operator">=</span> window <span class="token operator">!=</span> null <span class="token operator">?</span> window<span class="token punctuation">.</span><span class="token function">peekDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>decor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        decor<span class="token punctuation">.</span><span class="token function">cancelPendingInputEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LifecycleEventObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span>                                   <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_DESTROY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isChangingConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">getViewModelStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">19</span> <span class="token operator">&lt;=</span> SDK_INT <span class="token operator">&amp;&amp;</span> SDK_INT <span class="token operator">&lt;=</span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImmLeaksCleaner</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p><p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * {@inheritDoc}     *     * If your ComponentActivity is annotated with {@link ContentView}, this will     * call {@link #setContentView(int)} for you.     */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    mSavedStateRegistryController<span class="token punctuation">.</span><span class="token function">performRestore</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    ReportFragment<span class="token punctuation">.</span><span class="token function">injectIfNeededIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mContentLayoutId <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>mContentLayoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p><p>别慌，进去看。</p><h4 id="ReportFragment"><a href="#ReportFragment" class="headerlink" title="ReportFragment"></a><code>ReportFragment</code></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">injectIfNeededIn</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span>    <span class="token comment" spellcheck="true">// FragmentActivity from support lib, so we use framework fragments for activities</span>    android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>FragmentManager manager <span class="token operator">=</span> activity<span class="token punctuation">.</span><span class="token function">getFragmentManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>manager<span class="token punctuation">.</span><span class="token function">findFragmentByTag</span><span class="token punctuation">(</span>REPORT_FRAGMENT_TAG<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        manager<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReportFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> REPORT_FRAGMENT_TAG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Hopefully, we are the first to make a transaction.</span>        manager<span class="token punctuation">.</span><span class="token function">executePendingTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p><p>按照 <code>Fragment</code> 的生命周期，我们继续看</p><h5 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a><code>dispatch()</code></h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityCreated</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onActivityCreated</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatchCreate</span><span class="token punctuation">(</span>mProcessListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatchStart</span><span class="token punctuation">(</span>mProcessListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatchResume</span><span class="token punctuation">(</span>mProcessListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_RESUME<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_PAUSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// just want to be sure that we won't leak reference to an activity</span>    mProcessListener <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p><h5 id="handleLifecycleEvent"><a href="#handleLifecycleEvent" class="headerlink" title="handleLifecycleEvent()"></a><code>handleLifecycleEvent()</code></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Activity activity <span class="token operator">=</span> <span class="token function">getActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>activity <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleRegistryOwner</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleRegistryOwner<span class="token punctuation">)</span> activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>activity <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleOwner</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Lifecycle lifecycle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleOwner<span class="token punctuation">)</span> activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycle <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleRegistry<span class="token punctuation">)</span> lifecycle<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p><p>你跑，那我就追！</p><h3 id="LifecycleRegister"><a href="#LifecycleRegister" class="headerlink" title="LifecycleRegister"></a><strong><code>LifecycleRegister</code></strong></h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Sets the current state and notifies the observers.     * &lt;p>     * Note that if the {@code currentState} is the same state as the last call to this method,     * calling this method has no effect.     *     * @param event The event that was received     */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    State next <span class="token operator">=</span> <span class="token function">getStateAfter</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">moveToState</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToState</span><span class="token punctuation">(</span>State next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mState <span class="token operator">==</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mState <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mHandlingEvent <span class="token operator">||</span> mAddingObserverCounter <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// we will figure out what to do on upper level.</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mHandlingEvent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mHandlingEvent <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两个方法，我们翻译下注释</p><blockquote><p>设置当前状态，并通知观察者</p><p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p></blockquote><h4 id="getStateAfter"><a href="#getStateAfter" class="headerlink" title="getStateAfter()"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> State <span class="token function">getStateAfter</span><span class="token punctuation">(</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> ON_CREATE<span class="token operator">:</span>        <span class="token keyword">case</span> ON_STOP<span class="token operator">:</span>            <span class="token keyword">return</span> CREATED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_START<span class="token operator">:</span>        <span class="token keyword">case</span> ON_PAUSE<span class="token operator">:</span>            <span class="token keyword">return</span> STARTED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_RESUME<span class="token operator">:</span>            <span class="token keyword">return</span> RESUMED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_DESTROY<span class="token operator">:</span>            <span class="token keyword">return</span> DESTROYED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_ANY<span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unexpected event value "</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p><p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>mState <span class="token operator">==</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync()"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Custom list that keeps observers and can handle removals / additions during traversal.     *     * Invariant: at any moment of time for observer1 &amp; observer2:     * if addition_order(observer1) &lt; addition_order(observer2), then     * state(observer1) >= state(observer2),     */</span><span class="token keyword">private</span> FastSafeIterableMap<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> mObserverMap <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">FastSafeIterableMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// happens only on the top of stack (never in reentrance),</span><span class="token comment" spellcheck="true">// so it doesn't have to take in account parents</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LifecycleOwner lifecycleOwner <span class="token operator">=</span> mLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycleOwner <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"LifecycleOwner of this LifecycleRegistry is already"</span>                                        <span class="token operator">+</span> <span class="token string">"garbage collected. It is too late to change lifecycle state."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSynced</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// no need to check eldest for nullability, because isSynced does it for us.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mObserverMap<span class="token punctuation">.</span><span class="token function">eldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">backwardPass</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> newest <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">newest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mNewEventOccurred <span class="token operator">&amp;&amp;</span> newest <span class="token operator">!=</span> null            <span class="token operator">&amp;&amp;</span> mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>newest<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">forwardPass</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p><p>继续分析源码</p><p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p><p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p><h4 id="Lifecycle-State-Sequence"><a href="#Lifecycle-State-Sequence" class="headerlink" title="Lifecycle State Sequence"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> Event <span class="token function">downEvent</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> INITIALIZED<span class="token operator">:</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CREATED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_DESTROY<span class="token punctuation">;</span>            <span class="token keyword">case</span> STARTED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_STOP<span class="token punctuation">;</span>            <span class="token keyword">case</span> RESUMED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_PAUSE<span class="token punctuation">;</span>            <span class="token keyword">case</span> DESTROYED<span class="token operator">:</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unexpected state value "</span> <span class="token operator">+</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Event <span class="token function">upEvent</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> INITIALIZED<span class="token operator">:</span>            <span class="token keyword">case</span> DESTROYED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_CREATE<span class="token punctuation">;</span>            <span class="token keyword">case</span> CREATED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_START<span class="token punctuation">;</span>            <span class="token keyword">case</span> STARTED<span class="token operator">:</span>                <span class="token keyword">return</span> ON_RESUME<span class="token punctuation">;</span>            <span class="token keyword">case</span> RESUMED<span class="token operator">:</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unexpected state value "</span> <span class="token operator">+</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true" alt="Lifecycle State Sequence"></p><p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p><h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a><code>dispatchEvent</code></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">forwardPass</span><span class="token punctuation">(</span>LifecycleOwner lifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Iterator<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">>></span> ascendingIterator <span class="token operator">=</span>        mObserverMap<span class="token punctuation">.</span><span class="token function">iteratorWithAdditions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ascendingIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> entry <span class="token operator">=</span> ascendingIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObserverWithState observer <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred                <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pushParentState</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            observer<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> <span class="token function">upEvent</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backwardPass</span><span class="token punctuation">(</span>LifecycleOwner lifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Iterator<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">>></span> descendingIterator <span class="token operator">=</span>        mObserverMap<span class="token punctuation">.</span><span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>descendingIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> entry <span class="token operator">=</span> descendingIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObserverWithState observer <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mState<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred                <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Event event <span class="token operator">=</span> <span class="token function">downEvent</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">pushParentState</span><span class="token punctuation">(</span><span class="token function">getStateAfter</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            observer<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>LifecycleOwner owner<span class="token punctuation">,</span> Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    State newState <span class="token operator">=</span> <span class="token function">getStateAfter</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    mState <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>mState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span>    mLifecycleObserver<span class="token punctuation">.</span><span class="token function">onStateChanged</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    mState <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p><p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p><h4 id="ReflectiveGenericLifecycleObserver"><a href="#ReflectiveGenericLifecycleObserver" class="headerlink" title="ReflectiveGenericLifecycleObserver"></a><code>ReflectiveGenericLifecycleObserver</code></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * An internal implementation of {@link LifecycleObserver} that relies on reflection. */</span><span class="token keyword">class</span> <span class="token class-name">ReflectiveGenericLifecycleObserver</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleEventObserver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Object mWrapped<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> CallbackInfo mInfo<span class="token punctuation">;</span>    <span class="token function">ReflectiveGenericLifecycleObserver</span><span class="token punctuation">(</span>Object wrapped<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mWrapped <span class="token operator">=</span> wrapped<span class="token punctuation">;</span>        mInfo <span class="token operator">=</span> ClassesInfoCache<span class="token punctuation">.</span>sInstance<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span>mWrapped<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span>LifecycleOwner source<span class="token punctuation">,</span> Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mInfo<span class="token punctuation">.</span><span class="token function">invokeCallbacks</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">,</span> mWrapped<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p><p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p><p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p><p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p><p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p><h4 id="reflect-invoke-method"><a href="#reflect-invoke-method" class="headerlink" title="reflect invoke method"></a><code>reflect invoke method</code></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">invokeCallback</span><span class="token punctuation">(</span>LifecycleOwner source<span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">,</span> Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//noinspection TryWithIdenticalCatches</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>mCallType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> CALL_TYPE_NO_ARG<span class="token operator">:</span>                mMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CALL_TYPE_PROVIDER<span class="token operator">:</span>                mMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT<span class="token operator">:</span>                mMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Failed to call observer method"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p><p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p><p>但是！！！！！！！！！！！！！！！！</p><p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p><h4 id="addObserver"><a href="#addObserver" class="headerlink" title="addObserver()"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p><p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleObserver observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    State initialState <span class="token operator">=</span> mState <span class="token operator">==</span> DESTROYED <span class="token operator">?</span> DESTROYED <span class="token operator">:</span> INITIALIZED<span class="token punctuation">;</span>    ObserverWithState statefulObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObserverWithState</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>    ObserverWithState previous <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> statefulObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>previous <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LifecycleOwner lifecycleOwner <span class="token operator">=</span> mLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycleOwner <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// it is null we should be destroyed. Fallback quickly</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> isReentrance <span class="token operator">=</span> mAddingObserverCounter <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> mHandlingEvent<span class="token punctuation">;</span>    State targetState <span class="token operator">=</span> <span class="token function">calculateTargetState</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    mAddingObserverCounter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>targetState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span>            <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pushParentState</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>        statefulObserver<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> <span class="token function">upEvent</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// mState / subling may have been changed recalculate</span>        targetState <span class="token operator">=</span> <span class="token function">calculateTargetState</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReentrance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// we do sync only on the top level.</span>        <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mAddingObserverCounter<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p><p>我们这里要逐行清点</p><p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p><p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p><p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p><p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p><p>总结一下，分析源码我们从两方面入手</p><ol><li><p><code>addObserver()</code></p><p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p><ol><li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li><li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li><li>立即进行状态判断，决定是否处理生命周期变化</li></ol></li><li><p><code>ReportFragment</code></p><p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p></li><li><p><strong>反射</strong></p><p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p></li><li><p><code>sync()</code></p><p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;a href=&quot;#开始是废话（翻译自源码）&quot; class=&quot;headerlink&quot; title=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;/a&gt;开始是废话（翻译自源码）&lt;/h2&gt;&lt;p&gt;定义了一个 Android 生命周期的对象。 &lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;FragmentActivity&lt;/code&gt;类实现&lt;code&gt;LifecycleOwner&lt;/code&gt;接口， 并可以通过 &lt;code&gt;getLifecycle()&lt;/code&gt; 方法来访问生命周期。 我们也可以实现&lt;code&gt;LifecycleOwner&lt;/code&gt;在自己的类。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 架构组件</title>
    <link href="http://xiaoman.ren/2021/01/29/Jetpack/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6/"/>
    <id>http://xiaoman.ren/2021/01/29/Jetpack/Android架构组件/</id>
    <published>2021-01-29T15:54:28.313Z</published>
    <updated>2021-01-29T16:04:41.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用架构指南"><a href="#应用架构指南" class="headerlink" title="应用架构指南"></a>应用架构指南</h2><ul><li>当您在自己喜欢的社交网络应用中分享照片时会发生什么：<ol><li>该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的</li><li>相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用</li><li>最后，用户返回社交网络应用并分享照片<a id="more"></a>此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。</li></ol></li></ul><p>移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间</p><p>因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖</p><h2 id="常见架构原则"><a href="#常见架构原则" class="headerlink" title="常见架构原则"></a>常见架构原则</h2><h3 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h3><p>常见错误是再 <code>activity</code> 和 <code>fragment</code> 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题</p><h3 id="通过模型驱动界面"><a href="#通过模型驱动界面" class="headerlink" title="通过模型驱动界面"></a>通过模型驱动界面</h3><p>通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。</p><p>持久性是思想之选，原因如下:</p><pre><code>1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据2. 当网络连接不稳定或不可用时，应用会继续工作</code></pre><p>应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。</p><h2 id="推荐应用架构"><a href="#推荐应用架构" class="headerlink" title="推荐应用架构"></a>推荐应用架构</h2><p><img src="https://developer.android.com/topic/libraries/architecture/images/final-architecture.png" alt="img"></p><p>每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。</p><p>这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。</p><h2 id="构建界面"><a href="#构建界面" class="headerlink" title="构建界面"></a>构建界面</h2><p>界面由Fragment <code>UserProfileFragment</code> 及其对应的布局文件 <code>user_profile_layout.xml</code> 组成</p><p>如需驱动该界面，数据模型需要存储以下数据元素</p><ul><li>用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。</li><li>用户对象：用于存储用户详细信息的数据类</li></ul><blockquote><p>ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响</p></blockquote><ul><li><code>user_profile.xml</code> : 屏幕的界面布局</li><li><code>UserProfileFragment</code>：显示数据的界面控制器</li><li><code>UserProfileViewModel</code> : 准备数据以便再 <code>UserProfileFragment</code> 中查看并对用户互动做出响应的类</li></ul><p><strong>UserProfileViewModel</strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> UserProfileViewModel<span class="token operator">:</span> <span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">val</span> userId<span class="token operator">:</span>String <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> user<span class="token operator">:</span> User <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>UserProfileFragment</strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> UserProfileFragment<span class="token operator">:</span> <span class="token function">Fragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用 ViewModels() 拓展函数，以及 "androidx.fragment:fragment-ktx:lastest-version" 在 模块下的 build.gradle </span>    <span class="token keyword">private</span> <span class="token keyword">val</span> viewModel<span class="token operator">:</span> UserProfileViewModel <span class="token keyword">by</span> <span class="token function">viewModels</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreateView</span><span class="token punctuation">(</span>    inflater<span class="token operator">:</span> LayoutInflater<span class="token punctuation">,</span>    container<span class="token operator">:</span> ViewGroup<span class="token operator">?</span><span class="token punctuation">,</span>    savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> View <span class="token punctuation">{</span>        <span class="token keyword">return</span> inflater<span class="token punctuation">.</span><span class="token function">infalte</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>main_fragment<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在，由了这些代码块，需要将他们串联起来，毕竟在 <code>UserProfileViewModel</code> 类中设置 <code>user</code> 字段时，我们需要一种方法来通知界面</p><p>要获取 <code>user</code> 我们的 <code>ViewModel</code> 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 <code>SaveState</code> 模块，我们可以让 View Model 直接读取参数</p><blockquote><p>SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数</p></blockquote><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// UserProfileViewModel</span><span class="token keyword">class</span> <span class="token function">UserProfileViewModel</span> <span class="token punctuation">(</span>savedStatedHandle<span class="token operator">:</span> SavedStateHandle<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">val</span> userId<span class="token operator">:</span>String <span class="token operator">=</span> savedStateHandle<span class="token punctuation">[</span><span class="token string">"uid"</span><span class="token punctuation">]</span> <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"missing user id"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> user<span class="token operator">:</span> User <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// UserProfileFragment</span><span class="token keyword">private</span> <span class="token keyword">val</span> viewModel<span class="token operator">:</span> UserProfileViewModel <span class="token keyword">by</span> <span class="token function">viewModels</span><span class="token punctuation">(</span>    factoryProducer <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token function">SavedStateVMFactory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用架构指南&quot;&gt;&lt;a href=&quot;#应用架构指南&quot; class=&quot;headerlink&quot; title=&quot;应用架构指南&quot;&gt;&lt;/a&gt;应用架构指南&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当您在自己喜欢的社交网络应用中分享照片时会发生什么：&lt;ol&gt;
&lt;li&gt;该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的&lt;/li&gt;
&lt;li&gt;相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用&lt;/li&gt;
&lt;li&gt;最后，用户返回社交网络应用并分享照片
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Data Binding</title>
    <link href="http://xiaoman.ren/2021/01/29/Jetpack/Data%20Binding/"/>
    <id>http://xiaoman.ren/2021/01/29/Jetpack/Data Binding/</id>
    <published>2021-01-29T15:54:28.313Z</published>
    <updated>2021-01-29T16:04:38.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="布局和绑定表达式"><a href="#布局和绑定表达式" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。<br><a id="more"></a><br>该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 <code>data</code> 元素（界面布局根元素的同级）内定义。这两个元素都封装在 <code>layout</code> 标记中。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://scheams.android.com/apk/res-auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span>                  <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewModel<span class="token punctuation">"</span></span>                  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.myapp.data.ViewModel<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>variable</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ConstraintLayout</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- UI layout`s root element--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ConstraintLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span></code></pre><h3 id="使用可观察的数据对象"><a href="#使用可观察的数据对象" class="headerlink" title="使用可观察的数据对象"></a>使用可观察的数据对象</h3><p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。</p><h3 id="生成的绑定类"><a href="#生成的绑定类" class="headerlink" title="生成的绑定类"></a>生成的绑定类</h3><p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p><h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><p>每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 <code>setText()</code> 方法来设置文本属性，或者调用 <code>setOnClickListener()</code> 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 <code>android:text</code> 属性）可供您在 <code>android.databinding.adapters</code> 软件包中使用。也可以自定义适配器</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@BindingAdapter</span><span class="token punctuation">(</span><span class="token string">"app:goneUnless"</span><span class="token punctuation">)</span> <span class="token keyword">fun</span> <span class="token function">goneUnless</span><span class="token punctuation">(</span>view<span class="token operator">:</span> View<span class="token punctuation">,</span> visiable<span class="token operator">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>    view<span class="token punctuation">.</span>visibility <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>visiable<span class="token punctuation">)</span> View<span class="token punctuation">.</span>VISIABLE <span class="token keyword">else</span> View<span class="token punctuation">.</span>GONE<span class="token punctuation">}</span></code></pre><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新</p><h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>要开始使用数据绑定，从 Android SDK 管理器中的 <strong>支持代码库</strong> 下载。要将应用配置为使用配置绑定，需要在应用模块的 <code>build.gradle</code> 文件中添加 <code>databinding</code> 元素</p><pre class=" language-groovy"><code class="language-groovy">android<span class="token punctuation">{</span>    <span class="token punctuation">...</span>        dataBinding<span class="token punctuation">{</span>            enabled <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定</p></blockquote><h3 id="布局和绑定表达式-1"><a href="#布局和绑定表达式-1" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。</p><p>数据绑定布局文件略有不同，以根标记<code>layout</code> 开头，后跟 <code>data</code> 和 <code>view</code> 根元素。此视图元素是非绑定布局文件的根</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encodeing="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://scheams.android.comapk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span>                  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span> <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                   <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.fiestName}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>warp_content<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.lastName}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span></code></pre><p><code>data</code> 中的 <code>user</code> 变量描述了可在此布局中使用的属性</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>布局中的表达式使用了 <code>@{}</code> 语法写入特性属性中，在这里， <code>TextView</code> 文本被设置为 <code>user.fistName</code> 和 <code>user.lastName</code></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>warp_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.firstName}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>warp_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.lastName}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> firstName<span class="token operator">:</span>String<span class="token punctuation">,</span> <span class="token keyword">val</span> lastName<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 <code>activity_main.xml</code> ,因此生成的对应类为 <code>ActivityMainBinding</code>。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>    <span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding <span class="token operator">=</span> DataBindingUtil<span class="token punctuation">.</span><span class="token function">setContentView</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span>    binding<span class="token punctuation">.</span>user<span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">,</span> <span class="token string">"User"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 <strong>LayoutInflater</strong> 获取视图，</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding<span class="token operator">=</span> ActivityMainBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token function">getLayoutInflater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>如果需要再 <code>Fragment</code> <code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或 <code>DataBindingUtil</code> 类的 <code>inflate()</code> 方法</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> listItemBinding <span class="token operator">=</span> ListItemBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">,</span> viewGroup<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// or</span><span class="token keyword">val</span> listItemBinding <span class="token operator">=</span> DataBindingUtil<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">,</span> R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>list_item<span class="token punctuation">,</span> viewGroup<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></code></pre><h3 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h3><table><thead><tr><th>名称</th><th>符号</th></tr></thead><tbody><tr><td>算数运算符</td><td>+, -, /, *, %</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;, \</td><td>\</td><td></td></tr><tr><td>二元运算符</td><td>&amp;, \</td><td>, ^</td></tr><tr><td>一元运算符</td><td>+, -, !, ~</td></tr><tr><td>移位运算符</td><td>&gt;&gt; , &lt;&lt;, &gt;&gt;&gt;</td></tr><tr><td>比较运算符</td><td>==, &gt;, &lt;(需要转义为’&amp;lt ;’), &gt;=, &lt;=</td></tr><tr><td></td><td>instanceof</td></tr><tr><td>分组运算符</td><td>()</td></tr><tr><td>字面运算符</td><td>字符，字符串，数字， null</td></tr><tr><td>类型转换</td><td></td></tr><tr><td>方法调用</td><td></td></tr><tr><td>字段访问</td><td></td></tr><tr><td>数组访问</td><td>[]</td></tr><tr><td>三元运算符</td><td>?:</td></tr></tbody></table><pre class=" language-xml"><code class="language-xml">&lt;TextView          android:text="@{String.valueOf(index+1)}"          android:visibility="@{age > 13 ? View.GONE : View.VISIBLE}"          android:transitionName="@{"image_"+id}"</code></pre><h3 id="Null-合并运算符"><a href="#Null-合并运算符" class="headerlink" title="Null 合并运算符"></a>Null 合并运算符</h3><blockquote><p>如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边</p></blockquote><pre><code>android:text=&quot;@{user.displayName ?? user.lastName}&quot;</code></pre><p>等效于</p><pre><code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;</code></pre><h3 id="视图引用"><a href="#视图引用" class="headerlink" title="视图引用"></a>视图引用</h3><p>表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>          <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/example_text<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>          <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/example_output<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{exampleText.text}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>可以使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、Hash 列表、和映射</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.util.SparseArray<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.util.Map<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.util.List<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>List$lt;String<span class="token punctuation">></span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sparse<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Sparse$lt;String<span class="token punctuation">></span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Map$lt;&lt;String, String<span class="token punctuation">></span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>String<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>​</code></pre><p>android:text=”@{list[index]}”<br>​<code>android:text=&quot;@{sparse[index]}&quot;​</code><br>android:text=”@{map[key]}”</p><pre><code>### 资源表达式可以使用一下语法引用资源</code></pre><p>android:padding=”@{large?@dimen/largePadding : @dimen/smallPadding}”</p><pre><code>某些资源需要显示类型求值| 类型              | 常规引用  | 表达式引用         || ----------------- | --------- | ------------------ || String[]          | @array    | @stringArray       || int[]             | @array    | @intArray          || TypedArray        | @array    | @typedArray        || Animator          | @animator | @animator          || StateListAnimator | @animator | @stateListAnimator || color int         | @color    | @color             || ColorStateList    | @color    | @colorStateList    |### 事件处理可以编写从视图分派的表达式处理事件如：`onClick` #### 方法引用事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。```kotlinclass MyHandler{    fun onClickFriend(view:View){...}}</code></pre><p>绑定白哦大师可见视图的点击监听器分配给 <code>onClickFriend()</code> 方法</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://scheams.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>handlers<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.MyHandler<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>                  <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.firstName}<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>onClick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{handlers::onClickFriend}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span></code></pre><h4 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h4><p>监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。</p><p>在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Presenter <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">onSaveClick</span><span class="token punctuation">(</span>task<span class="token operator">:</span> Task<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>将事件绑定到 <code>onSaveClick()</code> 方法</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://scheams.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.Task<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>presenter<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.Presenter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>                  <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>onClick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{() -<span class="token punctuation">></span> presenter.onSaveClick(task)}<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span></code></pre><p>在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。</p><p><strong>避免使用复杂的监听器</strong> 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。</p><h4 id="导入、变量和-包含"><a href="#导入、变量和-包含" class="headerlink" title="导入、变量和 包含"></a>导入、变量和 包含</h4><p>导入：可以轻松的在布局文件中引用类</p><p>变量：可以描述可在绑定表达式中使用的属性</p><p>包含：可以在整个应用中重复使用复杂的布局</p><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>在 <code>data</code> 元素中使用多个 <code>import</code> 元素，也可以不用。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.view.View<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span></code></pre><p>导入 View 类可以通过绑定表达式引用该类</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>          <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.name}<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>visibility</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user.isAdult ? View.VISIBLE : View.GONE}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextView</span><span class="token punctuation">></span></span></code></pre><p><em>类型别名</em></p><p>当类名有冲突时，其中一个类可使用别名重命名。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.view.View<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.real.estate.View<span class="token punctuation">"</span></span>        <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Visia<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p><code>variable</code>  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.graphics.drawable.Drawable<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Drawable<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>note<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>String<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span></code></pre><p>变量类型在编译时进行检查，因此如果实现了  <code>Observable</code> 或者时 <strong>可观察集合</strong>，则因反应在类型中。</p><p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。</p><h5 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h5><p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">xmlns:</span>bind</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>variable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>           <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@layout/name<span class="token punctuation">"</span></span>               <span class="token attr-name"><span class="token namespace">bind:</span>user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@layout/contact<span class="token punctuation">"</span></span>               <span class="token attr-name"><span class="token namespace">bind:</span>user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{user}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Data-Binding&quot;&gt;&lt;a href=&quot;#Data-Binding&quot; class=&quot;headerlink&quot; title=&quot;Data Binding&quot;&gt;&lt;/a&gt;Data Binding&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;布局和绑定表达式&quot;&gt;&lt;a href=&quot;#布局和绑定表达式&quot; class=&quot;headerlink&quot; title=&quot;布局和绑定表达式&quot;&gt;&lt;/a&gt;布局和绑定表达式&lt;/h3&gt;&lt;p&gt;借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="http://xiaoman.ren/2021/01/29/Java/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://xiaoman.ren/2021/01/29/Java/阻塞队列/</id>
    <published>2021-01-29T15:54:28.312Z</published>
    <updated>2021-01-29T16:03:53.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p><code>BlockingQueue</code> 是一个支持两个附加操作的队列。</p><p>在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br><a id="more"></a><br>阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。</p><p>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p><ul><li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue: 一个使用优先级排序的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</li></ul><h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p>使用<strong>通知模式</strong>实现</p><p>所谓 <strong>通知模式</strong> 就是当生产者往<strong><code>满的队列</code></strong>里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p><strong>ArrayBlockingQueue：</strong></p><pre class=" language-Java"><code class="language-Java">private final Condition notFull;private final Condition notEmpty;public ArrayBlockingQueue(int capacity, boolean fair) {    if (capacity <= 0){        throw new IllegalArgumentException();            }    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull = lock.newCondition();}public void put(E e) throws InterruptedException {    checkNotNull(e);    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while(count == items.length) {            notFull.await();            insert(e);        } finally {            lock.unlock();        }    }}public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0) {            notEmpty = await();        }        return extract();    } finally {        lock.unlock();    }}private void insert(E x) {    items[putIndex] = x;    putIndex = inc(putIndex);    ++count;    // 唤醒一个等待线程    notEmpty.signal();} </code></pre><p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 <code>LockSupport.park(this)</code>  来实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaitting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是阻塞队列&quot;&gt;&lt;a href=&quot;#什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;什么是阻塞队列&quot;&gt;&lt;/a&gt;什么是阻塞队列&lt;/h2&gt;&lt;p&gt;&lt;code&gt;BlockingQueue&lt;/code&gt; 是一个支持两个附加操作的队列。&lt;/p&gt;
&lt;p&gt;在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android Room</title>
    <link href="http://xiaoman.ren/2021/01/29/Jetpack/Android%20Room/"/>
    <id>http://xiaoman.ren/2021/01/29/Jetpack/Android Room/</id>
    <published>2021-01-29T15:54:28.312Z</published>
    <updated>2021-01-29T16:04:45.937Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==" title="https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn">翻译自官网文档<i class="fa fa-external-link"></i></span></p><p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库</p><ul><li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li><li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li><li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li></ul><a id="more"></a><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// File: User.java</span><span class="token annotation punctuation">@Entity</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@PrimaryKey</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ColumnInfo</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"last_name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Room 请求 set 和 get 方法去访问数据</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// File: UserDao.java</span><span class="token annotation punctuation">@Dao</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"select * from user"</span><span class="token punctuation">)</span>     List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">loadAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"select * from user where uid in (:userIds)"</span><span class="token punctuation">)</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">loadAllByUserId</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> userIds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"select * from user where name like :first and last_name like :last limit 1"</span><span class="token punctuation">)</span>    User <span class="token function">loadOneByNameAndLastName</span><span class="token punctuation">(</span>String first<span class="token punctuation">,</span> String last<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Insert</span>    <span class="token keyword">void</span> <span class="token function">insertAll</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Delete</span>    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// File: AppDatabse.java</span><span class="token annotation punctuation">@Database</span><span class="token punctuation">(</span>entities <span class="token operator">=</span> <span class="token punctuation">{</span>User<span class="token punctuation">.</span>java<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AppDatabase</span> <span class="token keyword">extends</span> <span class="token class-name">RoomDatabase</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> UserDao <span class="token function">userDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建 AppDatabase 实例</span>AppDatabse db <span class="token operator">=</span> Room<span class="token punctuation">.</span><span class="token function">databaseBuilder</span><span class="token punctuation">(</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> AppDatabase<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"database_name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p><p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p><p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// LiveData 会自动分发数据表的改变</span><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"Select * from user order by name limit 5"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> LiveData<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> <span class="token function">loadFirstFiveUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==&quot; title=&quot;https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn&quot;&gt;翻译自官网文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Database:&lt;/strong&gt; 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entity:&lt;/strong&gt; 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dao:&lt;/strong&gt; 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xiaoman.ren/2021/01/29/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Object%20%E7%B1%BB/"/>
    <id>http://xiaoman.ren/2021/01/29/Java/基础知识/Object 类/</id>
    <published>2021-01-29T15:54:28.311Z</published>
    <updated>2021-01-29T16:17:04.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><ul><li><p>Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法</p></li><li><p>可以使用 Object 类型的变量指向任意类型的 super 类</p></li><li>Object 类有一个默认构造方法 <code>public Object()</code> ，在构造子类实例时，都会先调用这个默认构造方法</li><li><p>Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换</p><a id="more"></a><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2></li><li><p>Object () ： 默认构造方法</p></li><li>clone() : 创建并返回此对象得一个副本</li><li>equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）</li><li>finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法</li><li>getClass(): 返回一个对象得运行时类</li><li>hashCode(): 返回该对象得 哈希值</li><li>notify(): 唤醒在此对象监视器上等待得单个线程</li><li>notifyAll() : 唤醒在此对象监视器上等待得所有线程</li><li>toString(): 返回该对象得字符串标识</li><li>wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法</li><li>wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量</li><li>wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object-类&quot;&gt;&lt;a href=&quot;#Object-类&quot; class=&quot;headerlink&quot; title=&quot;Object 类&quot;&gt;&lt;/a&gt;Object 类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 Object 类型的变量指向任意类型的 super 类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Object 类有一个默认构造方法 &lt;code&gt;public Object()&lt;/code&gt; ，在构造子类实例时，都会先调用这个默认构造方法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://xiaoman.ren/2021/01/29/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E2%80%98/"/>
    <id>http://xiaoman.ren/2021/01/29/Java/设计模式/代理模式‘/</id>
    <published>2021-01-29T15:54:28.311Z</published>
    <updated>2021-01-29T16:16:44.804Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>目的</strong>：</p><ol><li>通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向</li><li>通过代理对象对原有业务的增强。</li></ol><p>代理模式一般会有三个角色：</p><p><strong>抽象角色：</strong> 指代理角色和真是角色对外提供的公共方法，一般为一个接口</p><p><strong>真实角色：</strong> 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者<br><a id="more"></a><br><strong>代理角色：</strong> 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。</p><p>静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。</p><p>静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是指在使用时再创建代理类和实例</p><p><strong>有点：</strong></p><p>只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活</p><p><strong>缺点：</strong></p><p>效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。</p><p>应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。</p><h2 id="动态代理的实现原理"><a href="#动态代理的实现原理" class="headerlink" title="动态代理的实现原理"></a>动态代理的实现原理</h2><p><code>InvocationHandler</code> 和 <code>Proxy</code> 一个接口，一个类，再动态代理中时一定会用到的</p><p><code>InvocationHandler</code> 接口是给动态代理类实现的，负责处理被代理对象的操作</p><p><code>Proxy</code> 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法</p><pre class=" language-java"><code class="language-java">Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span>getClassLoader<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。&lt;/p&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;&lt;a href=&quot;#静态代理&quot; class=&quot;headerlink&quot; title=&quot;静态代理&quot;&gt;&lt;/a&gt;静态代理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向&lt;/li&gt;
&lt;li&gt;通过代理对象对原有业务的增强。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代理模式一般会有三个角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象角色：&lt;/strong&gt; 指代理角色和真是角色对外提供的公共方法，一般为一个接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真实角色：&lt;/strong&gt; 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaoman.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
