<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶白白在胡说</title>
  <icon>https://www.gravatar.com/avatar/f27b936c2ac428d82177b6d3626c8e3a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaoman.ren/"/>
  <updated>2021-02-02T15:02:56.996Z</updated>
  <id>http://xiaoman.ren/</id>
  
  <author>
    <name>茶白</name>
    <email>zhuangbudong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 中文件 Copy 的方式</title>
    <link href="http://xiaoman.ren/2021/02/02/Java/Java%20%E4%B8%AD%E6%96%87%E4%BB%B6%20Copy%20%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://xiaoman.ren/2021/02/02/Java/Java 中文件 Copy 的几种方式/</id>
    <published>2021-02-02T14:49:46.727Z</published>
    <updated>2021-02-02T15:02:56.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-中文件-Copy-的几种方式"><a href="#Java-中文件-Copy-的几种方式" class="headerlink" title="Java 中文件 Copy 的几种方式"></a>Java 中文件 Copy 的几种方式</h1><h2 id="Java-io"><a href="#Java-io" class="headerlink" title="Java.io"></a>Java.io</h2><p>利用 <code>java.io</code> 类库。直接为源文件创建一个 <code>FileInputStream</code> 负责读取，然后再为目标文件创建一个 <code>FileOutputStream</code> 负责写入:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span><span class="params">(File source, File target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">        os = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">while</span>((length = is.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-nio"><a href="#Java-nio" class="headerlink" title="Java.nio"></a>Java.nio</h2><p>利用 <code>java.nio</code> 类库提供的 transferTo 或 transferFrom  方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source, File target)</span> throw IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileChannel sc = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">       FileChannel tc = <span class="keyword">new</span> FileOutputStream(target).getChannel();) &#123;</span><br><span class="line">        <span class="keyword">long</span> count = sc.size();</span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> transferred = sc.transferTo(sc.position(), count, tc);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-nio-file-File-copy"><a href="#Java-nio-file-File-copy" class="headerlink" title="Java.nio.file.File.copy"></a>Java.nio.file.File.copy</h2><p>关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio  transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-中文件-Copy-的几种方式&quot;&gt;&lt;a href=&quot;#Java-中文件-Copy-的几种方式&quot; class=&quot;headerlink&quot; title=&quot;Java 中文件 Copy 的几种方式&quot;&gt;&lt;/a&gt;Java 中文件 Copy 的几种方式&lt;/h1&gt;&lt;h2 id=&quot;Java-io&quot;&gt;&lt;a href=&quot;#Java-io&quot; class=&quot;headerlink&quot; title=&quot;Java.io&quot;&gt;&lt;/a&gt;Java.io&lt;/h2&gt;&lt;p&gt;利用 &lt;code&gt;java.io&lt;/code&gt; 类库。直接为源文件创建一个 &lt;code&gt;FileInputStream&lt;/code&gt; 负责读取，然后再为目标文件创建一个 &lt;code&gt;FileOutputStream&lt;/code&gt; 负责写入:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 中堆和栈的区别</title>
    <link href="http://xiaoman.ren/2021/02/02/Java/Java%20%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xiaoman.ren/2021/02/02/Java/Java 中堆和栈的区别/</id>
    <published>2021-02-02T14:49:46.726Z</published>
    <updated>2021-02-02T15:02:40.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Java 中堆和栈的区别具体由一下几点</p><h3 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h3><p><strong>栈：</strong> 用来存储局部变量和方法调用</p><p><strong>堆： </strong> 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。</p><a id="more"></a><h3 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h3><p><strong>栈：</strong> 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存</p><p><strong>堆： </strong> 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。</p><h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><p>如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 <code>java.lang.StackOverFlowError</code> </p><p>如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 <code>Java.lang.OutOfMemoryError</code></p><h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 <code>StackOverFlowError</code> 问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;Java 中堆和栈的区别具体由一下几点&lt;/p&gt;
&lt;h3 id=&quot;各司其职&quot;&gt;&lt;a href=&quot;#各司其职&quot; class=&quot;headerlink&quot; title=&quot;各司其职&quot;&gt;&lt;/a&gt;各司其职&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈：&lt;/strong&gt; 用来存储局部变量和方法调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆： &lt;/strong&gt; 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 磁盘空间优化</title>
    <link href="http://xiaoman.ren/2021/02/02/Android%20%E5%9F%BA%E7%A1%80/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/"/>
    <id>http://xiaoman.ren/2021/02/02/Android 基础/性能优化/磁盘空间优化/</id>
    <published>2021-02-01T16:37:29.167Z</published>
    <updated>2021-02-02T14:59:18.714Z</updated>
    
    <content type="html"><![CDATA[<p>资源类性能就像是撑起冰山一角的下面的冰层，我们称之为 <code>3 + 1 + 1</code> 。 <code>3 + 1</code>  时传统的 -磁盘、cpu 和 内存，加 1 是与环境密切相关的网络；最后一个加 1 则是因为移动网络而显得特别重要的电池（耗电）。</p><p>因为冰山一角体现出来的交互类性能，包括流畅度、时延等，实际上都是资源问题。例如流畅度问题，可以是内存的垃圾回收太频繁导致的，因为有些 GC 会 STOP THE WORLD, 又可以是 CPU 问题， decode 图片开了过多的子线程，导致主线程的 CPU  资源被争抢；更可以是再主线程中读/写磁盘，磁盘读/写耗时抖一抖、页面也就跟着卡一下。所以关注资源类性能，其实是关注问题的本质去解决问题的方式。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>再没有SSD 磁盘前，大家都觉着 HDD 很好用。对于外行来说，磁盘 I/0 性能总是最容易被忽略的，经理会更集中再 CPU 上。但内行人都知道，性能无非是 CPU 密集型和 I/O 密集型，磁盘 I/O 就是其中之一。</p><p>在设备长时间使用，磁盘空间不足。应用触发大量随机写操作，都会导致磁盘的负载，磁盘 I/O 的耗时会产生剧烈的波动， App 能做的只有一件事儿，即减少磁盘 I/O d 操作量，特别是主线程的操作量。</p><a id="more"></a><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>那么我们要如何发现、定位、解决这些磁盘 I/O 的性能问题呢？</p><table><thead><tr><th>工具</th><th>问题</th><th>能力</th></tr></thead><tbody><tr><td>Systrace/Strace</td><td>主线程I/O，I/O操作耗时过长</td><td>发现</td></tr><tr><td>STRICTMODE</td><td>主线程I/O</td><td>发现+ 定位</td></tr><tr><td>I/O Monitor</td><td>主线程I/O，多余I/O，Buffer 国小等</td><td>发现+ 定位</td></tr><tr><td>SQL I/O Monitor</td><td>主线程I/O，全表扫描，不合理事务等</td><td>发现+ 定位</td></tr></tbody></table><h4 id="STRICTMODE"><a href="#STRICTMODE" class="headerlink" title="STRICTMODE"></a><strong>STRICTMODE</strong></h4><p>严苛模式，在 Application 的 <code>onCreate()</code> 中定义，也是入门级的必备工具。可以发现并定位磁盘 I/O 问题中影响最大的主线程 I/O，使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(DEVELOPER_MODE) &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                                  .detectDiskReads()</span><br><span class="line">                                  .detectDiskWrites()</span><br><span class="line">                                  .detectNetwork()</span><br><span class="line">                                  .penaltyLog()</span><br><span class="line">                                  .build());</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理也很简单，主要是文件操作(BlockGuardOs.java)、数据库操作、和 SharedPreferences 操作的接口中插入检查的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pwrite</span><span class="params">(FileDescriptor fd, ByteBuffer buffer,<span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onWriteToDisk();</span><br><span class="line">    <span class="keyword">return</span> os.pwrite(fd, buffer, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part of blockguard.Policy interface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWriteToDisk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((mPolicyMask &amp; DETECT_DISK_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tooManyViolationsThisLoop()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BlockGuard.BlockGuardPolicyException e = <span class="keyword">new</span> StrictModeDiskWriteViolation(mPolicyMask);</span><br><span class="line">    e.fillInStackTrace();</span><br><span class="line">    startHandlingViolationException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><h4 id="冗余的文件读写"><a href="#冗余的文件读写" class="headerlink" title="冗余的文件读写"></a>冗余的文件读写</h4><p>每次打开、关闭或者读 / 写文件，操作系统都需要从用户态到内核态的转换，这种状态的切换本身是很消耗性能的，所以为了提高文件的读 / 写效率，就需要减少用户态和内核态的切换。使用缓存可以避免重复读 / 写，对于需要多次访问的数据，在第一次取出数据时，将数据放到缓存中，下次再访问这些数据时，就可以从缓存中取出来。</p><p><strong>SharedPreferences</strong></p><p>Android 系统使用 SharedPreferences 文件来保存数据很方便，再需要保存数据时的地方一次 <code>commit</code> 就可以。但很多开发同学可能并不知道每调用一次 <code>commit()</code> 就会对应一次文件的打开和关闭，从而造成因 <code>commit()</code> 方法的随意调用而导致文件的重复打开和关闭。</p><p>也就是说，当我们有多个字段需要保存时，只保留最后一个 <code>commit()</code> 方法即可。使用缓存来保存多次写入的数据，延迟写入，从而减少写入次数。</p><h4 id="主线程写入文件"><a href="#主线程写入文件" class="headerlink" title="主线程写入文件"></a>主线程写入文件</h4><p>我们要避免再主线程中进行 I/O 操作，尤其是写操作。因为写入的放大效应会让平时十多毫秒的操作方法几十倍，因此我们可以把 I/O 操作放到子线程中去执行。</p><h4 id="I-O-效率低"><a href="#I-O-效率低" class="headerlink" title="I/O 效率低"></a>I/O 效率低</h4><p><strong>选择合理的操作对象</strong></p><p>当读写文件时，使用不恰当的输入/输出流对象，就会造成 I/O 效率低的现象。比如，当我们使用 <code>ObjectOutputStream</code> 序列化磁盘时，会把内存中的每个对象保存到磁盘中，在保存对象的时候，每个数据成员会到来一次 I/O 操作。</p><p>那么我们可以在 <code>ObjectOutputStream</code> 上面封装一个输出流 <code>ByteArrayOutputStream</code> ，先将对象序列化后的信息写入到缓存区中，然后再一次性的写入到磁盘中。<strong>可以通过使用缓冲区，有效的减少磁盘 I/O 的次数</strong></p><table><br>    <tr><br>        <th></th><th></th><th>读 / 写方式</th><br>    </tr><br>    <tr><br>        <td rowspan="3">序列化写磁盘</td><td>优化前</td><td>ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td rowspan="2">优化后</td><td>BufferedOutputStream + ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td>ByteArrayOutputStream + ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td rowspan="3">序列化读磁盘</td><td>优化前</td><td>ObjectInputStream</td><br>    </tr><br>    <tr><br>    <td rowspan="2">优化后</td><td>BufferedInputStream + ObjectInputStream</td><br>    </tr><br>    <tr><br>        <td>ByteArrayInputStream + ObjectInputStream</td><br>    </tr><br></table><p><strong>合理的设置 Buffer 的大小</strong></p><p>我们可以做一个有趣的实验，如果有一个 1M 大小的文件需要我们读取，我们看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">gethash</span><span class="params">(String fileName, String hashType)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    MessageDigest md5 = MessageDigest.getInstance(hashType);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> numRead = <span class="number">0</span>;(numRed = is.read(buffer)) &gt; <span class="number">0</span>;)&#123;</span><br><span class="line">        md5.update(buffer, <span class="number">0</span>, numRead);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    <span class="keyword">return</span> toHexString(md5.digest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，程序中设置的 Buffer 大小为 1KB， 也就是说 1M 的数据，要读取 1025 次才能确保全部读取完成。那就需要对文件执行 1025 次的访问，大大增加的访问次数，就会降低读写效率。当然 Buffer 有不是越大越好。如果 Buffer 太大， 会导致申请 Buffer 的时间过长，反而整体效率不高。这里推荐使用的 Buffer 大小为 8kb，和 Java 默认的 Buffer 大小一致， Buffer 大小至少应为 4kb。</p><h4 id="重复开关数据库"><a href="#重复开关数据库" class="headerlink" title="重复开关数据库"></a>重复开关数据库</h4><p>在 <code>SQLiteDatabase</code> 的源码中，<code>getWriteableDatebase()</code> 方法的注释说明：一旦打开数据库，该链接就会被缓存，供下次使用，只有当真不需要时，调用 <code>close</code> 关闭即可。</p><p>因为数据库的开启是要给耗时的过程，每次打开数据库，同时会有一些 I/O 操作，且不建议在主线程中进行。那么我们可以在数据库打开后，先不要关闭，在应用程序退出时再关闭。</p><h4 id="AUTOINCREMENT"><a href="#AUTOINCREMENT" class="headerlink" title="AUTOINCREMENT"></a>AUTOINCREMENT</h4><p>针对数据库 INTEGER 型主键使用。其作用是保证主键是严格单调递增的，但如果出现删除或设置最大值，就会导致旧值被复用等问题。严格上来说，也不是很安全。</p><p>SQLite 创建一个叫 sqlite_sequence 的内部表来记录该表使用的最大行数。如果指定使用 UTOINCREMENT 来创建表，则 sqlite_sequence 也随之创建， UPDATE、INSERT、DELETE 语句都会修改 sqlite_sequence 的内容。因为维护 sqlite_sequence 表带来的额外开销会导致 INSERT 的效率降低。</p><h4 id="Bitmap-解吗"><a href="#Bitmap-解吗" class="headerlink" title="Bitmap 解吗"></a>Bitmap 解吗</h4><p>随着 Android SDK 升级， Google 修改了 Bitmap 解码的实现。</p><ul><li>解码 Bitmap 不要使用 decodeFile，在 4.4 以上系统效率不高</li><li>解码 Bitmap 使用 decodeStream，同时传入 BufferedInputStream</li><li>decodeResource 同样存在性能问题，可以使用 decodeResourseStream</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;资源类性能就像是撑起冰山一角的下面的冰层，我们称之为 &lt;code&gt;3 + 1 + 1&lt;/code&gt; 。 &lt;code&gt;3 + 1&lt;/code&gt;  时传统的 -磁盘、cpu 和 内存，加 1 是与环境密切相关的网络；最后一个加 1 则是因为移动网络而显得特别重要的电池（耗电）。&lt;/p&gt;
&lt;p&gt;因为冰山一角体现出来的交互类性能，包括流畅度、时延等，实际上都是资源问题。例如流畅度问题，可以是内存的垃圾回收太频繁导致的，因为有些 GC 会 STOP THE WORLD, 又可以是 CPU 问题， decode 图片开了过多的子线程，导致主线程的 CPU  资源被争抢；更可以是再主线程中读/写磁盘，磁盘读/写耗时抖一抖、页面也就跟着卡一下。所以关注资源类性能，其实是关注问题的本质去解决问题的方式。&lt;/p&gt;
&lt;h2 id=&quot;磁盘&quot;&gt;&lt;a href=&quot;#磁盘&quot; class=&quot;headerlink&quot; title=&quot;磁盘&quot;&gt;&lt;/a&gt;磁盘&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;再没有SSD 磁盘前，大家都觉着 HDD 很好用。对于外行来说，磁盘 I/0 性能总是最容易被忽略的，经理会更集中再 CPU 上。但内行人都知道，性能无非是 CPU 密集型和 I/O 密集型，磁盘 I/O 就是其中之一。&lt;/p&gt;
&lt;p&gt;在设备长时间使用，磁盘空间不足。应用触发大量随机写操作，都会导致磁盘的负载，磁盘 I/O 的耗时会产生剧烈的波动， App 能做的只有一件事儿，即减少磁盘 I/O d 操作量，特别是主线程的操作量。&lt;/p&gt;
    
    </summary>
    
      <category term="资源类性能优化" scheme="http://xiaoman.ren/categories/%E8%B5%84%E6%BA%90%E7%B1%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android 性能优化" scheme="http://xiaoman.ren/tags/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://xiaoman.ren/2021/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    <id>http://xiaoman.ren/2021/02/01/数据结构/算法/</id>
    <published>2021-02-01T12:47:12.938Z</published>
    <updated>2021-02-01T12:47:12.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高频数据结构和算法"><a href="#高频数据结构和算法" class="headerlink" title="高频数据结构和算法"></a>高频数据结构和算法</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数组/字符串</li><li>链表</li><li>栈</li><li>队列</li><li>双端队列</li><li>树</li></ul><a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>优点： 可以在 O（1） 的时间里根据下标查询某个元素</p><p>缺点：</p><ul><li>构建时必须时一段连续的空间</li><li>查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间</li><li>删除和添加某个元素时，同样需要耗费O(n) 的时间</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>单链表：</strong> 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起</p><p><strong>双链表：</strong> 与单链表不同的时，双链表的每个节点中都含有<strong>两个引用字段</strong></p><p><strong>优点：</strong> </p><ul><li>灵活的内存空间</li><li>能在 O(1) 时间内删除或添加元素</li></ul><p><strong>缺点：</strong></p><ul><li>查询元素需要O(n)时间</li></ul><p><strong>解题技巧：</strong></p><ol><li>利用快慢指针（有时需要3个）</li><li>构建一个虚假的链表头</li></ol><p><strong>练习：</strong></p><p>eg: k 个一组反转链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 k = 3</span></span><br><span class="line">prev = <span class="keyword">null</span>;</span><br><span class="line">curr = head;</span><br><span class="line">n = k;</span><br><span class="line"><span class="keyword">while</span>(curr &amp;&amp; n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p><p>算法的基本思想：</p><p>可以用一个单链表来实现</p><p>只关心上一次的操作</p><p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找下一个比自己大的数的距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackSwap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个栈，用来缓存当前的最大值的索引</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义一个数组，用来存储对应数据的间距</span></span><br><span class="line">    <span class="keyword">int</span>[] interval = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="comment">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span></span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="comment">// 拿出栈顶数据的索引</span></span><br><span class="line">                <span class="keyword">int</span> topIndex = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; num[topIndex]) &#123;</span><br><span class="line">                    interval[topIndex] = i - topIndex;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span></span><br><span class="line">        <span class="comment">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p><p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p><p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>可以利用双链表实现</p><p>队列</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>数据像鱼吐泡泡一样，从底部向上浮出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maopao</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j] &gt; num[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(num, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> src, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = num[src];</span><br><span class="line">    num[src] = num[des];</span><br><span class="line">    num[des] = temp;</span><br><span class="line">    System.out.println(Arrays.toString(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向已排列好的数组中插入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charu</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i; <span class="comment">// 记录当前最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = (i -<span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[k] &lt; num[j]) &#123;</span><br><span class="line">                swap(num, k, j);</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xuanze</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i; <span class="comment">// 已排序数组的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[minIndex] &gt; num[j]) &#123;</span><br><span class="line">                minIndex = j; <span class="comment">// 找到未排序部分的最小值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与已排序部分最大值比较，小则交换</span></span><br><span class="line">        <span class="keyword">if</span>(num[minIndex] &lt; num[i])&#123;</span><br><span class="line">            swap(num, minIndex, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><p>利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果</p><p>利用二叉树，左右两边同时排序，最后将两部分合并再一起</p><p>递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guibing</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; <span class="comment">// 临界点判断，终止递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">    guibing(nums, left, mid);</span><br><span class="line">    guibing(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(nums, left, right, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> length, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = nums.clone();</span><br><span class="line">    <span class="comment">// index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界</span></span><br><span class="line">    <span class="keyword">int</span> index = start, left = start, right = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt;= length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充</span></span><br><span class="line">            nums[index++] = copy[right++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; length)&#123;</span><br><span class="line">            <span class="comment">// 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充</span></span><br><span class="line">            nums[index++] = copy[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(copy[right] &lt; copy[left])&#123;</span><br><span class="line">            <span class="comment">// 右侧数据比左侧数据小，将右侧数据填充</span></span><br><span class="line">            nums[index++] = copy[right++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左侧数据比右侧数据小，将左侧数据填充</span></span><br><span class="line">            nums[index++] = copy[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>同样利用递归的思想。</p><p>先随机选择一个数，然后让比它小的放在左边，大的放在右边</p><p>然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kuaisu</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, low, high);</span><br><span class="line">    kuaisu(nums, low, p - <span class="number">1</span>);</span><br><span class="line">    kuaisu(nums, p + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 先随机一个索引，然后将他放在最后面。</span></span><br><span class="line">    <span class="comment">// 在定义两个指针</span></span><br><span class="line">    <span class="comment">// i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置</span></span><br><span class="line">    <span class="comment">// j: 当前第一个值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将最小值， copy 到最后一个位置</span></span><br><span class="line">    <span class="keyword">int</span> random = randRang(low, high);</span><br><span class="line">   swap(num, random, high);</span><br><span class="line">    <span class="comment">// i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">// 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小</span></span><br><span class="line">    <span class="keyword">for</span>(i = low, j = low, j &lt; high, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j] &lt; num[high]) &#123;</span><br><span class="line">            <span class="comment">// num[j] 当前值</span></span><br><span class="line">            <span class="comment">// num[high] 随机数，基准值</span></span><br><span class="line">            swap(num, i++, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准值还原到对应位置</span></span><br><span class="line">    swap(num, i, j);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRang</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(high) % (high - low + <span class="number">1</span>) + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高频数据结构和算法&quot;&gt;&lt;a href=&quot;#高频数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;高频数据结构和算法&quot;&gt;&lt;/a&gt;高频数据结构和算法&lt;/h2&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组/字符串&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;双端队列&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://xiaoman.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://xiaoman.ren/2021/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xiaoman.ren/2021/02/01/数据结构/数据结构/</id>
    <published>2021-02-01T12:47:12.937Z</published>
    <updated>2021-02-01T12:47:12.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>是一片物理上连续的大小确定的存储空间</p><p>数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。</p><p>利用索引进行查询速度快，无法真正的删除</p><a id="more"></a><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>具有连续有序性，可重复性，可扩容性，访问比较便捷</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>原理与特点</strong></p><p>实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">// 移位操作</span></span><br><span class="line">      System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                       size - index);</span><br><span class="line">      elementData[index] = element;</span><br><span class="line">      size++;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue = (E) elementData[index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 移位操作</span></span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>扩容机制：</strong></p><p><code>ArrayList</code> 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1 等价于  oldCapacity / 2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 <code>node</code> 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。</p><p>因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。</p><p>因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从前面查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从后面查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 插入时，有时也需要遍历，这里可以忽略</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 移除数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 <code>synchronized</code>，因此性能比 <code>ArrayList</code> 差，每次扩容申请双倍空间也可以自定义。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>具有不可重复性，无序性，<em>不可查找的特点</em></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet</code> 的内部使用 <code>HashMap</code> 来存储数据，即 <code>add</code> 时，将元素当作 <code>HashMap</code> 的 <code>Key</code> 来使用，这也符合 <code>Set</code> 集合不可重复性的特点。</p><p>此类集合不可以直接获取容器中的 value， 可通过遍历 <em>迭代器</em>  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 <code>ConCurrentException</code> 。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。</p><p><strong>List 和 Set 的区别</strong></p><ul><li>是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许</li><li>元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合</li><li>List 可以通过下标来访问元素， 而 Set 不能</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>数组</strong> 和 <strong>单链表</strong> 的组合， 数组用来存储 key，链表用来存储实际的 value</p><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value);"></a>put(K key, V value);</h3><p>当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，</p><p>当链表为空时，通过 <code>resize()</code> 函数帮我创建一个新链表，默认长度为 16 （1 &lt;&lt; 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)</p><p>当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 装箱过程，计算 hash 值的过程。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line">        Node&lt;K, V&gt; p;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// tab[i = (n - 1) &amp; hash] </span></span><br><span class="line">    <span class="comment">// n 是数组的长度，经过 &amp; 和 hash 值的位运算（模运算：求余数的运算，等价于=&gt; （hash % n）），获得该元素在数组中的索引</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Hash-碰撞-冲突"><a href="#Hash-碰撞-冲突" class="headerlink" title="Hash 碰撞/冲突"></a><strong>Hash 碰撞/冲突</strong></h3><p>在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值</p><p><strong>解决方案</strong>：</p><p><strong>链表法：</strong> 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 <code>get()</code> 函数获取数据时，拿到一个链表，就遍历，找到 <code>hash</code> 值相同的那个节点，并返回。</p><p><strong>避免冲突</strong>：</p><p>阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。</p><p><strong>扩容方案：</strong></p><p>加载因子：<code>loadFactor</code> 默认值是 0.75</p><p>阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。</p><p>HashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。</p><blockquote><p>比如：</p><p>length1 = 10，(非 2 的次幂)，对应的二进制数是 1001</p><p>length2 = 16(2 的 4 次幂)，对应的二进制数是 1111</p><p>当产生一个 hash 值，为 6（0110）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110</p><p>当产生一个 hash 值，为 7（0111）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111</p><p>由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞</p></blockquote><p>当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。</p><p>当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。</p><p>开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。</p><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p><strong>原理与特点</strong></p><p>由 <strong>双数组</strong> 构成，两个数组分别存储 <code>Key</code> 和  <code>Value</code> ，并一一对应。</p><p>查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）</p><p>通过获取 key 的索引找到其对应的 value 值，也就具备了 <strong>查询速度快</strong> 的特点（也是数组的特点）</p><p>删除元素时，仅将元素标记位 <strong>“DELETE”</strong> 状态，不发生移位等操作，因此速度上会比 <code>ArrayList</code> 快</p><p>因为是标记为 “DELETE” ，因此算法是可以达到复用，再利用二分查找，被标记为 “DELETE” 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。</p><p>缺点是，Key 只能是 <code>int</code> 类型数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 二分查找，快速定位传入的 key 所在位置</span></span><br><span class="line">       <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">       <span class="comment">// 如果存在，直接替换同位置数据</span></span><br><span class="line">       <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           mValues[i] = value;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值</span></span><br><span class="line">           i = ~i;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">               mKeys[i] = key;</span><br><span class="line">               mValues[i] = value;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">               gc();</span><br><span class="line">               <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">               i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 扩容机制，2倍</span></span><br><span class="line">           mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">           mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">           mSize++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insert(<span class="keyword">int</span>[] array, <span class="keyword">int</span> currentSize, <span class="keyword">int</span> index, <span class="keyword">int</span> element) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[growSize(currentSize)];</span><br><span class="line">       System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, index);</span><br><span class="line">       newArray[index] = element;</span><br><span class="line">       System.arraycopy(array, index, newArray, index + <span class="number">1</span>, array.length - index);</span><br><span class="line">       <span class="keyword">return</span> newArray;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">growSize</span><span class="params">(<span class="keyword">int</span> currentSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 2 倍扩容机制</span></span><br><span class="line">       <span class="keyword">return</span> currentSize &lt;= <span class="number">4</span> ? <span class="number">8</span> : currentSize * <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移除数据，仅标记 DELETE 状态</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">               mValues[i] = DELETED;</span><br><span class="line">               mGarbage = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>扩容机制：</strong></p><p>同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。</p><h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 <code>hashcode</code> 作为 key，弥补了 <code>SparseArray</code> 只能是 <code>int</code> 型。使用双数组的形式，又弥补了 <code>HashMap</code> 的对内存消耗的问题。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>是 <code>HashMap</code> 的子类， <code>put</code>  和 <code>remove</code> 函数使用的就是 <code>HashMap</code> 的，没有太大却别，主要区别在于 <code>get</code> 函数， <code>LinkedHashMap</code> 在每次 <code>get</code> 出一个数据后，会将这个数据放在链表的尾部。</p><p><code>LinkedHashMap</code> 的应用，在 <code>LRUCache</code> 和 <code>DiskLRUCache</code> 中使用，其算法名称 <em>最少/最小使用算法</em> ，也就是说，利用了 <code>LinkedHashMap</code> 的 <code>get</code> 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。</p><h2 id="队列-Queue-和-栈-Stack"><a href="#队列-Queue-和-栈-Stack" class="headerlink" title="队列 Queue 和 栈 Stack"></a>队列 Queue 和 栈 Stack</h2><ul><li>队列的特点是 <em>先入先出</em></li><li>栈的特点是 <em>先入后出</em> </li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p><p>算法的基本思想：</p><p>可以用一个单链表来实现</p><p>只关心上一次的操作</p><p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找下一个比自己大的数的距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackSwap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个栈，用来缓存当前的最大值的索引</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义一个数组，用来存储对应数据的间距</span></span><br><span class="line">    <span class="keyword">int</span>[] interval = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="comment">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span></span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="comment">// 拿出栈顶数据的索引</span></span><br><span class="line">                <span class="keyword">int</span> topIndex = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; num[topIndex]) &#123;</span><br><span class="line">                    interval[topIndex] = i - topIndex;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span></span><br><span class="line">        <span class="comment">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p><p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p><p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;是一片物理上连续的大小确定的存储空间&lt;/p&gt;
&lt;p&gt;数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。&lt;/p&gt;
&lt;p&gt;利用索引进行查询速度快，无法真正的删除&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://xiaoman.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码</title>
    <link href="http://xiaoman.ren/2021/02/01/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Glide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2021/02/01/三方框架/Glide 源码分析/</id>
    <published>2021-02-01T12:47:12.935Z</published>
    <updated>2021-02-01T12:47:12.935Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 <code>Picasso</code> 和 <code>ImageLoader</code> 两套框架。 都各有特色。这里主要还是讲一下 <code>Glide</code> 。</p><p><strong>基础用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(url).into(imageView);</span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Android 开发中，我们通常最简单的使用 <code>Glide</code> 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。</p><p>从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，<code>with</code> <code>load</code> 和 <code>into</code>，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">主要功能</th></tr></thead><tbody><tr><td style="text-align:center">with</td><td style="text-align:center">1. 初始化Glide对象<br>2. 创建空白的 Fragment 管理生命周期机制<br>3. 创建一个 RequestManager 管理任务</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">最终构建出 RequestBuilder ，记录传入的数据</td></tr><tr><td style="text-align:center">into</td><td style="text-align:center">1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br>2. 活动缓存<br>3. 内存缓存<br>4. HttpUrlConnection</td></tr></tbody></table><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><code>Glide</code> 通过 <code>with</code> 函数，给自己的实例化，并创建一个空白的 <code>Fragment</code> 来管理生命周期并绑定 <code>ReqeustManager</code> 。继续通过 <code>load()</code> 函数构建一个 <code>RequestBuilder()</code> 并缓存我们的参数，继续通过 <code>into</code> 创建一个 <code>Request</code> 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 <code>ActivityResources</code> 有没有数据，再检查内存缓存 <code>LRUResourceCache</code> ，如果两级缓存都未命中，则启动一个异步任务 <code>DecodeJob</code>, 去检查 <code>DiskCache</code> 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 <code>HttpUrlConnection</code> ，解析 <code>InputStream</code> 进行采样，最终拿到 <code>Bitmap</code>，将 <code>Bitmap</code> 转换成 <code>Drawable</code> 并讲数据缓存到磁盘中。</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>从上面的表格中，我们可以看出来 <code>with</code> 函数，就是用来帮我创建 <code>Glide</code> 对象，并创建一个空白的 <code>Fragment</code> 来管理生命周期。其具体的工作流程如图：</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true" alt="Glide with 时序图"></p><p>由上面的时序图，我们可以顺序的分析，我们一步步去分析。</p><p><strong>Glide.with()</strong></p><p><code>Glide.with()</code> 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getRetriever</strong>()</p><p><code>getRetriever()</code> 通过 Glide 的 get 函数，帮我们初始化了一个 <code>Glide</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(@Nullable Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get(context)</strong></p><p>可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>checkAndInitializeGlide() &amp; initializeGlide()</strong></p><p>最终通过构造者模式，完成了对 <code>Glide</code> 对象的初始化，同时在构造者中，也对很多 <code>Glide</code> 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkAndInitializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (isInitializing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"You cannot call Glide.get() in registerComponents(),"</span></span><br><span class="line">            + <span class="string">" use the provided Glide instance instead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isInitializing = <span class="keyword">true</span>;</span><br><span class="line">    initializeGlide(context, generatedAppGlideModule);</span><br><span class="line">    isInitializing = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule)</span> </span>&#123;</span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里， <code>Glide</code> 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。</p><p>并且代码按照流程，<code>get()</code> 的深度代码已经完成，程序会逐步回到 <code>getRetriever()</code> 函数中，去执行 <code>getRequestManagerRetriever</code> ， <code>getRequestManagerRetriever</code> <code>是通过</code>Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 <code>with()</code>函数 的 <code>get()</code> 去创建 <code>RequestManager</code></p><p><strong>get(Fragment fragment)</strong></p><p>这时候，我们发现，现在代码已经跳转到 <code>RequestManagerRetriever</code> 类中</p><p><strong>RequestManagerRetriever</strong></p><p><code>RequestManagerRetriever</code> 是一个管理类，负责生产 <code>Fragment</code> 对象，根据我们传入的 <code>Context</code> 上下文的定义不同，最终会帮我们创建不同的生命周期管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="comment">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span></span><br><span class="line">    <span class="keyword">return</span> get(fragment.getContext().getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">        &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">       <span class="comment">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong></p><ol><li><p><strong>如果当前任务工作在后台线程或者传入的 <code>Context</code> 对象是一个 <code>Application</code> 级别的，那 <code>Glide</code> 就会帮我们创建一个和 <code>Application</code> 同生命周期的 <code>RequestManager</code> 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color="red">内存的泄漏</font></strong>。 因此我们使用时，尽量不要传入里类似的。</p></li><li><p>如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 <code>Glide</code> 就会帮我们创建个空白的 <code>Fragment</code>， <code>supportFragmentGet</code> 和  <code>fragmentGet</code> 两种方案是用来做 <code>androidX</code> 和 <code>android.app</code>中不同 <code>fragment</code> 的适配</p></li></ol></blockquote><p><strong>supportFragmentGet</strong></p><p>创建管理生命周期的 Fragment, <code>androidx</code> 对应的是 <code>supportFragmentGet()</code> ， <code>android.app</code> 对应的是 <code>fragmentGet()</code>， 这里以 <code>supportFragmentGet()</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建/获取当前空白的 Fragment</span></span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    <span class="comment">// 获取空白 Fragment 中的 RequestManager 对象</span></span><br><span class="line">    <span class="comment">// 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中</span></span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 返回 reqeustManager 对象</span></span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> FragmentManager fm, @Nullable Fragment parentHint, <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment </span></span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="comment">// 如果为空，说明空白的 Fragment 还没有被添加进去</span></span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象</span></span><br><span class="line">      <span class="comment">// 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，</span></span><br><span class="line">      <span class="comment">// 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，</span></span><br><span class="line">      <span class="comment">// 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap</span></span><br><span class="line">    current = pendingSupportRequestManagerFragments.get(fm); <span class="comment">// 第一保障</span></span><br><span class="line">      <span class="comment">// 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的空白 Fragment</span></span><br><span class="line">      current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">          <span class="comment">// 调用生命周期方法，让所有的监听者开始任务（后面会说）</span></span><br><span class="line">        current.getGlideLifecycle().onStart();</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 将创建好的 Fragment 存入到集合中</span></span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">        <span class="comment">// Handler 通知父容器，这里添加了一个 Fragment</span></span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        <span class="comment">// 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）</span></span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong></p><p>这里有一个比较困惑的地方就是，将已经创建好的 <code>Fragment</code> 添加到集合中去后，又通过 <code>Handler</code> 消息，将这个 <code>Fragment</code> 从集合中移除，这是为什么呢？</p><p>其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，<code>fragment</code> 的添加也是通过 <code>Handler</code> 来完成的，但 <code>Handler</code> 消息的执行时间不能保证，因此通过 <code>Handler</code> 再发一次消息，让移除操作在 <code>Fragment</code> 添加完成之后去执行，就一定能够得到保障。</p><p>只有当 <code>Fragment</code> 被添加进入父容器之后， <code>fm.findFragmentByTag</code> 才能获取到对象。这也是为了保证每个父容器都只有一个空白 <code>Fragment</code> 的两次保障。</p></blockquote><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p>至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true" alt="Glide lifecycle"></p><p><strong>SupportRequestManagerFragment</strong> </p><p>内部绑定了 <code>ActivityFragmentLifecycle</code> ，通过 Fragment 生生命周期变化，来引导 <code>RequestManager</code> 完成图片的请求和后续的显示</p><p>我们查看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportRequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SupportRMFragment"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint</span>(<span class="string">"ValidFragment"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">(@NonNull ActivityFragmentLifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造器创建了 ActivityFramgentLifecycle</span></span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">    unregisterFragmentWithRoot();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。</p><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true" alt="Glide load"></p><p>我们将 <code>Glide.with(this).load(url).into(view);</code> 拆分开来写，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestManager requestManager = Glide.with(<span class="keyword">this</span>);</span><br><span class="line">RequestBuilder requestBuilder = requestManager.load(url);</span><br><span class="line">requestBuilder.into(view);</span><br></pre></td></tr></table></figure><p>可以看出， load 函数，我们传入了一个 <code>String</code> 类型的 <code>Url</code>， 最终返回给我们一个 <code>RequestBuilder</code> 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 <code>RequestBuilder</code> 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 <code>Drawable</code> 。</p><p><code>Glide</code> 也为我们提供了丰富的 <code>load api</code>， 我们可以传入 <code>url, bitmap, byte[], Drawable, Uri, File, Integer</code> 等等， <code>RequestBuilder</code> 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 <code>Drawable</code> 给图片容器，也就是后面我们要说的 <code>into</code> 函数。</p><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><p>into 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true" alt></p><p>但我们先按照这个残图先分析一下。</p><p>当 <code>into(imageview)</code> 被调用后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">        <span class="keyword">case</span> FIT_START:</span><br><span class="line">        <span class="keyword">case</span> FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER:</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Glide 显示对图片进行了解析，获取图片的尺寸等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续，创建了一个 <code>Request</code> ，这个 <code>Request</code> 的真实对象是 <code>SingleRequest</code> ，并通过 <code>requestManager</code> 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 &lt;code&gt;Picasso&lt;/code&gt; 和 &lt;code&gt;ImageLoader&lt;/code&gt; 两套框架。 都各有特色。这里主要还是讲一下 &lt;code&gt;Glide&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础用法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Glide.with(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;).load(url).into(imageView);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Glide" scheme="http://xiaoman.ren/categories/Glide/"/>
    
    
      <category term="三方框架" scheme="http://xiaoman.ren/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Typora 设置图床</title>
    <link href="http://xiaoman.ren/2021/02/01/Tools/Typora%20%E8%87%AA%E5%8A%A8%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/"/>
    <id>http://xiaoman.ren/2021/02/01/Tools/Typora 自动图床设置/</id>
    <published>2021-02-01T12:47:12.933Z</published>
    <updated>2021-02-01T12:47:12.933Z</updated>
    
    <content type="html"><![CDATA[<p>自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。<a id="more"></a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"picBed"</span>: &#123;</span><br><span class="line">    <span class="attr">"uploader"</span>: <span class="string">"github"</span>,</span><br><span class="line">    <span class="attr">"github"</span>: &#123;</span><br><span class="line">      "repo": "xxxxxxx/static_file", // 仓库名，格式时 username/reponame</span><br><span class="line">      "token": "xxxxxxxxxxxx", // github token</span><br><span class="line">      "path": "images/", // 自定义存储路径 如： image/</span><br><span class="line">      "branch": "master" // 分支名，默认是 master</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "picgoPlugins": &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先您要有一个 Github 账号</p></li><li><p>新建一个仓库</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png" alt="image-20210128140803755"></p></li><li><p>生成一个 token 用于 Picgo 操作您的仓库， </p><ul><li><p>访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==" title="https://github.com/settings/tokens">https://github.com/settings/tokens<i class="fa fa-external-link"></i></span></p></li><li><p>然后点击 <code>Generate new token</code></p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png" alt="image-20210128141003873"></p></li><li><p>勾选 <code>repo</code> 并记录 token</p></li></ul></li><li><p>配置 Picgo， 如上 JSON</p></li></ol><h2 id="Typora-设置如下图"><a href="#Typora-设置如下图" class="headerlink" title="Typora 设置如下图"></a>Typora 设置如下图</h2><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png" alt="image-20210128141254331"></p><ul><li><p>下载或更新：大约 18m 的 Picgo 插件，点击安装即可</p></li><li><p>点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入</p></li><li><p>点击验证图片上传选项，验证 github 是否连通</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png" alt="image-20210128141827255"></p></li></ul><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><p>我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9waWNnby5naXRodWIuaW8vUGljR28tQ29yZS1Eb2MvemgvZ3VpZGUvY29uZmlnLmh0bWwjJUU5JUJCJTk4JUU4JUFFJUE0JUU5JTg1JThEJUU3JUJEJUFFJUU2JTk2JTg3JUU0JUJCJUI2" title="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">Typora 文件配置<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9VcGxvYWQtSW1hZ2Uv" title="https://support.typora.io/Upload-Image/">图片上传工具配置<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。
    
    </summary>
    
      <category term="开发工具" scheme="http://xiaoman.ren/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Tools" scheme="http://xiaoman.ren/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 数学公式编辑</title>
    <link href="http://xiaoman.ren/2021/02/01/Tools/Markdown%20%E5%85%AC%E5%BC%8F/"/>
    <id>http://xiaoman.ren/2021/02/01/Tools/Markdown 公式/</id>
    <published>2021-02-01T12:47:12.929Z</published>
    <updated>2021-02-01T12:47:12.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown中公式编辑教程"><a href="#Markdown中公式编辑教程" class="headerlink" title="Markdown中公式编辑教程"></a>Markdown中公式编辑教程</h1><h1 id="markdown中公式编辑教程"><a href="#markdown中公式编辑教程" class="headerlink" title="markdown中公式编辑教程"></a>markdown中公式编辑教程</h1><p>标签： Mathjax 公式编辑 markdown</p><p>一般公式分为两种形式，行内公式和行间公式。</p><ul><li>行内公式：<img src="https://math.jianshu.com/math?formula=\Gamma(z" alt="\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,."> %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)</li><li>行间公式：<img src="https://math.jianshu.com/math?formula=\Gamma(z" alt="\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,."> %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)</li></ul><p>  对应的代码块为：<a id="more"></a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ \Gamma(z) = \int_<span class="number">0</span>^\infty t^&#123;z-<span class="number">1</span>&#125;e^&#123;-t&#125;dt\,. $</span><br><span class="line">$$\Gamma(z) = \int_<span class="number">0</span>^\infty t^&#123;z-<span class="number">1</span>&#125;e^&#123;-t&#125;dt\,.$$</span><br></pre></td></tr></table></figure><p>  行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。<br>  下面主要介绍数学公式中常用的一些符号。</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><strong>希腊字母</strong></h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大写</th><th style="text-align:center">code</th><th style="text-align:center">小写</th><th style="text-align:center">code</th></tr></thead><tbody><tr><td style="text-align:center">alpha</td><td style="text-align:center">A</td><td style="text-align:center">A</td><td style="text-align:center">α</td><td style="text-align:center">\alpha</td></tr><tr><td style="text-align:center">beta</td><td style="text-align:center">B</td><td style="text-align:center">B</td><td style="text-align:center">β</td><td style="text-align:center">\beta</td></tr><tr><td style="text-align:center">gamma</td><td style="text-align:center">Γ</td><td style="text-align:center">\Gamma</td><td style="text-align:center">γ</td><td style="text-align:center">\gamma</td></tr><tr><td style="text-align:center">delta</td><td style="text-align:center">Δ</td><td style="text-align:center">\Delta</td><td style="text-align:center">δ</td><td style="text-align:center">\delta</td></tr><tr><td style="text-align:center">epsilon</td><td style="text-align:center">E</td><td style="text-align:center">E</td><td style="text-align:center">ϵ</td><td style="text-align:center">\epsilon</td></tr><tr><td style="text-align:center">zeta</td><td style="text-align:center">Z</td><td style="text-align:center">Z</td><td style="text-align:center">ζ</td><td style="text-align:center">\zeta</td></tr><tr><td style="text-align:center">eta</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">η</td><td style="text-align:center">\eta</td></tr><tr><td style="text-align:center">theta</td><td style="text-align:center">Θ</td><td style="text-align:center">\Theta</td><td style="text-align:center">θ</td><td style="text-align:center">\theta</td></tr><tr><td style="text-align:center">iota</td><td style="text-align:center">I</td><td style="text-align:center">I</td><td style="text-align:center">ι</td><td style="text-align:center">\iota</td></tr><tr><td style="text-align:center">kappa</td><td style="text-align:center">K</td><td style="text-align:center">K</td><td style="text-align:center">κ</td><td style="text-align:center">\kappa</td></tr><tr><td style="text-align:center">lambda</td><td style="text-align:center">Λ</td><td style="text-align:center">\Lambda</td><td style="text-align:center">λ</td><td style="text-align:center">\lambda</td></tr><tr><td style="text-align:center">mu</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">μ</td><td style="text-align:center">\mu</td></tr><tr><td style="text-align:center">nu</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">ν</td><td style="text-align:center">\nu</td></tr><tr><td style="text-align:center">xi</td><td style="text-align:center">Ξ</td><td style="text-align:center">\Xi</td><td style="text-align:center">ξ</td><td style="text-align:center">\xi</td></tr><tr><td style="text-align:center">omicron</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">ο</td><td style="text-align:center">\omicron</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">Π</td><td style="text-align:center">\Pi</td><td style="text-align:center">π</td><td style="text-align:center">\pi</td></tr><tr><td style="text-align:center">rho</td><td style="text-align:center">P</td><td style="text-align:center">P</td><td style="text-align:center">ρ</td><td style="text-align:center">\rho</td></tr><tr><td style="text-align:center">sigma</td><td style="text-align:center">Σ</td><td style="text-align:center">\Sigma</td><td style="text-align:center">σ</td><td style="text-align:center">\sigma</td></tr><tr><td style="text-align:center">tau</td><td style="text-align:center">T</td><td style="text-align:center">T</td><td style="text-align:center">τ</td><td style="text-align:center">\tau</td></tr><tr><td style="text-align:center">upsilon</td><td style="text-align:center">Υ</td><td style="text-align:center">υ</td><td style="text-align:center">\upsilon</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">phi</td><td style="text-align:center">Φ</td><td style="text-align:center">\Phi</td><td style="text-align:center">ϕ</td><td style="text-align:center">\phi</td></tr><tr><td style="text-align:center">chi</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">χ</td><td style="text-align:center">\chi</td></tr><tr><td style="text-align:center">psi</td><td style="text-align:center">Ψ</td><td style="text-align:center">\Psi</td><td style="text-align:center">ψ</td><td style="text-align:center">\psi</td></tr><tr><td style="text-align:center">omega</td><td style="text-align:center">Ω</td><td style="text-align:center">\Omega</td><td style="text-align:center">ω</td><td style="text-align:center">\omega</td></tr></tbody></table><h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a><strong>上标与下标</strong></h2><p>  上标和下标分别使用<code>^</code> 与<code>_</code> ，例如<code>$x_i^2$</code>表示的是：<img src="https://math.jianshu.com/math?formula=x_i^2" alt="x_i^2">。<br>  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code> 表示的是<img src="https://math.jianshu.com/math?formula=10^10" alt="10^10">，而<code>$10^{10}$</code> 才是<img src="https://math.jianshu.com/math?formula=10^{10}" alt="10^{10}">。同时，大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code> ：<img src="https://math.jianshu.com/math?formula={x^5}^6" alt="{x^5}^6">或者<code>$x^{5^6}$</code> ：<img src="https://math.jianshu.com/math?formula=x^{5^6}" alt="x^{5^6}">。</p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a><strong>括号</strong></h2><h3 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h3><p>  使用原始的<code>( )</code> ，<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code> ：<img src="https://math.jianshu.com/math?formula=(2%2B3" alt="(2+3)">) <img src="https://math.jianshu.com/math?formula=[4%2B4]" alt="[4+4]"><br>  使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac{x}{y}\right)$</code> ：<img src="https://math.jianshu.com/math?formula=\left(\frac{x}{y}\right" alt="\left(\frac{x}{y}\right)">)</p><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\{</code>和<code>\}</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。如<code>$\{a\*b\}:a\∗b$</code> 或<code>$\lbrace a\*b\rbrace :a\*b$</code> 表示<img src="https://math.jianshu.com/math?formula=\{a*b\}%3Aa∗b" alt="\{a*b\}:a∗b">。</p><h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h3><p>  区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：<img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math" alt="\langle x \rangle">。</p><h3 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h3><p>  使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：<img src="https://math.jianshu.com/math?formula=\lceil x \rceil" alt="\lceil x \rceil">。</p><h3 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h3><p>  使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：<img src="https://math.jianshu.com/math?formula=\lfloor x \rfloor" alt="\lfloor x \rfloor">。</p><h2 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a><strong>求和与积分</strong></h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>  <code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>  <code>$\sum_{r=1}^n$</code>表示：<img src="https://math.jianshu.com/math?formula=\sum_{r%3D1}^n" alt="\sum_{r=1}^n">。<br>  <code>$$\sum_{r=1}^n$$</code>表示：<img src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" alt="\sum_{r=1}^n"></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>  <code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_{r=1}^\infty$</code>：<img src="https://math.jianshu.com/math?formula=\int_{r%3D1}^\infty" alt="\int_{r=1}^\infty">。<br>  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>  <code>$\iint$</code> ：<img src="https://math.jianshu.com/math?formula=\iint" alt="\iint"><br>  <code>$\iiint$</code> ：<img src="https://math.jianshu.com/math?formula=\iiint" alt="\iiint"><br>  <code>$\iiiint$</code> ：<img src="https://math.jianshu.com/math?formula=\iiiint" alt="\iiiint"></p><h3 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h3><p>  <code>$\prod {a+b}$</code>，输出：<img src="https://math.jianshu.com/math?formula=\prod {a%2Bb}" alt="\prod {a+b}">。<br>  <code>$\prod_{i=1}^{K}$</code>，输出：<img src="https://math.jianshu.com/math?formula=\prod_{i%3D1}^{K}" alt="\prod_{i=1}^{K}">。<br>  <code>$$\prod_{i=1}^{K}$$</code>，输出：<img src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" alt="\prod_{i=1}^{K}">。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>  与此类似的符号还有，<br>  <code>$\prod$</code> ：<img src="https://math.jianshu.com/math?formula=\prod" alt="\prod"><br>  <code>$\bigcup$</code> ：<img src="https://math.jianshu.com/math?formula=\bigcup" alt="\bigcup"><br>  <code>$\bigcap$</code> ：<img src="https://math.jianshu.com/math?formula=\bigcap" alt="\bigcap"><br>  <code>$arg\,\max_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=arg\%2C\max_{c_k}" alt="arg\,\max_{c_k}"><br>  <code>$arg\,\min_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=arg\%2C\min_{c_k}" alt="arg\,\min_{c_k}"><br>  <code>$\mathop {argmin}_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\mathop {argmin}_{c_k}" alt="\mathop {argmin}_{c_k}"><br>  <code>$\mathop {argmax}_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\mathop {argmax}_{c_k}" alt="\mathop {argmax}_{c_k}"><br>  <code>$\max_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\max_{c_k}" alt="\max_{c_k}"><br>  <code>$\min_{c_k}$</code>：<img src="https://math.jianshu.com/math?formula=\min_{c_k}" alt="\min_{c_k}"></p><h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a><strong>分式与根式</strong></h2><h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><ul><li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img src="https://math.jianshu.com/math?formula=\frac ab" alt="\frac ab">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\frac {a+c+1}{b+c+2}$</code>表示<img src="https://math.jianshu.com/math?formula=\frac {a%2Bc%2B1}{b%2Bc%2B2}" alt="\frac {a+c+1}{b+c+2}">。</li><li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>{a+1\over b+1}</code>：<img src="https://math.jianshu.com/math?formula={a%2B1\over b%2B1}" alt="{a+1\over b+1}"></li></ul><h3 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h3><p>  书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br>  <code>\frac</code> 表示如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x=a_<span class="number">0</span> + \frac &#123;<span class="number">1</span>^<span class="number">2</span>&#125;&#123;a_1 + \frac &#123;<span class="number">2</span>^<span class="number">2</span>&#125;&#123;a_2 + \frac &#123;<span class="number">3</span>^<span class="number">2</span>&#125;&#123;a_3 + \frac &#123;<span class="number">4</span>^<span class="number">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>  显示如下：<br><img src="https://math.jianshu.com/math?formula=x%3Da_0 %2B \frac {1^2}{a_1 %2B \frac {2^2}{a_2 %2B \frac {3^2}{a_3 %2B \frac {4^2}{a_4 %2B ...}}}}" alt="x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}"><br>  <code>\cfrac</code> 表示如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x=a_<span class="number">0</span> + \cfrac &#123;<span class="number">1</span>^<span class="number">2</span>&#125;&#123;a_1 + \cfrac &#123;<span class="number">2</span>^<span class="number">2</span>&#125;&#123;a_2 + \cfrac &#123;<span class="number">3</span>^<span class="number">2</span>&#125;&#123;a_3 + \cfrac &#123;<span class="number">4</span>^<span class="number">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>  显示如下：<br><img src="https://math.jianshu.com/math?formula=x%3Da_0 %2B \cfrac {1^2}{a_1 %2B \cfrac {2^2}{a_2 %2B \cfrac {3^2}{a_3 %2B \cfrac {4^2}{a_4 %2B ...}}}}" alt="x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}"></p><h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>  根式使用<code>\sqrt</code> 来表示。<br>  如开4次方：<code>$\sqrt[4]{\frac xy}$</code> ：<img src="https://math.jianshu.com/math?formula=\sqrt[4]{\frac xy}" alt="\sqrt[4]{\frac xy}">。<br>  开平方：<code>$\sqrt {a+b}$</code>：<img src="https://math.jianshu.com/math?formula=\sqrt {a%2Bb}" alt="\sqrt {a+b}">。</p><h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a><strong>多行表达式</strong></h2><h3 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h3><p>  定义函数的时候经常需要分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code> 。其中：</p><ul><li>  使用<code>\\</code> 来分类，</li><li>  使用<code>&amp;</code> 指示需要对齐的位置，</li><li>  使用<code>\</code> +<code>空格</code>表示空格。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(n)</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;<span class="keyword">if</span>\ n\ is\ even\\</span><br><span class="line"><span class="number">3</span>n + <span class="number">1</span>, &amp;<span class="keyword">if</span>\  n\ is\ odd</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示:<br><img src="https://math.jianshu.com/math?formula=f(n" alt="f(n) \begin{cases} \cfrac n2, &amp;if\ n\ is\ even\\ 3n + 1, &amp;if\ n\ is\ odd \end{cases}"> \begin{cases} \cfrac n2%2C %26if\ n\ is\ even\ 3n %2B 1%2C %26if\ n\ is\ odd \end{cases})</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) =</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">0</span>, &amp; \text&#123;Y = f(X)&#125;  \\</span><br><span class="line"><span class="number">1</span>, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示:<br><img src="https://math.jianshu.com/math?formula=L(Y%2Cf(X" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\ 1, &amp; \text{Y $\neq$ f(X)} \end{cases}">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)<br>  如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code> 代替<code>\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) =</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">0</span>, &amp; \text&#123;Y = f(X)&#125; \\[<span class="number">5</span>ex]</span><br><span class="line"><span class="number">1</span>, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示：<br><img src="https://math.jianshu.com/math?formula=L(Y%2Cf(X" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\[5ex] 1, &amp; \text{Y $\neq$ f(X)} \end{cases}">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)</p><h3 id="多行表达式-1"><a href="#多行表达式-1" class="headerlink" title="多行表达式"></a>多行表达式</h3><p>  有时候需要将一行公式分多行进行显示。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;\<span class="keyword">begin</span>&#123;split&#125; </span><br><span class="line">a&amp;=b+c-d \\ </span><br><span class="line">&amp;\quad +e-f\\ </span><br><span class="line">&amp;=g+h\\ </span><br><span class="line">&amp; =i </span><br><span class="line">\<span class="keyword">end</span>&#123;split&#125;\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{equation}\begin{split} a%26%3Db%2Bc-d \\ %26\quad %2Be-f\\ %26%3Dg%2Bh\\ %26 %3Di \end{split}\end{equation}" alt="\begin{equation}\begin{split} a&amp;=b+c-d \\ &amp;\quad +e-f\\ &amp;=g+h\\ &amp; =i \end{split}\end{equation}"><br>  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><p>  使用<code>\begin{array}...\end{array}</code> 与<code>\left \{</code> 与<code>\right.</code> 配合表示方程组:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left \&#123; </span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\left \{ \begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \end{array} \right." alt="\left \{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{array} \right."><br>  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\</code> ,增加些许间隙，<code>\;</code> 增加较宽的间隙，<code>\quad</code> 与<code>\qquad</code> 会增加更大的间隙。</p><h2 id="特殊函数与符号"><a href="#特殊函数与符号" class="headerlink" title="特殊函数与符号"></a><strong>特殊函数与符号</strong></h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>  <code>\snx$</code> : <img src="https://math.jianshu.com/math?formula=sinx" alt="sinx"><br>  <code>\arctanx</code> : <img src="https://math.jianshu.com/math?formula=arctanx" alt="arctanx"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>  小于(<code>\lt</code> )：<img src="https://math.jianshu.com/math?formula=\lt" alt="\lt"><br>  大于(<code>\gt</code> )：<img src="https://math.jianshu.com/math?formula=\gt" alt="\gt"><br>  小于等于(<code>\le</code> )：<img src="https://math.jianshu.com/math?formula=\le" alt="\le"><br>  大于等于(<code>\ge</code> )：<img src="https://math.jianshu.com/math?formula=\ge" alt="\ge"><br>  不等于(<code>\ne</code> ) : <img src="https://math.jianshu.com/math?formula=\ne" alt="\ne"><br>  可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> : <img src="https://math.jianshu.com/math?formula=\not\lt`" alt="\not\lt`"></p><h3 id="集合关系与运算"><a href="#集合关系与运算" class="headerlink" title="集合关系与运算"></a>集合关系与运算</h3><p>  并集(<code>\cup</code> ): <img src="https://math.jianshu.com/math?formula=\cup" alt="\cup"><br>  交集(<code>\cap</code> ): <img src="https://math.jianshu.com/math?formula=\cap" alt="\cap"><br>  差集(<code>\setminus</code> ): <img src="https://math.jianshu.com/math?formula=\setminus" alt="\setminus"><br>  子集(<code>\subset</code> ): <img src="https://math.jianshu.com/math?formula=\subset" alt="\subset"><br>  子集(<code>\subseteq</code> ): <img src="https://math.jianshu.com/math?formula=\subseteq" alt="\subseteq"><br>  非子集(<code>\subsetneq</code> ): <img src="https://math.jianshu.com/math?formula=\subsetneq" alt="\subsetneq"><br>  父集(<code>\supset</code> ): <img src="https://math.jianshu.com/math?formula=\supset" alt="\supset"><br>  属于(<code>\in</code> ): <img src="https://math.jianshu.com/math?formula=\in" alt="\in"><br>  不属于(<code>\notin</code> ): <img src="https://math.jianshu.com/math?formula=\notin" alt="\notin"><br>  空集(<code>\emptyset</code> ): <img src="https://math.jianshu.com/math?formula=\emptyset" alt="\emptyset"><br>  空(<code>\varnothing</code> ): <img src="https://math.jianshu.com/math?formula=\varnothing" alt="\varnothing"></p><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>  <code>\binom{n+1}{2k}</code> : <img src="https://math.jianshu.com/math?formula=\binom{n%2B1}{2k}" alt="\binom{n+1}{2k}"><br>  <code>{n+1 \choose 2k}</code> : <img src="https://math.jianshu.com/math?formula={n%2B1 \choose 2k}" alt="{n+1 \choose 2k}"></p><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p>  (<code>\to</code> ):<img src="https://math.jianshu.com/math?formula=\to" alt="\to"><br>  (<code>\rightarrow</code> ): <img src="https://math.jianshu.com/math?formula=\rightarrow" alt="\rightarrow"><br>  (<code>\leftarrow</code> ): <img src="https://math.jianshu.com/math?formula=\leftarrow" alt="\leftarrow"><br>  (<code>\Rightarrow</code> ): <img src="https://math.jianshu.com/math?formula=\Rightarrow" alt="\Rightarrow"><br>  (<code>\Leftarrow</code> ): <img src="https://math.jianshu.com/math?formula=\Leftarrow" alt="\Leftarrow"><br>  (<code>\mapsto</code> ): <img src="https://math.jianshu.com/math?formula=\mapsto" alt="\mapsto"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>  (<code>\land</code> ): <img src="https://math.jianshu.com/math?formula=\land" alt="\land"><br>  (<code>\lor</code> ): <img src="https://math.jianshu.com/math?formula=\lor" alt="\lor"><br>  (<code>\lnot</code> ): <img src="https://math.jianshu.com/math?formula=\lnot" alt="\lnot"><br>  (<code>\forall</code> ): <img src="https://math.jianshu.com/math?formula=\forall" alt="\forall"><br>  (<code>\exists</code> ): <img src="https://math.jianshu.com/math?formula=\exists" alt="\exists"><br>  (<code>\top</code> ): <img src="https://math.jianshu.com/math?formula=\top" alt="\top"><br>  (<code>\bot</code> ): <img src="https://math.jianshu.com/math?formula=\bot" alt="\bot"><br>  (<code>\vdash</code> ): <img src="https://math.jianshu.com/math?formula=\vdash" alt="\vdash"><br>  (<code>\vDash</code> ): <img src="https://math.jianshu.com/math?formula=\vDash" alt="\vDash"></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>  (<code>\star</code> ): <img src="https://math.jianshu.com/math?formula=\star" alt="\star"><br>  (<code>\ast</code> ): <img src="https://math.jianshu.com/math?formula=\ast" alt="\ast"><br>  (<code>\oplus</code> ): <img src="https://math.jianshu.com/math?formula=\oplus" alt="\oplus"><br>  (<code>\circ</code> ): <img src="https://math.jianshu.com/math?formula=\circ" alt="\circ"><br>  (<code>\bullet</code> ): <img src="https://math.jianshu.com/math?formula=\bullet" alt="\bullet"></p><h3 id="等于"><a href="#等于" class="headerlink" title="等于"></a>等于</h3><p>  (<code>\approx</code> ): <img src="https://math.jianshu.com/math?formula=\approx" alt="\approx"><br>  (<code>\sim</code> ): <img src="https://math.jianshu.com/math?formula=\sim" alt="\sim"><br>  (<code>\equiv</code> ): <img src="https://math.jianshu.com/math?formula=\equiv" alt="\equiv"><br>  (<code>\prec</code> ): <img src="https://math.jianshu.com/math?formula=\prec" alt="\prec"></p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>  (<code>\infty</code> ): <img src="https://math.jianshu.com/math?formula=\infty" alt="\infty"><br>  (<code>\aleph_o</code> ): <img src="https://math.jianshu.com/math?formula=\aleph_o" alt="\aleph_o"><br>  (<code>\nabla</code> ): <img src="https://math.jianshu.com/math?formula=\nabla" alt="\nabla"><br>  (<code>\Im</code> ): <img src="https://math.jianshu.com/math?formula=\Im" alt="\Im"><br>  (<code>\Re</code> ): <img src="https://math.jianshu.com/math?formula=\Re" alt="\Re"></p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>  (<code>\pmod</code> ): <img src="https://math.jianshu.com/math?formula=b \pmod n" alt="b \pmod n"><br>  如<code>a \equiv b \pmod n</code> : <img src="https://math.jianshu.com/math?formula=a \equiv b \pmod n" alt="a \equiv b \pmod n"></p><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>  (<code>\ldots</code> ): <img src="https://math.jianshu.com/math?formula=\ldots" alt="\ldots"><br>  (<code>\cdots</code> ): <img src="https://math.jianshu.com/math?formula=\cdots" alt="\cdots"><br>  (<code>\cdot</code> ): <img src="https://math.jianshu.com/math?formula=\cdot" alt="\cdot"><br>  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">a_1+a_2+\ldots+a_n \\ </span><br><span class="line">a_1+a_2+\cdots+a_n</span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{equation} a_1%2Ba_2%2B\ldots%2Ba_n \\ a_1%2Ba_2%2B\cdots%2Ba_n \end{equation}" alt="\begin{equation} a_1+a_2+\ldots+a_n \\ a_1+a_2+\cdots+a_n \end{equation}"></p><h2 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a><strong>顶部符号</strong></h2><p>  对于单字符，<code>\hat x</code> ：<img src="https://math.jianshu.com/math?formula=\hat x" alt="\hat x"><br>  多字符可以使用<code>\widehat {xy}</code> ：<img src="https://math.jianshu.com/math?formula=\widehat {xy}" alt="\widehat {xy}"><br>  类似的还有:<br>  (<code>\overline x</code> ): <img src="https://math.jianshu.com/math?formula=\overline x" alt="\overline x"><br>  矢量(<code>\vec</code> ): <img src="https://math.jianshu.com/math?formula=\vec x" alt="\vec x"><br>  向量(<code>\overrightarrow {xy}</code> ): <img src="https://math.jianshu.com/math?formula=\overrightarrow {xy}" alt="\overrightarrow {xy}"><br>  (<code>\dot x</code> ): <img src="https://math.jianshu.com/math?formula=\dot x" alt="\dot x"><br>  (<code>\ddot x</code> ): <img src="https://math.jianshu.com/math?formula=\ddot x" alt="\ddot x"><br>  (<code>\dot {\dot x}</code> ): <img src="https://math.jianshu.com/math?formula=\dot {\dot x}" alt="\dot {\dot x}"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>  使用<code>\begin{array}{列样式}…\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c<span class="params">|lcr&#125;</span></span><br><span class="line"><span class="params">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span></span><br><span class="line"><span class="params">2 &amp; -1 &amp; 189 &amp; -8 \\</span></span><br><span class="line"><span class="params">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span></span><br><span class="line"><span class="params">\<span class="keyword">end</span>&#123;array&#125;</span></span><br><span class="line"><span class="params">$$</span></span><br></pre></td></tr></table></figure><p>  得到：<br><img src="https://math.jianshu.com/math?formula=\begin{array}{c|lcr} n %26 \text{Left} %26 \text{Center} %26 \text{Right} \\ \hline 1 %26 0.24 %26 1 %26 125 \\ 2 %26 -1 %26 189 %26 -8 \\ 3 %26 -20 %26 2000 %26 1%2B10i \\ \end{array}" alt="\begin{array}{c|lcr} n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ 2 &amp; -1 &amp; 189 &amp; -8 \\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\ \end{array}"></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><strong>矩阵</strong></h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>  使用<code>\begin{matrix}…\end{matrix}</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span> &amp; x &amp; x^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; y &amp; y^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; z &amp; z^<span class="number">2</span> \\</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  得到：<br><img src="https://math.jianshu.com/math?formula=\begin{matrix} 1 %26 x %26 x^2 \\ 1 %26 y %26 y^2 \\ 1 %26 z %26 z^2 \\ \end{matrix}" alt="\begin{matrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \end{matrix}"></p><h3 id="括号-1"><a href="#括号-1" class="headerlink" title="括号"></a>括号</h3><p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin{matrix}…\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p><ol><li>pmatrix<code>$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{pmatrix}1 %26 2 \\ 3 %26 4\\ \end{pmatrix}" alt="\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}"></li><li>bmatrix<code>$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{bmatrix}1 %26 2 \\ 3 %26 4\\ \end{bmatrix}" alt="\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}"></li><li>Bmatrix<code>$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{Bmatrix}1 %26 2 \\ 3 %26 4\\ \end{Bmatrix}" alt="\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}"></li><li>vmatrix<code>$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{vmatrix}1 %26 2 \\ 3 %26 4\\ \end{vmatrix}" alt="\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}"></li><li>Vmatrix<code>$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$</code> : <img src="https://math.jianshu.com/math?formula=\begin{Vmatrix}1 %26 2 \\ 3 %26 4\\ \end{Vmatrix}" alt="\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}"></li></ol><h3 id="元素省略"><a href="#元素省略" class="headerlink" title="元素省略"></a>元素省略</h3><p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">begin</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="number">1</span>&amp;a_1&amp;a_1^<span class="number">2</span>&amp;\cdots&amp;a_1^n\\</span><br><span class="line"><span class="number">1</span>&amp;a_2&amp;a_2^<span class="number">2</span>&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line"><span class="number">1</span>&amp;a_m&amp;a_m^<span class="number">2</span>&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\<span class="keyword">end</span>&#123;pmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>  表示：<br><img src="https://math.jianshu.com/math?formula=\begin{pmatrix} 1%26a_1%26a_1^2%26\cdots%26a_1^n\\ 1%26a_2%26a_2^2%26\cdots%26a_2^n\\ \vdots%26\vdots%26\vdots%26\ddots%26\vdots\\ 1%26a_m%26a_m^2%26\cdots%26a_m^n\\ \end{pmatrix}" alt="\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\ 1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\ \end{pmatrix}"></p><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\begin{array} ... \end{array}</code> 来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\<span class="keyword">left</span>[  \begin&#123;array&#125;  &#123;<span class="built_in">c</span> <span class="built_in">c</span> | <span class="built_in">c</span>&#125; %这里的<span class="built_in">c</span>表示数组中元素对其方式：<span class="built_in">c</span>居中、r右对齐、l左对齐，竖线表示<span class="number">2</span>、<span class="number">3</span>列间插入竖线</span><br><span class="line"><span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">3</span> \\</span><br><span class="line">\hline %插入横线，如果去掉\hline就是增广矩阵</span><br><span class="line"><span class="number">4</span> &amp; <span class="number">5</span> &amp; <span class="number">6</span></span><br><span class="line">\end&#123;array&#125;  \<span class="keyword">right</span>]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示为：<br><img src="https://math.jianshu.com/math?formula=\left[ \begin{array} {c c | c} 1 %26 2 %26 3 \\ \hline 4 %26 5 %26 6 \end{array} \right]" alt="\left[ \begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\ \hline 4 &amp; 5 &amp; 6 \end{array} \right]"></p><h2 id="公式标记与引用"><a href="#公式标记与引用" class="headerlink" title="公式标记与引用"></a><strong>公式标记与引用</strong></h2><p>  使用<code>\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code> 在<code>\tag</code> 之后，如<code>$$a = x^2 - y^3 \tag{1}\label{1}$$</code> 显示为：<br><img src="https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \tag{1}\label{311}" alt="a := x^2 - y^3 \tag{1}\label{311}"><br>  如果不需要被引用，只使用<code>\tag{yourtag}</code> ，<code>$$x+y=z\tag{1.1}$$</code>显示为：<br><img src="https://math.jianshu.com/math?formula=x%2By%3Dz\tag{1.1}" alt="x+y=z\tag{1.1}"><br>  <code>\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref{yourlabel}</code> ，如<code>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</code> 显示为：<br><img src="https://math.jianshu.com/math?formula=a %2B y^3 \stackrel{\eqref{1}}%3D x^2" alt="a + y^3 \stackrel{\eqref{1}}= x^2"></p><p>或者使用<code>\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \stackrel{\ref{111}}= x^2$$</code> 显示为:<br><img src="https://math.jianshu.com/math?formula=a %2B y^3 \stackrel{\ref{1}}%3D x^2" alt="a + y^3 \stackrel{\ref{1}}= x^2"></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><h3 id="黑板粗体字"><a href="#黑板粗体字" class="headerlink" title="黑板粗体字"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\mathbb ABCDEF$</code>：<img src="https://math.jianshu.com/math?formula=\mathbb ABCDEF" alt="\mathbb ABCDEF"><br><code>$\Bbb ABCDEF$</code>：<img src="https://math.jianshu.com/math?formula=\Bbb ABCDEF" alt="\Bbb ABCDEF"></p><h3 id="黑体字"><a href="#黑体字" class="headerlink" title="黑体字"></a>黑体字</h3><p><code>$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src="https://math.jianshu.com/math?formula=\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ" alt="\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ"><br><code>$\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img src="https://math.jianshu.com/math?formula=\mathbf abcdefghijklmnopqrstuvwxyz" alt="\mathbf abcdefghijklmnopqrstuvwxyz"></p><h3 id="打印机字体"><a href="#打印机字体" class="headerlink" title="打印机字体"></a>打印机字体</h3><p><code>$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src="https://math.jianshu.com/math?formula=\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ" alt="\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><strong>参考文档</strong></h2><table><thead><tr><th>#</th><th>链接地址</th><th>文档名称</th></tr></thead><tbody><tr><td>1</td><td><code>blog.csdn.net/dabokele/article/details/79577072</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYm9rZWxlL2FydGljbGUvZGV0YWlscy83OTU3NzA3Mg==" title="https://blog.csdn.net/dabokele/article/details/79577072">Mathjax公式教程<i class="fa fa-external-link"></i></span></td></tr><tr><td>2</td><td><code>blog.csdn.net/ethmery/article/details/50670297</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V0aG1lcnkvYXJ0aWNsZS9kZXRhaWxzLzUwNjcwMjk3" title="https://blog.csdn.net/ethmery/article/details/50670297">基本数学公式语法<i class="fa fa-external-link"></i></span></td></tr><tr><td>3</td><td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td><td><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbG9uZ3N5L2FydGljbGUvZGV0YWlscy83OTM3ODYyMA==" title="https://blog.csdn.net/lilongsy/article/details/79378620">常用数学符号的LaTeX表示方法<i class="fa fa-external-link"></i></span></td></tr><tr><td>4</td><td><code>www.mathjax.org</code></td><td><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aGpheC5vcmcv" title="https://www.mathjax.org/">Beautiful math in all browsers<i class="fa fa-external-link"></i></span></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown中公式编辑教程&quot;&gt;&lt;a href=&quot;#Markdown中公式编辑教程&quot; class=&quot;headerlink&quot; title=&quot;Markdown中公式编辑教程&quot;&gt;&lt;/a&gt;Markdown中公式编辑教程&lt;/h1&gt;&lt;h1 id=&quot;markdown中公式编辑教程&quot;&gt;&lt;a href=&quot;#markdown中公式编辑教程&quot; class=&quot;headerlink&quot; title=&quot;markdown中公式编辑教程&quot;&gt;&lt;/a&gt;markdown中公式编辑教程&lt;/h1&gt;&lt;p&gt;标签： Mathjax 公式编辑 markdown&lt;/p&gt;
&lt;p&gt;一般公式分为两种形式，行内公式和行间公式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行内公式：&lt;img src=&quot;https://math.jianshu.com/math?formula=\Gamma(z&quot; alt=&quot;\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.&quot;&gt; %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)&lt;/li&gt;
&lt;li&gt;行间公式：&lt;img src=&quot;https://math.jianshu.com/math?formula=\Gamma(z&quot; alt=&quot;\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.&quot;&gt; %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  对应的代码块为：
    
    </summary>
    
      <category term="开发工具" scheme="http://xiaoman.ren/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Tools" scheme="http://xiaoman.ren/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>协程知识点</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程知识点/</id>
    <published>2021-02-01T12:47:12.926Z</published>
    <updated>2021-02-01T12:47:12.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><ol><li><strong>轻量级的线程</strong>，并不完全是线程</li><li>可以<strong>顺序的写异步代码</strong>， 降低异步编程带来的负担</li><li><strong>更高效</strong>，<strong>多个协程可以公用一个线程</strong>。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的</li><li><strong>运行在协程中的可中断的方法不会阻塞当前线程</strong></li></ol><a id="more"></a><h2 id="可中断的方法（suspending-functions）"><a href="#可中断的方法（suspending-functions）" class="headerlink" title="可中断的方法（suspending functions）"></a>可中断的方法（suspending functions）</h2><p><strong>可中断的方法有能力中断协程的执行</strong>， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = <span class="keyword">suspend</span> &#123; userService.doLogin(username, password)&#125;</span><br><span class="line"><span class="keyword">val</span> currentFriends = <span class="keyword">suspend</span> &#123; userService.requestCurrentFriends(user) &#125;</span><br></pre></td></tr></table></figure><ul><li>可中断方法可以运行在相同或不同的线程，取决于使用方式*</li><li>可中断的方法只能运行在协程中或其它可中断的方法中</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendingFunction</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// do long things</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程上下文（Coroutine-Context）"><a href="#协程上下文（Coroutine-Context）" class="headerlink" title="协程上下文（Coroutine Context）"></a>协程上下文（Coroutine Context）</h2><p><em>协程上下文是一系列规则和配置的集合，它决定了协程的运行方式</em>， 其内部结构是一个列表容器</p><h2 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h2><p><strong>在协程内部</strong>，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendLogin</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>)</span></span>:String = </span><br><span class="line">withContext(Dispatchers.Main) &#123;</span><br><span class="line">    userService.doLogin(username, password)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度器-dispatcher"><a href="#调度器-dispatcher" class="headerlink" title="调度器(dispatcher)"></a>调度器(dispatcher)</h3><ul><li><strong>Default</strong>： 未指定 <code>dispathcer</code> 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程</li><li><strong>IO</strong>：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。</li><li><strong>UnConfined</strong>： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议</li><li><strong>Main</strong>: 这个是 UI 相关的</li></ul><h2 id="协程构造器（Coroutine-Builders）"><a href="#协程构造器（Coroutine-Builders）" class="headerlink" title="协程构造器（Coroutine Builders）"></a>协程构造器（Coroutine Builders）</h2><p>根据实际情况，我们可以选择不同的协程构造器，也可以自己创建</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。</p><p><code>runBolcking</code> 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 <code>runBlocking</code> 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testSuspendedFunction</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> res = suspendingTask1()</span><br><span class="line">    assertEquals(<span class="number">0</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这个场景意外，几乎永不到</p><h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>这个构造器狠重要，因为它可以 <strong>很轻易的创建一个协程</strong>，经常使用。</p><p><code>launch</code> 不会阻塞当前线程（前期是我们使用了合适的 <code>dispatcher</code>）</p><p>这个构造器需要一个作用域（<code>scope</code>）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>launch</code> 方法返回一个 <code>Job</code> ，<code>Job</code>  继承了协程上下文(<code>CoroutineContext</code>)</p><p><code>Job</code> 提供了很多有用的方法，一个 <code>Job</code> 可以有一个父 <code>Job</code>，父 <code>Job</code> 可以控制子 <code>Job</code></p><h4 id="job-join"><a href="#job-join" class="headerlink" title="job.join"></a>job.join</h4><p>这个方法可以中断与当前 <code>Job</code> 关联的协程，直到所有子 <code>Job</code> 执行完成。协程内所有可中断的方法与当前 <code>Job</code> 关联。直到子 <code>Job</code> 全部执行完成，与当前 <code>Job</code> 关联的协程才能继续执行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    doCoroutineTask()</span><br><span class="line">    <span class="keyword">val</span> res1 = suspendingTask1()</span><br><span class="line">    <span class="keyword">val</span> res2 = suspendingTask2()</span><br><span class="line">    process(res1, res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p><code>job.join()</code> 是一个可中断的方法，所以它应该在协程内部被调用。</p><h4 id="job-cancel"><a href="#job-cancel" class="headerlink" title="job.cancel()"></a>job.cancel()</h4><p>取消所有与其关联的子 <code>Job</code> ，加入 <code>suspendingTask1()</code> 正在执行的时候 <code>Job</code> 调用了取消，这个时候 <code>res1</code> 不会再返回， 而且 <code>suspendingTask2()</code> 也不会再执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    doCoroutineTask()</span><br><span class="line">    <span class="keyword">val</span> res1 = suspendingTask1()</span><br><span class="line">    <span class="keyword">val</span> res2 = suspendingTask2()</span><br><span class="line">    process(res1, res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure><p><code>job.cancel</code> 是一个普通方法，不必运行再协程内部</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code> <strong>允许并行地运行多个子线程任务</strong>， 它不是一个可中断方法，当调用 <code>async</code> 启动子协程的同事，后面的代码也会立即执行。 <code>async</code> 通常需要运行再另外一个协程内部，它会返回一个特殊的 <code>Job</code> -&gt; <code>Deferred</code></p><h4 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h4><p><code>Deferred</code> 有一个 <code>await()</code> 函数，它是一个可终端的方法，当需要获取 <code>async</code> 的结果是，需要调用 <code>await()</code> 方法等待。调用后，会中断当前线程，直到其返回结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = withContext(Dispathcers.IO) &#123;userService.doLogin(username, password)&#125;</span><br><span class="line">    <span class="keyword">val</span> currendFriend = async(Dispatchers.IO) &#123;userService.requestCurrentFriends(user) &#125;</span><br><span class="line">    <span class="keyword">val</span> suggestedFriends = async(Dispatchers.IO) &#123; userService.requestSuggestedFriends(user)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> finalUser = user.copy(friends = currenFriends.await() + suggestedFriends.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h3 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h3><p>全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>是否伴随 APP 整个生命周期</li><li>没有界面和组件绑定</li></ul><h3 id="自定义协程作用域"><a href="#自定义协程作用域" class="headerlink" title="自定义协程作用域"></a>自定义协程作用域</h3><p>任何类都可以继承 <code>CoroutineScope</code> 作为一个作用域，唯一需要做的事儿就是去重写 <code>coroutineContext</code> 属性</p><p>需要先明白两个概念 <code>dispathcer</code> 和 <code>Job</code></p><ul><li>dispathcer： 用于指定协程默认使用的 dispatcher</li><li>Job: 用在任何需要的时候取消协程</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>:<span class="type">AppCompatActivity</span></span>(), CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() = Dispatchers.Main + job</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> job: Job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是协程&quot;&gt;&lt;a href=&quot;#什么是协程&quot; class=&quot;headerlink&quot; title=&quot;什么是协程&quot;&gt;&lt;/a&gt;什么是协程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轻量级的线程&lt;/strong&gt;，并不完全是线程&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;顺序的写异步代码&lt;/strong&gt;， 降低异步编程带来的负担&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高效&lt;/strong&gt;，&lt;strong&gt;多个协程可以公用一个线程&lt;/strong&gt;。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行在协程中的可中断的方法不会阻塞当前线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程/</id>
    <published>2021-02-01T12:47:12.925Z</published>
    <updated>2021-02-01T12:47:12.925Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;<span class="comment">// 后台启动一个新的协程并继续， launch 协程的构建器</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 非阻塞的等待1s，</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 延时后，输出 </span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello"</span>) <span class="comment">// 协程已再等待时，主线程还在继续</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// 阻塞主线程 2s 保证， JVM 存活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程是轻量级的线程。 <code>CoroutineScope</code> 通常与 <code>launch</code> 协程构建器一起启动。</p><p><strong>GlobalScope</strong>： 意味着新协程的生命周期与应用程序的生命周期一致</p><p><code>delay</code> 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。</p><a id="more"></a><h2 id="桥接阻塞与非阻塞的世界"><a href="#桥接阻塞与非阻塞的世界" class="headerlink" title="桥接阻塞与非阻塞的世界"></a>桥接阻塞与非阻塞的世界</h2><p>使用<code>runBlocking</code> 协程构建器来阻塞，使用非阻塞函数<code>delay</code> 方便，不易与 <code>Thread.sleep()</code> 阻塞函数混淆</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"hello "</span>)</span><br><span class="line">    runBlocking&#123; <span class="comment">// 这个表达式阻塞了主线程</span></span><br><span class="line">        delay(<span class="number">2000L</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例，只使用了非阻塞函数 <code>delay</code>, 调用 <code>runBlocking</code> 的主线程会一直阻塞，直到 <code>runBlocking</code> 内部的协程执行完毕</p><p>还可以使用 <code>runBlocking</code> 包裹 main 函数来执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello "</span>)</span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runBlicking&lt;Unit&gt; {}</code> 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型</p><h2 id="等待一个作业"><a href="#等待一个作业" class="headerlink" title="等待一个作业"></a>等待一个作业</h2><p>延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// 启动一个新协程并持有这个作业的引用</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"hello "</span>)</span><br><span class="line">job.join()<span class="comment">// 等待直到子协程执行结束</span></span><br></pre></td></tr></table></figure><p>这里主协程与后台作业的持续时间没有任何关系了。</p><h2 id="结构化的并发"><a href="#结构化的并发" class="headerlink" title="结构化的并发"></a>结构化的并发</h2><p>当我们使用 <code>GlobalScope.launch</code> 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 <code>join</code> 很容易出错</p><p>结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 <code>GlobalScope</code> 中启动。</p><p>我们使用<code>runBlocking</code> 协程构建器将 <code>main</code> 函数转化为协程，包括 <code>runBlocking</code> 在内的每个协程构建器都将 <code>CoroutineScope</code> 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 <code>join</code> 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// 在 runBlocking 作用域中启动一个新的协程</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello, "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域构建"><a href="#作用域构建" class="headerlink" title="作用域构建"></a>作用域构建</h2><p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束</p><p><code>runBlocking</code> 与 <code>coroutineScope</code>  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 <code>runBlocking</code> 方法会<strong>阻塞</strong>当前线程来等待，而 <code>coroutineScope</code> 只会挂起，会释放底层线程用于其他用途。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> main = runBlocking &#123; // coroutine scope</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">"Task from runBlocking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123;<span class="comment">// 创建一个作用域协程</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            println(<span class="string">"Task from nested launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">println(<span class="string">"Task from coroutine scope"</span>) <span class="comment">// 这一行会在内嵌 launch 之前输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Coroutine scope is over"</span>)    <span class="comment">// 这一行在内嵌 launch 执行完毕后输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h2><p>当将 <code>launch{}</code> 内部代码块提取到独立的函数体中时，需要 <code>suspend</code>  修饰新函数。这是一个挂起函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;doWorld()&#125;</span><br><span class="line">    println(<span class="string">"hello "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程很轻量"><a href="#协程很轻量" class="headerlink" title="协程很轻量"></a>协程很轻量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> main = runBlocking &#123;</span></span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            println(<span class="string">"."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况</p><h2 id="全局协程像守护线程"><a href="#全局协程像守护线程" class="headerlink" title="全局协程像守护线程"></a>全局协程像守护线程</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt; </span><br><span class="line">println(<span class="string">"I`m sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">                  delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1399L</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GlobalScope.launch &amp;#123;&lt;span class=&quot;comment&quot;&gt;// 后台启动一个新的协程并继续， launch 协程的构建器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(&lt;span class=&quot;number&quot;&gt;1000L&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 非阻塞的等待1s，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;World!&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 延时后，输出 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 协程已再等待时，主线程还在继续&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Thread.sleep(&lt;span class=&quot;number&quot;&gt;2000L&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 阻塞主线程 2s 保证， JVM 存活&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;协程是轻量级的线程。 &lt;code&gt;CoroutineScope&lt;/code&gt; 通常与 &lt;code&gt;launch&lt;/code&gt; 协程构建器一起启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GlobalScope&lt;/strong&gt;： 意味着新协程的生命周期与应用程序的生命周期一致&lt;/p&gt;
&lt;p&gt;&lt;code&gt;delay&lt;/code&gt; 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程调度器</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-调度器/</id>
    <published>2021-02-01T12:47:12.924Z</published>
    <updated>2021-02-01T12:47:12.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/18062676-f99f572eee860a04.jpg" alt="协程调度器"></p><a id="more"></a><ul><li>调度器本质上就是协程上下文的实现</li><li>调度器的作用是用来实现线程的切换</li><li>过度使用线程，同样会造成线程安全问题</li><li>suspendMain 是有一个空的上下文，因此不会产生线程的调度</li><li>系统提供的调度器实现，Default, Main, Unconfined, IO</li></ul><h2 id="协程上下文（CoroutineContext）"><a href="#协程上下文（CoroutineContext）" class="headerlink" title="协程上下文（CoroutineContext）"></a>协程上下文（CoroutineContext）</h2><p>调度器本质上就是协程上下文的实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E: Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>:E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial:  <span class="type">R</span>, operation:(<span class="type">R</span>, Element)</span></span> -&gt; R):R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CorountineContext = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E: Element</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，上下文就是一个以 <code>key</code> 为索引的  <code>List</code> </p><p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code> ， 每一个 <code>Element</code> 都有一个 <code>Key</code> ，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code>  的子接口，因此也可以作为集合出现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedContext</span> </span>(</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> element: Element) : CoroutineContext, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CombinedContext</code> 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的<code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 <code>key</code> 来查找</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch&#123;</span><br><span class="line">        println(coroutineContext[Job]) <span class="comment">// “coroutine#1: StandaloneCoroutine&#123;Active&#125;@1ff5025</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(coroutineContext[Job]) <span class="comment">// null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Key for [job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key: CoroutineContext.Key&lt;Job&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿照<code>Thread.currentThread()</code> 来获取当前 <code>Job</code> 的方法 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Job.Key.<span class="title">currentJob</span><span class="params">()</span></span> = coroutineContext[Job]</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(Job.currentJob())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log(Job.currentJob())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取协程名字</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(CoroutineName(<span class="string">"Hello"</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果有多个上下文，需要添加 <code>+</code> 就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatcher.Main + CoroutineName(<span class="string">"Hello"</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterception</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key: CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，</p><p>协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的<code>Continuation</code>，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。</p><p>我们可以自己定义一个拦截器放到我们协程的上下问中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuationInterceptor</span>: <span class="type">ContinuationInterceptor &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation:<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCOntinuation</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = continuation.context</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result:<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        log(<span class="string">"&lt;MyContinuation&gt;<span class="variable">$result</span>"</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> job = async &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> result = job.await()</span><br><span class="line">        log(<span class="string">"5.<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>launch</code> 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用<code>async</code> 启动了一个协程，<code>async</code> 和 <code>launch</code>从功能上是同等类型的函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果。可以通过 <code>await</code> 方法获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[main] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[main] 1</span><br><span class="line">[main] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[main] 2</span><br><span class="line">[main] 4</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit)</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello)</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 5.Hello</span><br><span class="line">[kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure><p>首先，所有协程启动的时候，都会有一次<code>Continuation.resumeWith</code> 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。</p><p>其次 <code>delay</code> 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。</p><p>最后，正是我们需要的结果。</p><p>而协程真正切换线程的逻辑源自于 <code>delay</code>  在 JVM 上，<code>delay</code> 实际上是一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineDispatcher</span> : <span class="type">AbstractCoroutineContextElement</span></span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调度器本身也是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类<code>AbstracoroutineContextElement</code> 就可以</p><ul><li>Default: 线程池</li><li>Main： UI 线程</li><li>Unconfined：直接执行</li><li>IO：线程池</li></ul><h3 id="UI-相关程序"><a href="#UI-相关程序" class="headerlink" title="UI  相关程序"></a>UI  相关程序</h3><p>Kotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    getUser&#123;user-&gt; &#123;</span><br><span class="line">        handler.post&#123;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>getUser</code> 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 <code>handler.post</code> 切换到 UI 线程。</p><p>过度到协程的写法；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span>= suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt; </span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispathcer.Main) &#123;</span><br><span class="line">        userNameVite.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>suspendCoroutine</strong></p><p>它运行在协程当中，并且帮助我们获取当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方柏霓我们调用它的 <code>resume</code> 和 <code>resumeWithException</code> 来返回结果或者抛出异常</p><p><strong>Dispatchers.Main</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> MainDispatcherLoader &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> dispatcher:MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadMainDispatcher</span><span class="params">()</span></span> :MainCoroutineDispatcher &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> factories = MainDispatcherFactory::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">let</span> </span>&#123;cle -&gt; </span><br><span class="line">ServiceLoader.load(clz, clz.classLoader).toList()</span><br><span class="line">   &#125;</span><br><span class="line">            factories.maxBy&#123;it.loadPriority&#125;?.tryCreateDispatcher(factories) ?: MissingMainCoroutineDispatcher(<span class="literal">null</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            MissingMainCoroutineDispatcher(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 是的 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例。</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/18062676-f99f572eee860a04.jpg&quot; alt=&quot;协程调度器&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程异常处理</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-异常处理/</id>
    <published>2021-02-01T12:47:12.923Z</published>
    <updated>2021-02-01T12:47:12.923Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>协程内部异常处理流程</strong>： </p><p><code>launch</code> 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 <code>CoroutineExceptionHandler</code> 中，如果没有配置，会查找全局（JVM）上的<code>CoroutineExceptionHandler</code> 处理，</p><p> <code>async</code> 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 <code>await</code> 时抛出</p></li><li><p><strong>异常在作用域内传播</strong></p><p>当协程出现异常时，会根据当前作用域触发异常传递</p><p><code>GlobalScope</code> 会创建一个独立的作用域，<strong>自成一派</strong></p><p><code>coroutineScope</code>  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 <code>coroutineScope</code> 整体进行捕获，也可以捕获到该异常，<strong>一损俱损</strong></p><p><code>supervisorScope</code> 子协程的异常不会向上传递， <strong>自作自受</strong><a id="more"></a></p></li><li><p><strong>join</strong> 和 <strong>await</strong></p><p><code>join</code>  只关心是否执行完， <code>await</code> 则关心运行的结果</p><p>因此 <code>join</code> 在协程出现异常时也不会抛出该异常，而 <code>await</code> 则会直接抛出异常；</p><p><strong>Note:</strong> 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 <code>join</code> 时，尽管不会对协程本身的异常进行抛出，但如果 <code>join</code> 调用所在的协程被取消，就会抛出 <em>取消异常</em></p></li></ol><p>当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;continuation-&gt;</span><br><span class="line">getUser(<span class="keyword">object</span>: Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(resume)</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)                                                        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e:Exception) &#123;</span><br><span class="line">        userNameView.text = <span class="string">"Get user error: <span class="variable">$e</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>线程也好，RxJava 也好，都会有全局处理异常的方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler&#123;t: Thread, e: Throwable -&gt;</span><br><span class="line">    <span class="comment">// handle exception here</span></span><br><span class="line">println(<span class="string">"Thread '<span class="subst">$&#123;t.name&#125;</span>' throws an exception with mesage '<span class="subst">$&#123;e.message&#125;</span>'"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava 设置全局异常捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(e-&gt; &#123;</span><br><span class="line">    println(<span class="string">"Throws an exception with message '$&#123;e.message&#125;'"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>协程也可以设置</strong>，类似于通过 <code>Thread.setUnCaughtExceptionHandler</code> 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code> 这样协程内未捕获的异常既可以通过它来捕获</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler&#123; coroutineContext, throwable -&gt; </span><br><span class="line">println(<span class="string">"Throws an exception with message: '<span class="subst">$&#123;throwable.message&#125;</span>'"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithemticException(<span class="string">"Hey!"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConroutineExceptionHandler</code> 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalCoroutineExceptionHandler</span>: <span class="type">CoroutineExceptionHandler &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptinHandler</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context, CoroutineContext, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"coroutine exceptino: <span class="variable">$exception</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>classpath</code> 中创建 <code>META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全名</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.***.***.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure><h2 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h2><h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>当我们启动协程的时候，一直都在用 <code>GlobalScope</code> ，意味着这是要给独立的顶级协程作用域，此外还有<code>coroutineScope{}</code> 及 <code>supervisorScope{}</code></p><ul><li>通过 <code>GlobalScope</code> 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 <code>GlobalScope</code> 启动的协程自成一派</li><li><code>coroutineScope</code> 是继承外部 <code>Job</code> 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，<strong>任何一个子协程异常退出，那么整体都将退出</strong>， <strong>一损俱损</strong> ，同时这也是协程内部再启动子协程的默认作用域</li><li><code>supervisorScope</code> 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着<strong>子协程出现了异常并不会影响父协程以及其他兄弟协程</strong>，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，<strong>自作自受</strong>。<code>supervisorScope</code> 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，<strong>即<code>supervosorScope</code> 只作用其直接子协程</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            launch &#123;</span><br><span class="line">                log(<span class="number">3</span>)</span><br><span class="line">                launch &#123;</span><br><span class="line">                    log(<span class="number">4</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hello"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">                log(<span class="number">7</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="number">8</span>)</span><br><span class="line">                job.join()</span><br><span class="line">                log(<span class="number">9</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(<span class="string">"10 <span class="variable">$e</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">11</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"12 <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">10 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine&#123;Cancelling&#125;@695fd68b</span><br><span class="line">12 java.lang.ArithmeticException: Hello</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>从上面的程序和结果我们可以看出，<strong>10</strong>  这里，我们调用 <code>join</code> 收到了一个取消异常，在协程当中支持取消的操作的 <code>suspend</code> 函数在取消是抛出一个 <code>CancellationException</code>。</p><p>协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 <code>job.join()</code> 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。</p><p>我们将 <code>coroutineScope</code> 换成 <code>supervisorScope</code> ，其他不变</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">Exception in thread "DefaultDispatcher-worker-3" java.lang.ArithmeticException: Hello</span><br><span class="line">at com.hachi.common.GlobalExceptionHandlerKt<span class="formula">$main$</span>2<span class="formula">$1$</span>1.invokeSuspend(GlobalExceptionHandler.kt:69)</span><br><span class="line">at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)</span><br><span class="line">at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class="line">at kotlinx.coroutines.scheduling.CoroutineScheduler.access<span class="formula">$runSafely(CoroutineScheduler.kt:60)</span></span><br><span class="line"><span class="formula">at kotlinx.coroutines.scheduling.CoroutineScheduler$</span>Worker.run(CoroutineScheduler.kt:740)</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。</p><p>我们为内部协程增加啊一个 <code>CoroutineExceptionHandler</code> 就可以证明我们一个结论</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler = CoroutineExceptioHandler &#123;coroutineContext, throwable -&gt; </span><br><span class="line">           log(<span class="string">"<span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class="variable">$throwable</span>"</span>)                                     &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        superisorScope &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            launch(exceptionHandler + CoroutineName(<span class="string">"2"</span>)) &#123;</span><br><span class="line">                log(<span class="number">3</span>)</span><br><span class="line">                launch (exceptionHandler + CoroutineName(<span class="string">"3"</span>))&#123;</span><br><span class="line">                    log(<span class="number">4</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hello"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">                log(<span class="number">7</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="number">8</span>)</span><br><span class="line">                job.join()</span><br><span class="line">                log(<span class="number">9</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(<span class="string">"10 <span class="variable">$e</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">11</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"12 <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">CoroutineName(2) java.lang.ArithmeticException: Hello</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>我们看到，触发<code>CoroutineExceptionHandler</code> 的是协程 2。</p><h3 id="如何使用-scope"><a href="#如何使用-scope" class="headerlink" title="如何使用 scope"></a>如何使用 scope</h3><ul><li>对于没有协程作用域，但需要启动协程的时候，适合用 <strong>GlobalScope</strong></li><li>对于已经由协程作用域的情况，直接用协程启动器启动</li><li>对于明确要求子协程之间互相独立不干扰时，使用 <strong>supervisorScope</strong></li><li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 <code>Job</code> 作用域等概念的支撑，例如 <code>suspernd main</code> ，有限考虑通过 <code>coroutineScope</code> 创建作用域</li></ul><h2 id="join-和-await"><a href="#join-和-await" class="headerlink" title="join 和 await"></a>join 和 await</h2><p>前面的例子一直是用 <code>launch</code> 启动协程常用的还有 <code>async</code>, <code>actor</code> <code>produce</code> 其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获异常出现以后，会抛出。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。</p><h3 id="什么是消费结果"><a href="#什么是消费结果" class="headerlink" title="什么是消费结果"></a>什么是消费结果</h3><p>两组协程启动器，我们可以分别认为是 <em>消费者</em> 和 <em>生产者</em> </p><p>消费者异常立即抛出；生产者只有结果异常时抛出</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a><strong>async 和 await</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> value = deferred.await()</span><br><span class="line">        log(<span class="string">"1. <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"2. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join</code> 则和 <code>await</code> 不同， <code>join</code> 只关心是否执行完，至于为什么完成，它不关心。将上面的 <code>await</code> 替换成 <code>join</code> 后 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. kotlin.Unit</span><br></pre></td></tr></table></figure><p>异常信息被吞掉了，用 <code>launch</code> 替换 <code>async</code> ，<code>join</code> 处仍然不会有任何响应。</p><p><code>launch</code> 中未捕获的异常与 <code>aysync</code> 的处理方式不同， <code>launch</code> 会直接抛出异常给父协程，如果没有父协程或者处于 <code>supervisorScope</code> 中父协程不响应，那么就会交给上下文中执行的 <code>CoroutineExceptionHandler</code> 处理，如果没有指定，那就传给全局的 <code>CoroutineExcetionHandler</code> 等等。而 <code>async</code>  则要等 <code>await</code> 来消费</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;协程内部异常处理流程&lt;/strong&gt;： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;launch&lt;/code&gt; 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; 中，如果没有配置，会查找全局（JVM）上的&lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; 处理，&lt;/p&gt;
&lt;p&gt; &lt;code&gt;async&lt;/code&gt; 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 &lt;code&gt;await&lt;/code&gt; 时抛出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;异常在作用域内传播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当协程出现异常时，会根据当前作用域触发异常传递&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GlobalScope&lt;/code&gt; 会创建一个独立的作用域，&lt;strong&gt;自成一派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutineScope&lt;/code&gt;  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 &lt;code&gt;coroutineScope&lt;/code&gt; 整体进行捕获，也可以捕获到该异常，&lt;strong&gt;一损俱损&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;supervisorScope&lt;/code&gt; 子协程的异常不会向上传递， &lt;strong&gt;自作自受&lt;/strong&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程挂起</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E6%8C%82%E8%B5%B7/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-挂起/</id>
    <published>2021-02-01T12:47:12.923Z</published>
    <updated>2021-02-01T12:47:12.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><ul><li><p>线程: <code>Thread.sleep()</code></p><p><code>sleep</code> 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行</p></li><li><p>协程: <code>delay</code> <a id="more"></a></p><p><code>delay</code> 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 <code>delay</code> 也可以要让协程休眠的一种手段</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123;cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt; </span><br><span class="line">    cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作,可以类比 Android 的 <code>handler.postDealy</code> ,本质上就是设置了一个延时回调,时间一到就调用 <code>resume</code> 方法让协程继续执行</p></li></ul><h2 id="SuspendCancellableCoroutine"><a href="#SuspendCancellableCoroutine" class="headerlink" title="SuspendCancellableCoroutine"></a>SuspendCancellableCoroutine</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!joinInternal()) &#123; <span class="comment">// fast-path no wait</span></span><br><span class="line">        coroutineContext.checkCompletion()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// do not suspend</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joinSuspend() <span class="comment">// slow-path wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">joinSuspend</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers</span></span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class="keyword">this</span>, cont).asHandler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Job.join()</code> 这个方法会先检查调用者 <code>Job</code> 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 <code>joinSuspend</code> 。这里只注册了一个完成时的回调</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public suspend inline fun &lt;T&gt; suspendCancellableCoroutine(crossinline block: (CancellableContinuation&lt;T&gt;)-&gt; Unit):T = suspendCoroutineUninterceptedOrReturn&#123; uCont-&gt;</span><br><span class="line">    <span class="keyword">val</span> cancelable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">    block(cancellable)</span><br><span class="line">    cancellable.getResult()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法帮助我们拿到 <code>Continuation</code> 实例，<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 <code>cancellable.getResult()</code> 的类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult</span><span class="params">()</span></span> :Any? &#123;</span><br><span class="line">    <span class="keyword">if</span>(trySuspend()) <span class="keyword">return</span> COROUTINE_SUSPEND <span class="comment">// 触发挂起逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(state <span class="keyword">is</span> CompletedExceptionally) <span class="comment">// 异常立即抛出</span></span><br><span class="line">    <span class="keyword">throw</span> recoverStackTrce(state.cause, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getSuccessfulResult(state) <span class="comment">// 正常结果立即返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trySuspend()</code> 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。</p><p>然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> vla COROUTINE_SUSPEND: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPEND</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>&#123;CONTINE_SUSPEND, UNDECIDED, RESUMED&#125;</span><br></pre></td></tr></table></figure><p>而 <code>trySuspend()</code> 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。</p><h2 id="深入挂起操作"><a href="#深入挂起操作" class="headerlink" title="深入挂起操作"></a>深入挂起操作</h2><p>真正的挂起是什么？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">        continuation.resume(<span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    CONTROUTINE_SUSPEND</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回这个 <code>COROUTINE_SUSPEND</code></p><h2 id="协程的状态转移"><a href="#协程的状态转移" class="headerlink" title="协程的状态转移"></a>协程的状态转移</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationImpl</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContinuationImpl</span><span class="params">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completion = completion;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object resume = o;</span><br><span class="line">            <span class="keyword">switch</span>(label) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                    LogKt.log(<span class="number">1</span>)</span><br><span class="line">                    result = SuspendFunctionsKt.returnSuspended(<span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span>(isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">2</span>)</span><br><span class="line">                    result = DelayKt.delay(<span class="number">1000</span>, <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span>(isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    LogKt.log(<span class="number">3</span>)</span><br><span class="line">                        result = SuspendedFunctionsKt.returnImmediately(<span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span>(isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completion.resumeWith(Unit.INSTACNE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        completion.resumeWith(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuspended</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，在 Kotlin 的标准库中，有一个 <code>ContinuationImpl</code> 的累，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code> 而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 <code>launch</code> 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code>  的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p></blockquote><p>仿照 <code>runSuspend</code> 类，我们实现一个 completion </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSuspend</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            notifyAll();<span class="comment">// 协程已结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Object result = <span class="keyword">this</span>.result;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="keyword">null</span>) wait();<span class="comment">// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Throwable) result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RunSuspend runSuspend = <span class="keyword">new</span> RunSuspend();</span><br><span class="line">    ContinationImpl table = <span class="keyword">new</span> ContinuationImpl(runSuspend);</span><br><span class="line">    table.resumeWith(Unit.INSTANCE);</span><br><span class="line">    runSuspend.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种写法，简直就是 <code>suspend main</code> 的真是面目。</p></blockquote><p><code>completion</code> 传入的 <code>runSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWith</code> 的最后才被调用，因为它的 <code>await()</code> 一旦进入阻塞状态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Delay&quot;&gt;&lt;a href=&quot;#Delay&quot; class=&quot;headerlink&quot; title=&quot;Delay&quot;&gt;&lt;/a&gt;Delay&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程: &lt;code&gt;Thread.sleep()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sleep&lt;/code&gt; 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程: &lt;code&gt;delay&lt;/code&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程取消</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%8F%96%E6%B6%88/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-取消/</id>
    <published>2021-02-01T12:47:12.922Z</published>
    <updated>2021-02-01T12:47:12.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样</p></blockquote><h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><p>当我们执行一个任务时,很快就后悔了,怎么办?<a id="more"></a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = thread &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e :Exception) &#123;</span><br><span class="line">        log(<span class="string">"interrupted, do cleaning stuff"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.interrupt()</span><br></pre></td></tr></table></figure><p>当线程被标记为中断状态,就会抛出 <code>InterruptedException</code> ,我们可以进行捕获做资源清理.</p><p>所以,所谓的协作式任务种植,协程的取消也是<code>cancel</code>机制的设计思路.</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>= runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = launch&#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job1.cancel()</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delay</code> 与线程中的 <code>sleep</code> 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 <code>delay</code> 还没有回调的时候,协程就被取消了,因为 <code>delay</code> 可以影响取消,因此 <code>delay</code> 后面的代码就不会再次调度,直接抛出一个 <code>CancellationException</code></p><p><strong>完善前面的一个例子</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;continuation -&gt; </span><br><span class="line">getUser(<span class="keyword">object</span>: Callback&lt;User&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailed</span><span class="params">(e:<span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上取消逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation-&gt; </span><br><span class="line"><span class="keyword">val</span> call = OkHttpClient().newCall(...)</span><br><span class="line">    continuation.invokeOnCancellation&#123;</span><br><span class="line">log()</span><br><span class="line">         call.cancel()</span><br><span class="line">&#125;</span><br><span class="line"> call.enqueue(<span class="keyword">object</span> : okhttp3.Callback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">"onFailure: <span class="variable">$e</span>"</span>)</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">"onResponse: <span class="subst">$&#123;response.code()&#125;</span>"</span>)</span><br><span class="line">            response.body()?.let &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    continuation.resume(User.from(it.string()))</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e: Exception) &#123;</span><br><span class="line">                    continuation.resumeWithException(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; ?: continuation.resumeWithException(NullPointerException(<span class="string">"ResponseBody is null"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>suspendCancellableCoroutine</code>  是为了让我们的挂起函数支持协程的取消.该方法将获取到的<code>Continuation</code> 包装成了一个<code>CacncellableContinuation</code> 通过调用 <code>invokeOnCancellation</code> 方法可以设置一个取消时间的回调,一旦被调用,意味着 <code>getUserCoroutine</code> 调用所在的协程将被取消,我们也应该相应的做出取消操作.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserCoroutine()</span><br><span class="line">    log(user)</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayt(<span class="number">10</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job1.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">invokeOnCancellation: cancel the request.</span><br><span class="line">4</span><br><span class="line">onFilure: java.io.IOException: Canceled</span><br></pre></td></tr></table></figure><p>取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用<code>continuation.resume</code> <code>continuation.resumeWithException</code> <code>continuation.resumtWith</code>  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 <code>continuation.resumeWithException(e)</code>  不会有任何副作用.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程的中断&quot;&gt;&lt;a href=&quot;#线程的中断&quot; class=&quot;headerlink&quot; title=&quot;线程的中断&quot;&gt;&lt;/a&gt;线程的中断&lt;/h2&gt;&lt;p&gt;当我们执行一个任务时,很快就后悔了,怎么办?
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程启动</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%90%AF%E5%8A%A8/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-启动/</id>
    <published>2021-02-01T12:47:12.922Z</published>
    <updated>2021-02-01T12:47:12.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程-启动"><a href="#协程-启动" class="headerlink" title="协程-启动"></a>协程-启动</h1><p><strong>启动模式</strong></p><ol><li>DEFAULT： 立即执行</li><li>LAZY： 需要时执行</li><li>ATOMIC： 立即执行，但开始前不会被取消</li><li>UNDISPATCHED： 立即执行，直到第一个 suspend 挂起</li></ol><a id="more"></a><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = <span class="keyword">object</span> : Thread() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run()</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>上面是线程的启动方法，通常还会忘记去写 <code>start()</code> ，那再 kotlin 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread(start = <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//do you wang</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start()</code> 方法是默认被开启自动会执行的，为我们省去了很多麻煩</p><h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">// do you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineStart</span> </span>&#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LAZY,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    ATOMIC，</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    UNDISPATCHED；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>DEFAULT</td><td>立即执行协程体</td></tr><tr><td>ATOMIC</td><td>立即执行协程体，但在开始运行之前无法取消</td></tr><tr><td>UNDISPATCHED</td><td>立即在当前线程执行协程体，直到第一个 suspend 调用</td></tr><tr><td>LAZY</td><td>只有在需要的情况下运行</td></tr></tbody></table><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>四种启动模式中，常用的其实是<code>DEFAULT</code> 和 <code>LAZY</code></p><p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch&#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br><span class="line">[main] 4</span><br></pre></td></tr></table></figure><p>它取决于 CPU 对于当前线程和后台线程的调度顺序</p><h3 id="LAZY"><a href="#LAZY" class="headerlink" title="LAZY"></a>LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。<code>launch</code> 后会返回一个 <code>job</code> 实例，因此我们可以通过 <code>job</code> 来实现</p><ul><li>调用 <code>Job.start()</code> 主动触发协程的调度</li><li>调用 <code>Job.join()</code> 隐式的触发协程的调度</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.start()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>其输出结果可能为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[main] 4</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure><p>运气好话，2 也可能在 4  的前面，而对于 <code>join()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>因为要等待协程执行完毕，因此数据结果一定是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] 1</span><br><span class="line">[main] 3</span><br><span class="line">[DefaultDispatcher-worker-1] 2</span><br><span class="line">[main] 4</span><br></pre></td></tr></table></figure><h3 id="ATOMIC"><a href="#ATOMIC" class="headerlink" title="ATOMIC"></a>ATOMIC</h3><p><code>ATOMIC</code> 只有涉及到 <code>cancel</code> 的时候才有意义， <code>cancel</code> 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 <code>cancel</code> 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们创建写成后立即 <code>cancel</code> 但由于 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说</p><p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时，如果 <code>cancel</code> 就已经调用，那么协程就会被直接 <code>cancel</code> 而不会有任何调度。</p><blockquote><p>需要注意， <code>cancel</code> 调用一定会将 job 的状态设置为 cancelling, 只不过 <code>ATOMIC</code> 模式的协程在启动时无视了这一状态。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p>2 和 3 之间加了一个 <code>delay</code> ，<code>delay</code> 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 <code>ATOMIC</code> 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 <code>suspend</code> 函数，此时程序迎来了第一个挂起点，恰好 <code>delay</code> 是支持 <code>cancel</code> 的，因此后面的 3 将不会打印。</p><h4 id="UNDISPATCHED"><a href="#UNDISPATCHED" class="headerlink" title="UNDISPATCHED"></a>UNDISPATCHED</h4><p>协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 <code>ATOMIC</code> 很像，不同在于 <code>DISPATCHED</code> 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协程-启动&quot;&gt;&lt;a href=&quot;#协程-启动&quot; class=&quot;headerlink&quot; title=&quot;协程-启动&quot;&gt;&lt;/a&gt;协程-启动&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;启动模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DEFAULT： 立即执行&lt;/li&gt;
&lt;li&gt;LAZY： 需要时执行&lt;/li&gt;
&lt;li&gt;ATOMIC： 立即执行，但开始前不会被取消&lt;/li&gt;
&lt;li&gt;UNDISPATCHED： 立即执行，直到第一个 suspend 挂起&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>协程入门</title>
    <link href="http://xiaoman.ren/2021/02/01/Kotlin/%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B-%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaoman.ren/2021/02/01/Kotlin/协程/协程-入门/</id>
    <published>2021-02-01T12:47:12.921Z</published>
    <updated>2021-02-01T12:47:12.921Z</updated>
    
    <content type="html"><![CDATA[<ul><li>协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。</li><li>线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着</li><li>协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。</li><li>协程的三要素：上下文、启动模式、协程体</li><li><p>多个协程可以共用一个线程</p></li><li><p>协程的本质</p><ul><li>协程的挂起函数本质上就是一个回调，回调类型就是<code>Continuation</code></li><li>协程体的执行就是一个<em>状态机</em>，每一次遇到挂起函数，都是一次状态转移</li></ul></li></ul><a id="more"></a><h2 id="通过-Retrofit-请求"><a href="#通过-Retrofit-请求" class="headerlink" title="通过 Retrofit 请求"></a>通过 Retrofit 请求</h2><p>通过 <code>Retrofit</code> 发送一个网络请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login:<span class="type">String</span>)</span></span>:Call&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id:String, <span class="keyword">val</span> name:String, <span class="keyword">val</span> url:String)</span><br></pre></td></tr></table></figure><p><code>Retrofit</code> 初始化如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> githubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retorfit = retrofit2.Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https//api.github.com"</span>)</span><br><span class="line">        .addConverterFacetory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    retrofit.create(GitHUbServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起网络请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">githubServiceApi.getUser(<span class="string">"small"</span>)</span><br><span class="line">.enqueue(<span class="keyword">object</span>: Callback&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        handler.post&#123;showError(t)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        handler.post&#123;</span><br><span class="line">            response.body()?.let(::showUser) ?: showError(NullPointerException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="改造为携程"><a href="#改造为携程" class="headerlink" title="改造为携程"></a>改造为携程</h2><p>对于 <code>Retrofit</code> 改造为协程的方式有两种，分别通过 <code>CallAdapter</code> 和 <code>suspend</code> 函数</p><h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>该方法的本质是让接口的方法返回一个协程的 <code>Job</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span>login:<span class="type">String</span>)</span></span>:Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Deferred 是 Job 的子接口</p></blockquote><p>同时需要为 <code>Retrofit</code> 添加对 <code>Deferred</code> 的支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></span><br></pre></td></tr></table></figure><p>对构造 <code>Retorfit</code> 的实例添加</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> githubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retorfit = retrofit2.Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https//api.github.com"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(CoroutineCallAdapterFactroy())</span><br><span class="line">        .build()</span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的修改，那么我们的请求就可以这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        showUser(githubServiceApi.getUser(<span class="string">"small"</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        shwoError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>  我们首先通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个: 协程上下文、协程启动模式、协程体</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CorountineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">context:<span class="type">CorountineContext</span> = EmptyCouroutineContext,<span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFGAULT, <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CorountineScope</span>.()</span></span> -&gt; UNit <span class="comment">// 协程体</span></span><br><span class="line">) :Job</span><br></pre></td></tr></table></figure><p><strong>启动模式</strong> 不是一个复杂的概念，默认直接俄允许调度执行</p><p><strong>上下文</strong>可以有很多作用，包括<em>携带参数</em>、<em>拦截协程执行</em>等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保<code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己再 <code>launch</code> 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）</p><p>换句话说，在例子当中的整个 <code>launch</code> 内部，你看到的代码都是运行在UI线程中的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 <code>getUser</code> 返回了要给 <code>Deferred</code> 类型，他的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么<code>await</code> 不会阻塞 UI 线程嘛？</p><p>当然不会。不然 <code>Deferred</code> 于 <code>Future</code>  又有上面区别的，这里<code>await</code>  很可疑。因为实际上是要给 <code>suspend</code> 函数。整个函数只能在协程体或者其他 <code>suspend</code> 函数内部被调用，就像是回调的语法糖一样，通过一个叫 <code>Continuation</code> 的接口来实现返回结果<code></code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.3"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context:CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result:<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context:CorouineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是要给回调，有结果正常返回， <code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常。</p><p>因此，请求的代码执行流程本质上是一个异步回调</p><p>而之所以可以看起来是同步的，那就是编译器的黑魔法了</p><p>在虚拟机上 <code>await</code> 函数的真实样子是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object</span><br></pre></td></tr></table></figure><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 这么一个函数，所以前面的代码可以理解为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是正确代码，仅用来理解协程使用</span></span><br><span class="line">GlobalScope.launch(Dispathcers.Main) &#123;</span><br><span class="line">    githubServiceApi.getUser(<span class="string">"small"</span>).await(<span class="keyword">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            showUser(value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            showError(exception)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>await</code> 当中大致就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是正确代码，仅用来理解协程使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">awiat</span><span class="params">(continuation:<span class="type">Continuation</span>&lt;<span class="type">user</span>&gt;)</span></span>:Any&#123;</span><br><span class="line">    ...<span class="comment">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = ....<span class="comment">// 这里执行任务</span></span><br><span class="line">        handler.post &#123;</span><br><span class="line">            continuation.resume(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: Exception) &#123;</span><br><span class="line">        handler.post&#123;continuation.resumeWithException(e)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从运行机制上来讲，协程和回调没有本质的区别</p></blockquote><h3 id="suspend-方式"><a href="#suspend-方式" class="headerlink" title="suspend  方式"></a>suspend  方式</h3><p><code>suspend</code> 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用</p><blockquote><p>Retrofit 在 release 2.5.0 之后才会支持 suspend 函数</p></blockquote><p>首先修改一下接口方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span>login:<span class="type">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure><p>这种情况下， <code>Retrofit</code> 会根据接口方法的生命来构造<code>Continuation</code> ，并且在内部封装了一个 <code>Call</code> 的异步请求(使用 <code>enqueue</code>) ，进而得到 User 实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(githubServiceApi.getUser(<span class="string">"small"</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程到底是什么"><a href="#协程到底是什么" class="headerlink" title="协程到底是什么"></a>协程到底是什么</h2><p>以前我们使用 Java 进行开发的时候，经常会遇到 <em>回调地域</em> ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。</p><p>而 <strong>协程</strong> 可以帮我们优雅的处理掉这些</p><p>协程本身是一个脱离语言实现的概念。简单来说就是：</p><p>协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span>: <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>:<span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下 <strong>Thread</strong> 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。&lt;/li&gt;
&lt;li&gt;线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着&lt;/li&gt;
&lt;li&gt;协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。&lt;/li&gt;
&lt;li&gt;协程的三要素：上下文、启动模式、协程体&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多个协程可以共用一个线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程的本质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协程的挂起函数本质上就是一个回调，回调类型就是&lt;code&gt;Continuation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;协程体的执行就是一个&lt;em&gt;状态机&lt;/em&gt;，每一次遇到挂起函数，都是一次状态转移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="协程" scheme="http://xiaoman.ren/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="Kotlin" scheme="http://xiaoman.ren/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>WorkManager 基础</title>
    <link href="http://xiaoman.ren/2021/02/01/Jetpack/WorkManager%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaoman.ren/2021/02/01/Jetpack/WorkManager 基础/</id>
    <published>2021-02-01T12:47:12.920Z</published>
    <updated>2021-02-01T12:47:12.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><code>WorkManager</code> 是要给 API,  可让您轻松的调度那些<strong>即使在退出应用或重启设备后仍可运行的可延期异步任务。</strong>也就是说，只要是我们创建好了一个后台任务，交给 <code>WorkManager</code> 后，系统会保证它一定被执行。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>先来看一下 <code>WorkManager</code> 是如何使用的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>.requireContext())</span><br><span class="line">.beginWith(listOf(workA, workB))</span><br><span class="line">.then(workC).enqueue()</span><br></pre></td></tr></table></figure><p>这是一个最复杂的调用结构，基本上也是我们使用 <code>WorkManager</code> 最复杂的情况。</p><p>对于每项工作任务，我们都可以定义工作的输入和输出。并将工作串联在一起，<code>WorkManager</code> 会自动将输出从要给工作任务传递到下一个任务。</p><blockquote><p> Note: WorkManager 适用于 <strong>可延期</strong> 工作，即不需要立即运行，但需要可靠执行的工作。即使退出应用或设备重启也不影响工作的执行。比如： </p><ul><li>向后端服务发送日志或分析数据</li><li>定期将应用数据与服务器同步</li></ul></blockquote><h3 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h3><h4 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h4><p>先添加依赖库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime-ktx:2.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h4><p>使用 <code>Worker</code> 类定义，实现 <code>doWork()</code> 函数，为 <code>WorkManager</code> 提供的后台线程异步运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkA</span></span>(appContext:Context, workerParams: WorkerParameters): Worker(appContext, workerParams) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Do the work here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>doWork()</code> 返回的 <code>Result</code> 会通知 <code>WorkManager</code> 服务工作是否成功，以及工作失败时是否应重试工作</p><ul><li>Result.success():  work 成功完成</li><li>Result.failure(): work 失败</li><li>Result.retry(): work 失败，根据重试策略在其他时间尝试</li></ul><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="WorkRequest"><a href="#WorkRequest" class="headerlink" title="WorkRequest"></a>WorkRequest</h4><p>定义好任务后，我们需要使用 <code>WorkManager</code> 服务进行调度该工作才可以运行。<code>WorkManager</code> 提供了两种方式，为我们安排任务的执行。<strong>周期任务</strong>  和 <strong>一次性任务</strong></p><p>不论我们选择何种方式调度，都始终使用的时 <code>WorkRequest</code>。 <code>Worker</code> 定义工作单元， <code>WorkRequest(及子类)</code> 规定工作方式和时间， <code>WorkManager</code> 负责执行和调度。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> workRequest: WorkRequest = OneTimeWorkRequestBuilder&lt;WorkerA&gt;().build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(mContext)</span><br><span class="line">.enqueue(workRequest)</span><br></pre></td></tr></table></figure><p>任务的执行时间，取决于 <code>WorkRequest</code> 中使用的约束和系统优化方案。</p><h5 id="如何定义和自定义-WorkRequest"><a href="#如何定义和自定义-WorkRequest" class="headerlink" title="如何定义和自定义 WorkRequest"></a><strong>如何定义和自定义 <code>WorkRequest</code></strong></h5><ul><li>调度一次性工作和重复工作</li><li>设置工作约束条件，例如要求连接到 Wi-Fi 网络或者充电</li><li>确保至少延时一定时间在执行</li><li>设置重试和退避策略</li><li>将输入数据传递给 Worker</li><li>使用标记将相关工作分组在一起</li></ul><p><code>Worker</code> 通过 <code>WorkRequest</code> 在 <code>WorkManager</code> 中进行定义。为使 <code>WorkManager</code> 调度任何工作，必须创建一个 <code>WorkRequest</code> 对象，并加入到执行队列</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mWorkRequest: WorkRequst </span><br><span class="line">WorkManager.getInstance(mContext).enqueue(mWorkRequest)</span><br></pre></td></tr></table></figure><h5 id="一次性任务"><a href="#一次性任务" class="headerlink" title="一次性任务"></a>一次性任务</h5><p>对于无需额外配置的简单工作，可使用静态方法 <code>from</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mWorkRequest = OneTimeWorkRequest.from(MyWork::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><p>对于复杂的工作，可使用构建器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mWorkRequst = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line"><span class="comment">// 设置约束条件</span></span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><h5 id="周期性任务"><a href="#周期性任务" class="headerlink" title="周期性任务"></a>周期性任务</h5><p>可能我们需要定期备份数据，定期下载应用中的新鲜内容或者定期上传日志到服务器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> saveRequest = PeriodicWorkRequestBuilder&lt;SaveImageToFileWork&gt;(<span class="number">1</span>, TimUnit.HOURS)</span><br><span class="line"><span class="comment">// 设置约束条件</span></span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>时间间隔定义为两次重复执行之间的最短时间，工作器的确切执行时间取决于您在 <code>WorkRequest</code> 对象中设置的约束及系统执行的优化。</p><p>值得注意的是，最短的重复间隔为 15 分钟，即使我们设置了一个小于 15 分钟的时间，那么系统也会默认帮我们修改为 15 分钟。系统考虑到对电量的优化给予我们的配置。</p><h5 id="灵活的周期性任务"><a href="#灵活的周期性任务" class="headerlink" title="灵活的周期性任务"></a>灵活的周期性任务</h5><p>灵活的重复任务是对周期性任务的扩展，其特点是要我们对 <code>Worker</code> 的运行时间比较敏感的情况。我们可以将 <code>PeriodicWorkRequest</code> 配置为在每个时间间隔的 <strong>灵活时间段</strong> 内运行</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/definework-flex-period.png" alt="PeriodicWork RepatInterval"></p><p>如图，我们定义了具有灵活时间段的定期任务，需要在创建 <code>PeriodicWorkRequest</code>  时传递 <code>flexInterval</code> 和 <code>repeatInterval</code> 。灵活时间段从 <code>repeatInterval - flexInterval</code> 开始，一直到间隔结束</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置每小时的最后 15 分钟内运行的周期任务</span></span><br><span class="line"><span class="keyword">val</span> myUploadWork = PeriodicWorkRequestBuilder&lt;SaveImageToFileWOrk&gt; (</span><br><span class="line"><span class="number">1</span>, TimeUnit.HOURS, <span class="comment">// repeatInterval</span></span><br><span class="line">    <span class="number">15</span>, TimeUnit.MINUTES <span class="comment">// flexInterval</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束可以确保将工作延迟到满足最佳条件时运行。</p><ul><li>NetworkType: 约束隐形 Wroker 所需的网络类型，如 WiFi</li><li>BatteryNotLow：设置为 true， 表示当设备处于 “电量不足模式”时，Worker 不会运行</li><li>RequiresCharging：设置为 true，表示只能在充电状态下运行</li><li>Deviceldle：设置为 true，表示用户的设备必须处于空闲状态，才能工作。如果要运行批量操作，二则可能会降低用户设备上正在运行的应用性能。</li><li>StorageNotLow： 设置为 true，那么当用户设备上的存储空间不足时，不会工作。</li></ul><h5 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">.setRequiredNetworkType(NetworkType.UNMETERED)</span><br><span class="line">.setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">.build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">.setConstraints(constraints)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><blockquote><p>如果指定了多个约束，Work 将仅在所有约束同时满足时才会工作</p><p>如果 Worker 在运行时不满足某个约束， WorkManager 将停止工作器。系统将在满足所有约束后重试 Worker</p></blockquote><h5 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h5><p>如果没有添加约束，或者当其加入到队列是，所有约束都满足，系统就会选择立即执行该 Worker, 如果我们不希望他立即执行，可以将任务设置为在经过一段初始时间后再执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">.setInitialDelay(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><h4 id="重试和退避策略"><a href="#重试和退避策略" class="headerlink" title="重试和退避策略"></a>重试和退避策略</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">   .setBackoffCriteria(</span><br><span class="line">       BackoffPolicy.LINEAR,</span><br><span class="line">       OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">       TimeUnit.MILLISECONDS)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure><p>如需要重试，可以让 <code>doWork()</code> 返回 <code>Result.retry()</code> </p><h4 id="入参数据"><a href="#入参数据" class="headerlink" title="入参数据"></a>入参数据</h4><p>当任务需要输入数据才能运行时，例如处理图片上传需要图片的 URI 作为输入数据。</p><p>输入数据以键值对的形式存储再 <code>Data</code> 对象中。Worker 可以通过 <code>Worker.getInputData()</code> 访问输入参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define the Worker requiring input</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWork</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">   : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">       <span class="keyword">val</span> imageUriInput =</span><br><span class="line">           inputData.getString(<span class="string">"IMAGE_URI"</span>) ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line"></span><br><span class="line">       uploadFile(imageUriInput)</span><br><span class="line">       <span class="keyword">return</span> Result.success()</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a WorkRequest for your Worker and sending it input</span></span><br><span class="line"><span class="keyword">val</span> myUploadWork = OneTimeWorkRequestBuilder&lt;UploadWork&gt;()</span><br><span class="line">   .setInputData(workDataOf(</span><br><span class="line">       <span class="string">"IMAGE_URI"</span> to <span class="string">"http://..."</span></span><br><span class="line">   ))</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><h4 id="一次性工作状态"><a href="#一次性工作状态" class="headerlink" title="一次性工作状态"></a>一次性工作状态</h4><p>初始态为 <code>ENQUEUED</code>, 在 <code>ENQUEUED</code> 下，当满足约束条件和初始延时要求后立即运行，转换为 <code>RUNNING</code> 状态，然后根据结果可转换为 <code>SUCCESSED</code>,<code>FAILED</code> 如果结果时 <code>retry</code>  可能会回到 <code>ENQUEUED</code>，随时可以取消进入 <code>CANCELLED</code> 状态</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/one-time-work-flow.png" alt="一次性任务状态流转"></p><p><code>SUCCESSED, FAILED, CANCELLED</code> 均表示 <code>Worker</code> 的终止状态， <code>WorkInfo.State.isFinished()</code> 都会返回 true。</p><h4 id="周期性任务工作状态"><a href="#周期性任务工作状态" class="headerlink" title="周期性任务工作状态"></a>周期性任务工作状态</h4><p>成功和失败仅时用于一次性和链式工作。周期性任务只有一个终止状态 <code>CANCELLED</code>。 这是因为周期任务永远不会结束。每次运行后，无论结果如何，都会重新对其进行调度。</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/periodic-work-states.png" alt></p><h3 id="管理工作"><a href="#管理工作" class="headerlink" title="管理工作"></a>管理工作</h3><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h4><ul><li><code>WorkManager.enqueueUniqueWork()</code>（用于一次性工作）</li><li><code>WorkManager.enqueueUniquePeriodicWork()</code> (用于周期工作）</li></ul><p>这两个方法接收 3 个参数</p><ul><li><code>uniqueWorkName</code>: 唯一标识工作请求的 <code>String</code></li><li><code>existingWorkPolicy</code>: 此 <code>enum</code> 可告知 WorkManager：如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sendLogsWorkRequest =</span><br><span class="line">       PeriodicWorkRequestBuilder&lt;SendLogsWorker&gt;(<span class="number">24</span>, TimeUnit.HOURS)</span><br><span class="line">           .setConstraints(Constraints.Builder()</span><br><span class="line">               .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">               .build()</span><br><span class="line">            )</span><br><span class="line">           .build()</span><br><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).enqueueUniquePeriodicWork(</span><br><span class="line">           <span class="string">"sendLogs"</span>,</span><br><span class="line">           ExistingPeriodicWorkPolicy.KEEP,</span><br><span class="line">           sendLogsWorkRequest</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="冲突解决策略"><a href="#冲突解决策略" class="headerlink" title="冲突解决策略"></a>冲突解决策略</h4><p>调用唯一工作是，必须告知 <code>WorkManager</code> 在发生冲突是要执行的操作。可以通过将工作加入到队列时传入一个枚举 <code>ExistingWorkPolicy</code> 和 <code>ExistingPeriodicWorkPolicy</code> 来实现</p><ul><li><p>REPLACE ：用新的任务替换现有任务。现有任务将取消</p></li><li><p>KEEP： 保留现有任务，丢弃新任务</p></li><li>APPEND：将新任务附加到现有任务的末尾，形成链式调用。新任务的执行条件取决于现有任务的状态</li><li>APPEND_OR_REPLACE：类似于 APPEND ，不过不依赖现有任务的工作状态。</li></ul><h4 id="获取状态"><a href="#获取状态" class="headerlink" title="获取状态"></a>获取状态</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WorkInfo 可通过 id，name，Tag 等方式获取，</span></span><br><span class="line">workManager.getWorkInfoByIdLiveData(syncWorker.id)</span><br><span class="line">               .observe(viewLifecycleOwner) &#123; workInfo -&gt;</span><br><span class="line">   <span class="keyword">if</span>(workInfo?.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line">       Snackbar.make(requireView(),</span><br><span class="line">      R.string.work_completed, Snackbar.LENGTH_SHORT)</span><br><span class="line">           .show()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察任务进度"><a href="#观察任务进度" class="headerlink" title="观察任务进度"></a>观察任务进度</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// requestId is the WorkRequest id</span></span><br><span class="line">    .getWorkInfoByIdLiveData(requestId)</span><br><span class="line">    .observe(observer, Observer &#123; workInfo: WorkInfo? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> progress = workInfo.progress</span><br><span class="line">                <span class="keyword">val</span> value = progress.getInt(Progress, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// Do something with progress information</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;&lt;code&gt;WorkManager&lt;/code&gt; 是要给 API,  可让您轻松的调度那些&lt;strong&gt;即使在退出应用或重启设备后仍可运行的可延期异步任务。&lt;/strong&gt;也就是说，只要是我们创建好了一个后台任务，交给 &lt;code&gt;WorkManager&lt;/code&gt; 后，系统会保证它一定被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="WorkManager" scheme="http://xiaoman.ren/categories/WorkManager/"/>
    
    
      <category term="Jetpack" scheme="http://xiaoman.ren/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Lifecycle</title>
    <link href="http://xiaoman.ren/2021/02/01/Jetpack/Lifecycle%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2021/02/01/Jetpack/Lifecycle 源码分析/</id>
    <published>2021-02-01T12:47:12.919Z</published>
    <updated>2021-02-01T12:47:12.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始是废话（翻译自源码）"><a href="#开始是废话（翻译自源码）" class="headerlink" title="开始是废话（翻译自源码）"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 </span></span><br><span class="line">Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME</span><br><span class="line"><span class="comment">// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。</span></span><br><span class="line">Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY</span><br></pre></td></tr></table></figure><p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">DefaultLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStopped</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_CREATE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreated</span><span class="params">(LifecycleOwner source)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(ON_ANY)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onAny</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p><h2 id="那我能做什么呢"><a href="#那我能做什么呢" class="headerlink" title="那我能做什么呢"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p><p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p><p>干货~~~来了</p><p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p><p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Lifecycle-UML"><a href="#Lifecycle-UML" class="headerlink" title="Lifecycle UML"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true" alt="Lifecycle UML"></p><p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p><p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p><h3 id="ComponentActivity-amp-ReportFragment"><a href="#ComponentActivity-amp-ReportFragment" class="headerlink" title="ComponentActivity &amp; ReportFragment"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleOwner 接口，提供了一个 getLifecycle() 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComponentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lifecycle lifecycle = getLifecycle();</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"getLifecycle() returned null in ComponentActivity's "</span></span><br><span class="line">                                        + <span class="string">"constructor. Please make sure you are lazily constructing your Lifecycle "</span></span><br><span class="line">                                        + <span class="string">"in the first call to getLifecycle() rather than relying on field "</span></span><br><span class="line">                                        + <span class="string">"initialization."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">                    Window window = getWindow();</span><br><span class="line">                    <span class="keyword">final</span> View decor = window != <span class="keyword">null</span> ? window.peekDecorView() : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (decor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        decor.cancelPendingInputEvents();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">19</span> &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= <span class="number">23</span>) &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> ImmLeaksCleaner(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p><p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If your ComponentActivity is annotated with &#123;<span class="doctag">@link</span> ContentView&#125;, this will</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> #setContentView(int)&#125; for you.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">        setContentView(mContentLayoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p><p>别慌，进去看。</p><h4 id="ReportFragment"><a href="#ReportFragment" class="headerlink" title="ReportFragment"></a><code>ReportFragment</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">    <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p><p>按照 <code>Fragment</code> 的生命周期，我们继续看</p><h5 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a><code>dispatch()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatchStart(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatchResume(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">    mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p><h5 id="handleLifecycleEvent"><a href="#handleLifecycleEvent" class="headerlink" title="handleLifecycleEvent()"></a><code>handleLifecycleEvent()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p><p>你跑，那我就追！</p><h3 id="LifecycleRegister"><a href="#LifecycleRegister" class="headerlink" title="LifecycleRegister"></a><strong><code>LifecycleRegister</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current state and notifies the observers.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that if the &#123;<span class="doctag">@code</span> currentState&#125; is the same state as the last call to this method,</span></span><br><span class="line"><span class="comment">     * calling this method has no effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event The event that was received</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法，我们翻译下注释</p><blockquote><p>设置当前状态，并通知观察者</p><p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p></blockquote><h4 id="getStateAfter"><a href="#getStateAfter" class="headerlink" title="getStateAfter()"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p><p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync()"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">    <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"><span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line"><span class="comment">// so it doesn't have to take in account parents</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"LifecycleOwner of this LifecycleRegistry is already"</span></span><br><span class="line">                                        + <span class="string">"garbage collected. It is too late to change lifecycle state."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p><p>继续分析源码</p><p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p><p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p><h4 id="Lifecycle-State-Sequence"><a href="#Lifecycle-State-Sequence" class="headerlink" title="Lifecycle State Sequence"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_STOP;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">           <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">           <span class="keyword">case</span> DESTROYED:</span><br><span class="line">               <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">           <span class="keyword">case</span> CREATED:</span><br><span class="line">               <span class="keyword">return</span> ON_START;</span><br><span class="line">           <span class="keyword">case</span> STARTED:</span><br><span class="line">               <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">           <span class="keyword">case</span> RESUMED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true" alt="Lifecycle State Sequence"></p><p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p><h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a><code>dispatchEvent</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">        mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">        mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            Event event = downEvent(observer.mState);</span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p><p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p><h4 id="ReflectiveGenericLifecycleObserver"><a href="#ReflectiveGenericLifecycleObserver" class="headerlink" title="ReflectiveGenericLifecycleObserver"></a><code>ReflectiveGenericLifecycleObserver</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An internal implementation of &#123;<span class="doctag">@link</span> LifecycleObserver&#125; that relies on reflection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p><p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p><p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p><p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p><p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p><h4 id="reflect-invoke-method"><a href="#reflect-invoke-method" class="headerlink" title="reflect invoke method"></a><code>reflect invoke method</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">                mMethod.invoke(target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">                mMethod.invoke(target, source);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                mMethod.invoke(target, source, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to call observer method"</span>, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p><p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p><p>但是！！！！！！！！！！！！！！！！</p><p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p><h4 id="addObserver"><a href="#addObserver" class="headerlink" title="addObserver()"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p><p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p><p>我们这里要逐行清点</p><p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p><p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p><p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p><p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p><p>总结一下，分析源码我们从两方面入手</p><ol><li><p><code>addObserver()</code></p><p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p><ol><li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li><li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li><li>立即进行状态判断，决定是否处理生命周期变化</li></ol></li><li><p><code>ReportFragment</code></p><p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p></li><li><p><strong>反射</strong></p><p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p></li><li><p><code>sync()</code></p><p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;a href=&quot;#开始是废话（翻译自源码）&quot; class=&quot;headerlink&quot; title=&quot;开始是废话（翻译自源码）&quot;&gt;&lt;/a&gt;开始是废话（翻译自源码）&lt;/h2&gt;&lt;p&gt;定义了一个 Android 生命周期的对象。 &lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;FragmentActivity&lt;/code&gt;类实现&lt;code&gt;LifecycleOwner&lt;/code&gt;接口， 并可以通过 &lt;code&gt;getLifecycle()&lt;/code&gt; 方法来访问生命周期。 我们也可以实现&lt;code&gt;LifecycleOwner&lt;/code&gt;在自己的类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 架构组件</title>
    <link href="http://xiaoman.ren/2021/02/01/Jetpack/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6/"/>
    <id>http://xiaoman.ren/2021/02/01/Jetpack/Android架构组件/</id>
    <published>2021-02-01T12:47:12.918Z</published>
    <updated>2021-02-01T12:47:12.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用架构指南"><a href="#应用架构指南" class="headerlink" title="应用架构指南"></a>应用架构指南</h2><ul><li>当您在自己喜欢的社交网络应用中分享照片时会发生什么：<ol><li>该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的</li><li>相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用</li><li>最后，用户返回社交网络应用并分享照片</li></ol></li></ul><p>此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。</p><a id="more"></a><p>移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间</p><p>因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖</p><h2 id="常见架构原则"><a href="#常见架构原则" class="headerlink" title="常见架构原则"></a>常见架构原则</h2><h3 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h3><p>常见错误是再 <code>activity</code> 和 <code>fragment</code> 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题</p><h3 id="通过模型驱动界面"><a href="#通过模型驱动界面" class="headerlink" title="通过模型驱动界面"></a>通过模型驱动界面</h3><p>通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。</p><p>持久性是思想之选，原因如下:</p><pre><code>1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据2. 当网络连接不稳定或不可用时，应用会继续工作</code></pre><p>应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。</p><h2 id="推荐应用架构"><a href="#推荐应用架构" class="headerlink" title="推荐应用架构"></a>推荐应用架构</h2><p><img src="https://developer.android.com/topic/libraries/architecture/images/final-architecture.png" alt="img"></p><p>每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。</p><p>这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。</p><h2 id="构建界面"><a href="#构建界面" class="headerlink" title="构建界面"></a>构建界面</h2><p>界面由Fragment <code>UserProfileFragment</code> 及其对应的布局文件 <code>user_profile_layout.xml</code> 组成</p><p>如需驱动该界面，数据模型需要存储以下数据元素</p><ul><li>用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。</li><li>用户对象：用于存储用户详细信息的数据类</li></ul><blockquote><p>ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响</p></blockquote><ul><li><code>user_profile.xml</code> : 屏幕的界面布局</li><li><code>UserProfileFragment</code>：显示数据的界面控制器</li><li><code>UserProfileViewModel</code> : 准备数据以便再 <code>UserProfileFragment</code> 中查看并对用户互动做出响应的类</li></ul><p><strong>UserProfileViewModel</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span>: <span class="type">ViewModel</span></span>()&#123;</span><br><span class="line"><span class="keyword">val</span> userId:String = TODO()</span><br><span class="line">    <span class="keyword">val</span> user: User = TODO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserProfileFragment</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileFragment</span>: <span class="type">Fragment</span></span>()&#123;</span><br><span class="line">    <span class="comment">// 使用 ViewModels() 拓展函数，以及 "androidx.fragment:fragment-ktx:lastest-version" 在 模块下的 build.gradle </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: UserProfileViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.infalte(R.layout.main_fragment, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，由了这些代码块，需要将他们串联起来，毕竟在 <code>UserProfileViewModel</code> 类中设置 <code>user</code> 字段时，我们需要一种方法来通知界面</p><p>要获取 <code>user</code> 我们的 <code>ViewModel</code> 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 <code>SaveState</code> 模块，我们可以让 View Model 直接读取参数</p><blockquote><p>SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserProfileViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> </span>(savedStatedHandle: SavedStateHandle) :ViewModel()&#123;</span><br><span class="line">    <span class="keyword">val</span> userId:String = savedStateHandle[<span class="string">"uid"</span>] ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"missing user id"</span>)</span><br><span class="line">    <span class="keyword">val</span> user: User = TODO()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserProfileFragment</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: UserProfileViewModel <span class="keyword">by</span> viewModels(</span><br><span class="line">    factoryProducer = &#123;SavedStateVMFactory(<span class="keyword">this</span>)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用架构指南&quot;&gt;&lt;a href=&quot;#应用架构指南&quot; class=&quot;headerlink&quot; title=&quot;应用架构指南&quot;&gt;&lt;/a&gt;应用架构指南&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当您在自己喜欢的社交网络应用中分享照片时会发生什么：&lt;ol&gt;
&lt;li&gt;该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的&lt;/li&gt;
&lt;li&gt;相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用&lt;/li&gt;
&lt;li&gt;最后，用户返回社交网络应用并分享照片&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Data Binding</title>
    <link href="http://xiaoman.ren/2021/02/01/Jetpack/Data%20Binding/"/>
    <id>http://xiaoman.ren/2021/02/01/Jetpack/Data Binding/</id>
    <published>2021-02-01T12:47:12.918Z</published>
    <updated>2021-02-01T12:47:12.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="布局和绑定表达式"><a href="#布局和绑定表达式" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。</p><a id="more"></a><p>该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 <code>data</code> 元素（界面布局根元素的同级）内定义。这两个元素都封装在 <code>layout</code> 标记中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://scheams.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">name</span>=<span class="string">"viewModel"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- UI layout`s root element--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用可观察的数据对象"><a href="#使用可观察的数据对象" class="headerlink" title="使用可观察的数据对象"></a>使用可观察的数据对象</h3><p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。</p><h3 id="生成的绑定类"><a href="#生成的绑定类" class="headerlink" title="生成的绑定类"></a>生成的绑定类</h3><p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p><h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><p>每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 <code>setText()</code> 方法来设置文本属性，或者调用 <code>setOnClickListener()</code> 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 <code>android:text</code> 属性）可供您在 <code>android.databinding.adapters</code> 软件包中使用。也可以自定义适配器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:goneUnless"</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">goneUnless</span><span class="params">(view: <span class="type">View</span>, visiable: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    view.visibility = <span class="keyword">if</span> (visiable) View.VISIABLE <span class="keyword">else</span> View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新</p><!-- more --><h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>要开始使用数据绑定，从 Android SDK 管理器中的 <strong>支持代码库</strong> 下载。要将应用配置为使用配置绑定，需要在应用模块的 <code>build.gradle</code> 文件中添加 <code>databinding</code> 元素</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    ...</span><br><span class="line">        dataBinding&#123;</span><br><span class="line">            enabled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定</p></blockquote><h3 id="布局和绑定表达式-1"><a href="#布局和绑定表达式-1" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。</p><p>数据绑定布局文件略有不同，以根标记<code>layout</code> 开头，后跟 <code>data</code> 和 <code>view</code> 根元素。此视图元素是非绑定布局文件的根</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encodeing="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://scheams.android.comapk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"@&#123;user.fiestName&#125;"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"warp_content"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>data</code> 中的 <code>user</code> 变量描述了可在此布局中使用的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>布局中的表达式使用了 <code>@{}</code> 语法写入特性属性中，在这里， <code>TextView</code> 文本被设置为 <code>user.fistName</code> 和 <code>user.lastName</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"warp_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"warp_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> firstName:String, <span class="keyword">val</span> lastName: String)</span><br></pre></td></tr></table></figure><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 <code>activity_main.xml</code> ,因此生成的对应类为 <code>ActivityMainBinding</code>。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">    </span><br><span class="line">    binding.user= User(<span class="string">'Test'</span>, <span class="string">"User"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 <strong>LayoutInflater</strong> 获取视图，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding= ActivityMainBinding.inflate(getLayoutInflater())</span><br></pre></td></tr></table></figure><p>如果需要再 <code>Fragment</code> <code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或 <code>DataBindingUtil</code> 类的 <code>inflate()</code> 方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h3><table><thead><tr><th>名称</th><th>符号</th></tr></thead><tbody><tr><td>算数运算符</td><td>+, -, /, *, %</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;, \</td><td>\</td><td></td></tr><tr><td>二元运算符</td><td>&amp;, \</td><td>, ^</td></tr><tr><td>一元运算符</td><td>+, -, !, ~</td></tr><tr><td>移位运算符</td><td>&gt;&gt; , &lt;&lt;, &gt;&gt;&gt;</td></tr><tr><td>比较运算符</td><td>==, &gt;, &lt;(需要转义为’&amp;lt ;’), &gt;=, &lt;=</td></tr><tr><td></td><td>instanceof</td></tr><tr><td>分组运算符</td><td>()</td></tr><tr><td>字面运算符</td><td>字符，字符串，数字， null</td></tr><tr><td>类型转换</td><td></td></tr><tr><td>方法调用</td><td></td></tr><tr><td>字段访问</td><td></td></tr><tr><td>数组访问</td><td>[]</td></tr><tr><td>三元运算符</td><td>?:</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;String.valueOf(index+1)&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:visibility</span>=<span class="string">"@&#123;age &gt; 13 ? View.GONE : View.VISIBLE&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:transitionName</span>=<span class="string">"@&#123;"</span><span class="attr">image_</span>"+<span class="attr">id</span>&#125;"</span></span><br></pre></td></tr></table></figure><h3 id="Null-合并运算符"><a href="#Null-合并运算符" class="headerlink" title="Null 合并运算符"></a>Null 合并运算符</h3><blockquote><p>如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="视图引用"><a href="#视图引用" class="headerlink" title="视图引用"></a>视图引用</h3><p>表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/example_text"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/example_output"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;exampleText.text&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>可以使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、Hash 列表、和映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.util.SparseArray"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.Map"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">type</span>=<span class="string">"List$lt;String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"sparse"</span> <span class="attr">type</span>=<span class="string">"Sparse$lt;String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Map$lt;&lt;String, String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>android:text=”@{list[index]}”<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>android:text=”@{map[key]}”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 资源</span><br><span class="line"></span><br><span class="line">表达式可以使用一下语法引用资源</span><br></pre></td></tr></table></figure></p><p>android:padding=”@{large?@dimen/largePadding : @dimen/smallPadding}”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">某些资源需要显示类型求值</span><br><span class="line"></span><br><span class="line">| 类型              | 常规引用  | 表达式引用         |</span><br><span class="line">| ----------------- | --------- | ------------------ |</span><br><span class="line">| String[]          | @array    | @stringArray       |</span><br><span class="line">| int[]             | @array    | @intArray          |</span><br><span class="line">| TypedArray        | @array    | @typedArray        |</span><br><span class="line">| Animator          | @animator | @animator          |</span><br><span class="line">| StateListAnimator | @animator | @stateListAnimator |</span><br><span class="line">| color int         | @color    | @color             |</span><br><span class="line">| ColorStateList    | @color    | @colorStateList    |</span><br><span class="line"></span><br><span class="line">### 事件处理</span><br><span class="line"></span><br><span class="line">可以编写从视图分派的表达式处理事件如：`onClick` </span><br><span class="line"></span><br><span class="line">#### 方法引用</span><br><span class="line"></span><br><span class="line">事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。</span><br><span class="line"></span><br><span class="line">方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">class MyHandler&#123;</span><br><span class="line">    fun onClickFriend(view:View)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绑定白哦大师可见视图的点击监听器分配给 <code>onClickFriend()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://scheams.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">              </span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h4><p>监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。</p><p>在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将事件绑定到 <code>onSaveClick()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://scheams.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">"com.example.Task"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.example.Presenter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span>              </span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。</p><p><strong>避免使用复杂的监听器</strong> 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。</p><h4 id="导入、变量和-包含"><a href="#导入、变量和-包含" class="headerlink" title="导入、变量和 包含"></a>导入、变量和 包含</h4><p>导入：可以轻松的在布局文件中引用类</p><p>变量：可以描述可在绑定表达式中使用的属性</p><p>包含：可以在整个应用中重复使用复杂的布局</p><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>在 <code>data</code> 元素中使用多个 <code>import</code> 元素，也可以不用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入 View 类可以通过绑定表达式引用该类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;user.name&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:visibility</span>=<span class="string">"@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>类型别名</em></p><p>当类名有冲突时，其中一个类可使用别名重命名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.real.estate.View"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">alias</span>=<span class="string">"Visia"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p><code>variable</code>  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.graphics.drawable.Drawable"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">type</span>=<span class="string">"Drawable"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量类型在编译时进行检查，因此如果实现了  <code>Observable</code> 或者时 <strong>可观察集合</strong>，则因反应在类型中。</p><p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。</p><h5 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h5><p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Data-Binding&quot;&gt;&lt;a href=&quot;#Data-Binding&quot; class=&quot;headerlink&quot; title=&quot;Data Binding&quot;&gt;&lt;/a&gt;Data Binding&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;布局和绑定表达式&quot;&gt;&lt;a href=&quot;#布局和绑定表达式&quot; class=&quot;headerlink&quot; title=&quot;布局和绑定表达式&quot;&gt;&lt;/a&gt;布局和绑定表达式&lt;/h3&gt;&lt;p&gt;借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://xiaoman.ren/tags/Android/"/>
    
  </entry>
  
</feed>
