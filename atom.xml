<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶白白在胡说</title>
  <icon>https://www.gravatar.com/avatar/f27b936c2ac428d82177b6d3626c8e3a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaoman.ren/"/>
  <updated>2021-03-22T16:09:16.237Z</updated>
  <id>http://xiaoman.ren/</id>
  
  <author>
    <name>茶白</name>
    <email>zhuangbudong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>行为统计 SDK 结构设计</title>
    <link href="http://xiaoman.ren/2021/03/12/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E7%BB%9F%E8%AE%A1%20SDK/"/>
    <id>http://xiaoman.ren/2021/03/12/用户行为统计 SDK/</id>
    <published>2021-03-12T06:59:30.448Z</published>
    <updated>2021-03-22T16:09:16.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/%E7%BB%9F%E8%AE%A1SDK.jpg" alt="统计SDK"></p><a id="more"></a><p><strong>API：</strong></p><ul><li>初始化配置策略（上报策略，压缩方案）</li><li>对应不同业务，分类设计 api</li></ul><p><strong>数据加工：</strong></p><ul><li>根据不同业务，给收集上来的数据绑定不同的业务数据，以及相同的设备等信息</li></ul><p><strong>持久层：</strong></p><ul><li>对加工后的数据进行存储，选用 Sqlite 数据库，原生好用，效率高，吞吐量大，比文件优秀。且是原生，不对 app 增加额外的包体积</li></ul><p><strong>数据上报：</strong></p><ul><li>采用单线程的方式，逐一从数据库中读取数据，并压缩处理，上传至服务器，成功后清除数据库中对应数据。上传失败，则取消上报保留数据。</li></ul><p><strong>异常采集</strong></p><ul><li>对于线上的异常问题，我们可以追踪采集数据的页面流转信息，以及报错信息，可以快速定位异常点、以及产生异常的流程</li><li>针对项目的主流程、核心路径监控，计算真实转化率。</li><li>被 catch 住的异常，虽然没有导致 app 崩溃，但程序的功能已经变的不可用，所以这些 catch 的异常也是需要上报的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/%E7%BB%9F%E8%AE%A1SDK.jpg&quot; alt=&quot;统计SDK&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="软件架构" scheme="http://xiaoman.ren/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码</title>
    <link href="http://xiaoman.ren/2021/03/12/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Glide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xiaoman.ren/2021/03/12/三方框架/Glide 源码分析/</id>
    <published>2021-03-12T06:59:30.441Z</published>
    <updated>2021-03-12T06:59:30.442Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 <code>Picasso</code> 和 <code>ImageLoader</code> 两套框架。 都各有特色。这里主要还是讲一下 <code>Glide</code> 。</p><p><strong>基础用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(url).into(imageView);</span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Android 开发中，我们通常最简单的使用 <code>Glide</code> 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。</p><p>从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，<code>with</code> <code>load</code> 和 <code>into</code>，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">主要功能</th></tr></thead><tbody><tr><td style="text-align:center">with</td><td style="text-align:center">1. 初始化Glide对象<br>2. 创建空白的 Fragment 管理生命周期机制<br>3. 创建一个 RequestManager 管理任务</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">最终构建出 RequestBuilder ，记录传入的数据</td></tr><tr><td style="text-align:center">into</td><td style="text-align:center">1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br>2. 活动缓存<br>3. 内存缓存<br>4. HttpUrlConnection</td></tr></tbody></table><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><code>Glide</code> 通过 <code>with</code> 函数，给自己的实例化，并创建一个空白的 <code>Fragment</code> 来管理生命周期并绑定 <code>ReqeustManager</code> 。继续通过 <code>load()</code> 函数构建一个 <code>RequestBuilder()</code> 并缓存我们的参数，继续通过 <code>into</code> 创建一个 <code>Request</code> 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 <code>ActivityResources</code> 有没有数据，再检查内存缓存 <code>LRUResourceCache</code> ，如果两级缓存都未命中，则启动一个异步任务 <code>DecodeJob</code>, 去检查 <code>DiskCache</code> 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 <code>HttpUrlConnection</code> ，解析 <code>InputStream</code> 进行采样，最终拿到 <code>Bitmap</code>，将 <code>Bitmap</code> 转换成 <code>Drawable</code> 并讲数据缓存到磁盘中。</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>从上面的表格中，我们可以看出来 <code>with</code> 函数，就是用来帮我创建 <code>Glide</code> 对象，并创建一个空白的 <code>Fragment</code> 来管理生命周期。其具体的工作流程如图：</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true" alt="Glide with 时序图"></p><p>由上面的时序图，我们可以顺序的分析，我们一步步去分析。</p><p><strong>Glide.with()</strong></p><p><code>Glide.with()</code> 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getRetriever</strong>()</p><p><code>getRetriever()</code> 通过 Glide 的 get 函数，帮我们初始化了一个 <code>Glide</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(@Nullable Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get(context)</strong></p><p>可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>checkAndInitializeGlide() &amp; initializeGlide()</strong></p><p>最终通过构造者模式，完成了对 <code>Glide</code> 对象的初始化，同时在构造者中，也对很多 <code>Glide</code> 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkAndInitializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (isInitializing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"You cannot call Glide.get() in registerComponents(),"</span></span><br><span class="line">            + <span class="string">" use the provided Glide instance instead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isInitializing = <span class="keyword">true</span>;</span><br><span class="line">    initializeGlide(context, generatedAppGlideModule);</span><br><span class="line">    isInitializing = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule)</span> </span>&#123;</span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里， <code>Glide</code> 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。</p><p>并且代码按照流程，<code>get()</code> 的深度代码已经完成，程序会逐步回到 <code>getRetriever()</code> 函数中，去执行 <code>getRequestManagerRetriever</code> ， <code>getRequestManagerRetriever</code> <code>是通过</code>Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 <code>with()</code>函数 的 <code>get()</code> 去创建 <code>RequestManager</code></p><p><strong>get(Fragment fragment)</strong></p><p>这时候，我们发现，现在代码已经跳转到 <code>RequestManagerRetriever</code> 类中</p><p><strong>RequestManagerRetriever</strong></p><p><code>RequestManagerRetriever</code> 是一个管理类，负责生产 <code>Fragment</code> 对象，根据我们传入的 <code>Context</code> 上下文的定义不同，最终会帮我们创建不同的生命周期管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="comment">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span></span><br><span class="line">    <span class="keyword">return</span> get(fragment.getContext().getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">        &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">       <span class="comment">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong></p><ol><li><p><strong>如果当前任务工作在后台线程或者传入的 <code>Context</code> 对象是一个 <code>Application</code> 级别的，那 <code>Glide</code> 就会帮我们创建一个和 <code>Application</code> 同生命周期的 <code>RequestManager</code> 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color="red">内存的泄漏</font></strong>。 因此我们使用时，尽量不要传入里类似的。</p></li><li><p>如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 <code>Glide</code> 就会帮我们创建个空白的 <code>Fragment</code>， <code>supportFragmentGet</code> 和  <code>fragmentGet</code> 两种方案是用来做 <code>androidX</code> 和 <code>android.app</code>中不同 <code>fragment</code> 的适配</p></li></ol></blockquote><p><strong>supportFragmentGet</strong></p><p>创建管理生命周期的 Fragment, <code>androidx</code> 对应的是 <code>supportFragmentGet()</code> ， <code>android.app</code> 对应的是 <code>fragmentGet()</code>， 这里以 <code>supportFragmentGet()</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建/获取当前空白的 Fragment</span></span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    <span class="comment">// 获取空白 Fragment 中的 RequestManager 对象</span></span><br><span class="line">    <span class="comment">// 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中</span></span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 返回 reqeustManager 对象</span></span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> FragmentManager fm, @Nullable Fragment parentHint, <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment </span></span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="comment">// 如果为空，说明空白的 Fragment 还没有被添加进去</span></span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象</span></span><br><span class="line">      <span class="comment">// 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，</span></span><br><span class="line">      <span class="comment">// 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，</span></span><br><span class="line">      <span class="comment">// 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap</span></span><br><span class="line">    current = pendingSupportRequestManagerFragments.get(fm); <span class="comment">// 第一保障</span></span><br><span class="line">      <span class="comment">// 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的空白 Fragment</span></span><br><span class="line">      current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">          <span class="comment">// 调用生命周期方法，让所有的监听者开始任务（后面会说）</span></span><br><span class="line">        current.getGlideLifecycle().onStart();</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 将创建好的 Fragment 存入到集合中</span></span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">        <span class="comment">// Handler 通知父容器，这里添加了一个 Fragment</span></span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        <span class="comment">// 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）</span></span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong></p><p>这里有一个比较困惑的地方就是，将已经创建好的 <code>Fragment</code> 添加到集合中去后，又通过 <code>Handler</code> 消息，将这个 <code>Fragment</code> 从集合中移除，这是为什么呢？</p><p>其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，<code>fragment</code> 的添加也是通过 <code>Handler</code> 来完成的，但 <code>Handler</code> 消息的执行时间不能保证，因此通过 <code>Handler</code> 再发一次消息，让移除操作在 <code>Fragment</code> 添加完成之后去执行，就一定能够得到保障。</p><p>只有当 <code>Fragment</code> 被添加进入父容器之后， <code>fm.findFragmentByTag</code> 才能获取到对象。这也是为了保证每个父容器都只有一个空白 <code>Fragment</code> 的两次保障。</p></blockquote><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p>至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true" alt="Glide lifecycle"></p><p><strong>SupportRequestManagerFragment</strong> </p><p>内部绑定了 <code>ActivityFragmentLifecycle</code> ，通过 Fragment 生生命周期变化，来引导 <code>RequestManager</code> 完成图片的请求和后续的显示</p><p>我们查看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportRequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SupportRMFragment"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint</span>(<span class="string">"ValidFragment"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">(@NonNull ActivityFragmentLifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造器创建了 ActivityFramgentLifecycle</span></span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">    unregisterFragmentWithRoot();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。</p><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true" alt="Glide load"></p><p>我们将 <code>Glide.with(this).load(url).into(view);</code> 拆分开来写，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestManager requestManager = Glide.with(<span class="keyword">this</span>);</span><br><span class="line">RequestBuilder requestBuilder = requestManager.load(url);</span><br><span class="line">requestBuilder.into(view);</span><br></pre></td></tr></table></figure><p>可以看出， load 函数，我们传入了一个 <code>String</code> 类型的 <code>Url</code>， 最终返回给我们一个 <code>RequestBuilder</code> 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 <code>RequestBuilder</code> 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 <code>Drawable</code> 。</p><p><code>Glide</code> 也为我们提供了丰富的 <code>load api</code>， 我们可以传入 <code>url, bitmap, byte[], Drawable, Uri, File, Integer</code> 等等， <code>RequestBuilder</code> 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 <code>Drawable</code> 给图片容器，也就是后面我们要说的 <code>into</code> 函数。</p><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><p>into 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true" alt></p><p>但我们先按照这个残图先分析一下。</p><p>当 <code>into(imageview)</code> 被调用后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">        <span class="keyword">case</span> FIT_START:</span><br><span class="line">        <span class="keyword">case</span> FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER:</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Glide 显示对图片进行了解析，获取图片的尺寸等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续，创建了一个 <code>Request</code> ，这个 <code>Request</code> 的真实对象是 <code>SingleRequest</code> ，并通过 <code>requestManager</code> 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 &lt;code&gt;Picasso&lt;/code&gt; 和 &lt;code&gt;ImageLoader&lt;/code&gt; 两套框架。 都各有特色。这里主要还是讲一下 &lt;code&gt;Glide&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础用法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Glide.with(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;).load(url).into(imageView);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="三方框架" scheme="http://xiaoman.ren/categories/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Glide" scheme="http://xiaoman.ren/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Object 类</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Object%20%E7%B1%BB/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Object 类/</id>
    <published>2021-03-12T06:59:30.441Z</published>
    <updated>2021-03-12T06:59:30.441Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法</li><li>可以使用 Object 类型的变量指向任意类型的 super 类</li><li>Object 类有一个默认构造方法 <code>public Object()</code> ，在构造子类实例时，都会先调用这个默认构造方法</li><li>Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换</li></ul><a id="more"></a><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>Object () ： 默认构造方法</li><li>clone() : 创建并返回此对象得一个副本</li><li>equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）</li><li>finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法</li><li>getClass(): 返回一个对象得运行时类</li><li>hashCode(): 返回该对象得 哈希值</li><li>notify(): 唤醒在此对象监视器上等待得单个线程</li><li>notifyAll() : 唤醒在此对象监视器上等待得所有线程</li><li>toString(): 返回该对象得字符串标识</li><li>wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法</li><li>wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量</li><li>wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法&lt;/li&gt;
&lt;li&gt;可以使用 Object 类型的变量指向任意类型的 super 类&lt;/li&gt;
&lt;li&gt;Object 类有一个默认构造方法 &lt;code&gt;public Object()&lt;/code&gt; ，在构造子类实例时，都会先调用这个默认构造方法&lt;/li&gt;
&lt;li&gt;Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 注解</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Java-注解/</id>
    <published>2021-03-12T06:59:30.440Z</published>
    <updated>2021-03-12T06:59:30.440Z</updated>
    
    <content type="html"><![CDATA[<p>Java 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。</p><h2 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h2><p>Java 中所有的注解，默认实现接口 <code>Annotation</code> 接口</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与生命一个  Class 不同，注解的使用使用 <code>@interface</code> 管检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值</p><ul><li>ElementType.ANNOTATION_TYPE 可以用于注解类型</li><li>ElementType.CONSTRUCTOR 可以用于构造函数</li><li>ElementType.FIELD 可以用于字段或属性</li><li>ElementType.LOCAL_VARIABLE 可以用于局部变量</li><li>ElementType.METHOD 可以应用于方法级注解</li><li>ElementType.PACKAGE 可以应用于包生命</li><li>ELementType.PARAMETER 方法参数</li><li>ElementType.TYPE 用于类的任何元素</li></ul><h2 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h2><p>注解指定标记注解的存储方式（作用域）：</p><ul><li>RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略</li><li>RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略</li><li>RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>按照作用域来讲，注解可以被三种场景使用</p><h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE"></a>SOURCE</h3><p><code>RetentionPolicy.SOURCE</code> 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用</p><p><strong>语法检查：</strong></p><p>在 <code>Adnroid</code>开发中，<code>support-annotations</code> 与 <code>androidx.annotation</code> 中均提供了 <code>@IntDef</code> 注解，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ANNOTATION_TYPE&#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IntDef &#123;</span><br><span class="line">    <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">flag</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解的意义在于能够取代枚举，实现如方法入参限制</p><p>如：我们定义 test 方法，只接收 Teacher 参数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Teacher &#123;</span><br><span class="line">    LILY, MARY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Teacher teacher)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而现在为了内存优化，我们现在不再使用枚举，则方法定义为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LILY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MARY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> teacher)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然而 <code>test</code> 方法由于采用基本数据类型 <code>int</code> ，讲无法进行类型限定。此时我们使用 <code>@IntDef</code> 增加自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LILY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MARY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IntDef</span>(value = &#123;LILY, MARY&#125;) <span class="comment">// 限定为 LILY, MARY</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER) <span class="comment">// 作用于参数的注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE) </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Teacher&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@Teacher <span class="keyword">int</span> teacher)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此时，我们再去调用 <code>test</code> 方法，如果传递的参数不时 LILY, 和  MARY 则会显示 <code>Inspection</code> 警告</p><p><strong>APT 注解处理器</strong></p><p>apt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等</p><p>所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。</p><p>我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：<em>需要登录</em> 和 <em>不需要登录</em> 即两个切面，对于切面的区分可采用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginAspect&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoginAspect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, AActivity.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, BActivity.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。&lt;/p&gt;
&lt;h2 id=&quot;声明注解&quot;&gt;&lt;a href=&quot;#声明注解&quot; class=&quot;headerlink&quot; title=&quot;声明注解&quot;&gt;&lt;/a&gt;声明注解&lt;/h2&gt;&lt;p&gt;Java 中所有的注解，默认实现接口 &lt;code&gt;Annotation&lt;/code&gt; 接口&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java-%E5%BC%82%E5%B8%B8/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Java-异常/</id>
    <published>2021-03-12T06:59:30.439Z</published>
    <updated>2021-03-12T06:59:30.439Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Crash</strong> 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。</p><p>发生 <strong>Crash</strong> 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 <strong>Crash</strong> 的放生，在 <strong>Android</strong> 系统中，系统碎片化比较严重，各 <strong>Rom</strong> 之间的差异，设置系统的 BUG ，都可能导致 <strong>Crash</strong> 的发生。</p><p>在 <strong>Android</strong> 应用 中发生 <strong>Crash</strong> 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 <strong>Crash</strong> 的监控和获取堆栈信息有所不同。</p><a id="more"></a><h2 id="Java-Crash"><a href="#Java-Crash" class="headerlink" title="Java Crash"></a>Java Crash</h2><p>Java 的 Crash 监控非常简单，<strong>Java 中的 Thread 定义了一个接口： <code>UncaughtExceptionHandler</code> , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到）</strong>，当应用发生了 Crash 的时候，就会走 <code>UNcaughtExceptionHandler.uncaughtException</code> ，该方法中可以获取到异常的信息，我们通过 <code>Thread.setDefaultUncaughtExceptionHandler</code> ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME_STUFFIX = <span class="string">".trace"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread.UncaughtExceptionHandler mDefaultCrashHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CrashHandler</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">this</span>);</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当程序中有未捕获异常，系统将会调用这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 自行处理，可以保存到本地，也可以上传到后台</span></span><br><span class="line">            File file = dealException(e);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 交给系统默认程序处理，否则会重复自启动</span></span><br><span class="line">            <span class="keyword">if</span>(mDefaultCrashHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDefaultCrashHandler.uncaughtException(t, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出异常到 SD 卡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> File <span class="title">dealException</span><span class="params">(Thread t, Throwable e)</span> throw Exception </span>&#123;</span><br><span class="line">         String time = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">         File f = <span class="keyword">new</span> File(mContext.getExternalCacheDir().getAbsoluteFile(), <span class="string">"crash_info"</span>);</span><br><span class="line">         <span class="keyword">if</span>(!f.exists()) &#123;</span><br><span class="line">             f.mkdirs();</span><br><span class="line">         &#125;</span><br><span class="line">         File crashFile = <span class="keyword">new</span> File(f, time+ FILE_NAME_SUFFIX);</span><br><span class="line">         <span class="comment">// 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题</span></span><br><span class="line">         PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(f)));</span><br><span class="line">         pw.println(time);</span><br><span class="line">         pw.println(<span class="string">"Thread:"</span> + t.getName());</span><br><span class="line">         e.printStackTrace(pw);<span class="comment">// 写入 crash 堆栈</span></span><br><span class="line">         pw.flush();</span><br><span class="line">         pw.close();</span><br><span class="line">         <span class="keyword">return</span> f;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NDK-Crash"><a href="#NDK-Crash" class="headerlink" title="NDK Crash"></a>NDK Crash</h2><h3 id="Linux-信号机制"><a href="#Linux-信号机制" class="headerlink" title="Linux 信号机制"></a>Linux 信号机制</h3><p>信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式：</p><ul><li>忽略该信号</li><li>捕捉该信号并执行对应的信号处理函数（信号处理程序）</li><li>执行该信号的缺省操作（如终止进程）</li></ul><p>当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。</p><p>常见的崩溃信号列表：</p><ul><li><strong>SIGSEGV: </strong> 内存引用无效</li><li><strong>SIGBUS: </strong> 访问内存对象的未定义部分</li><li><strong>SIGFPE: </strong> 算数运算错误</li><li><strong>SIGILL: </strong> 非法指令，如执行垃圾或特权指令</li><li><strong>SIGSYS: </strong> 糟糕的系统调用</li><li><strong>SIGXCPU: </strong> 超过 CPU 时间限制</li><li><strong>SIGXFSZ: </strong> 文件大小限制</li></ul><p>一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。</p><h3 id="BreakPad"><a href="#BreakPad" class="headerlink" title="BreakPad"></a>BreakPad</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9icmVha3BhZA==" title="https://github.com/google/breakpad">Google breakpad<i class="fa fa-external-link"></i></span> 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为  C++, 在 Android 中必须要借助 NDK 工具。</p><p> <a href="..\..\技术文档\Crash监控.pdf">Crash监控.pdf</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Crash&lt;/strong&gt; 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。&lt;/p&gt;
&lt;p&gt;发生 &lt;strong&gt;Crash&lt;/strong&gt; 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 &lt;strong&gt;Crash&lt;/strong&gt; 的放生，在 &lt;strong&gt;Android&lt;/strong&gt; 系统中，系统碎片化比较严重，各 &lt;strong&gt;Rom&lt;/strong&gt; 之间的差异，设置系统的 BUG ，都可能导致 &lt;strong&gt;Crash&lt;/strong&gt; 的发生。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Android&lt;/strong&gt; 应用 中发生 &lt;strong&gt;Crash&lt;/strong&gt; 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 &lt;strong&gt;Crash&lt;/strong&gt; 的监控和获取堆栈信息有所不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Java-泛型/</id>
    <published>2021-03-12T06:59:30.439Z</published>
    <updated>2021-03-12T06:59:30.439Z</updated>
    
    <content type="html"><![CDATA[<p>泛型，即 <strong>参数化类型</strong>。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。</p><p>参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。</p><p>泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。</p><a id="more"></a><h2 id="三种泛型方式"><a href="#三种泛型方式" class="headerlink" title="三种泛型方式"></a>三种泛型方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeClass</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">typeMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><ol><li>使得代码更健壮</li><li>代码更简洁</li><li>更灵活、可复用</li></ol><h2 id="限定类型变量"><a href="#限定类型变量" class="headerlink" title="限定类型变量"></a>限定类型变量</h2><p>有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.compareTo(b) &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如上代码，如果我们传入的两个变量没有实现 <code>Comparable</code> 会如何呢？那一定是调用不到 <code>compareTo()</code> 的，那么我们对其加上约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span> <span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.compareTo(b) &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T extends Comparable</code> 中，T 表示应该绑定的子类型， <code>Comparable</code> 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。</p><p>如果我们传入一个没有实现 <code>Comparable</code> 接口的实例，则会发生编译错误。</p><p><strong>同时 <code>extends</code> 左右都允许有多个，比如 <code>T, V extends Comparable &amp; serializable</code> ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个</strong></p><h4 id="约束和局限性"><a href="#约束和局限性" class="headerlink" title="约束和局限性"></a>约束和局限性</h4><ul><li>不能使用基本类习数据类型做参数，只能使用包装器类型</li><li>运行时类型查询只时用于原始类型</li><li>反射对泛型擦除增加了风险</li><li>泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突）</li><li>静态块/静态方法中不能使用泛型</li><li>不能创建参数化类型的数组</li><li>不能实例化类型变量</li><li>不能捕获泛型类的实例</li></ul><h2 id="泛型的继承规则"><a href="#泛型的继承规则" class="headerlink" title="泛型的继承规则"></a>泛型的继承规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="title">exrends</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>泛型类可以继承或者扩展其他泛型类，比如 <code>List</code> 和 <code>ArrayList</code></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HongFuShi</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(GenericType&lt;Fruit&gt; p)</span> </span>&#123;</span><br><span class="line">    System.out.println(p.getData().getColor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    GenericType&lt;Fruit&gt; a = <span class="keyword">new</span> GenericType(); <span class="comment">// 可以</span></span><br><span class="line">    GenericType&lt;Apple&gt; b = <span class="keyword">new</span> GenericType();<span class="comment">// 不允许d </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面的方案不被 SDK 允许，于是提出了一个通配符类型</p><ul><li><code>? extends X</code> 表示类型的上界，类型参数是 X 的子类</li><li><code>? super X</code> 表示类型的下界，类型参数是 X 的父类</li></ul><h4 id="extends-X，可读不可写"><a href="#extends-X，可读不可写" class="headerlink" title="? extends X，可读不可写"></a>? extends X，可读不可写</h4><p>表示传递给方法的参数，必须是 X 的子类（包括 X 本身）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(GenericType&lt;? extends Fruit&gt; p)</span></span>&#123;</span><br><span class="line">    System.out.println(p.getData().getColor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改）</p><p>因为 <code>? extends X</code> 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。</p><h4 id="super-X-，可写不可读"><a href="#super-X-，可写不可读" class="headerlink" title="? super X ，可写不可读"></a>? super X ，可写不可读</h4><p>表示传递给方法的参数，必须是 X 的父类（包括 X 本身）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(GenericType&lt;? <span class="keyword">super</span> Apple&gt; p)</span> </span>&#123;</span><br><span class="line">    System.out.println(po.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set  类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。</p><p>get 方法只返回一个 Object 类型的值。<br>因为  <code>? super X</code> 表示类型的下界，参数类型是 X  的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但  Object 一定是它的父类，所以 get  方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。</p><h3 id="无限通配符-，只是为了说明用法"><a href="#无限通配符-，只是为了说明用法" class="headerlink" title="无限通配符 ?，只是为了说明用法"></a>无限通配符 ?，只是为了说明用法</h3><p>表示类型没有限制，可以把 <code>?</code> 看成所有类型的父类，如： Pair&lt;?&gt;</p><p><code>ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;()</code> 指定集合元素只能是 T 类型</p><p><code>ArrayList&lt;?&gt; al = new ArrayList&lt;?&gt;()</code> 集合元素可以是任意类型。</p><h2 id="虚拟机是如何实现的"><a href="#虚拟机是如何实现的" class="headerlink" title="虚拟机是如何实现的"></a>虚拟机是如何实现的</h2><p>Java 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，<code>ArrayList&lt;int&gt;</code> 与 <code>ArrayList&lt;String&gt;</code> 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为<strong>伪泛型</strong></p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>因为虚拟机实现原理，就是泛型擦除，因此 <strong>泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object</strong></p><p><strong>步骤</strong></p><ol><li>检查泛型类型，获取目标泛型</li><li>擦除类型变量，并替换为限定类型<ol><li>如果泛型类型的类型变量没有限定<code>&lt;T&gt;</code> 则用 Object 原始类型表示</li><li>如果有限定类型<code>&lt;T extends XClass&gt;</code>则用，<code>XClass</code> 作为原始类型</li><li>如果有多个限定<code>&lt;T extends XClass &amp; XClass2&gt;</code> 则使用第一个作为原始类型</li></ol></li><li>在必要时插入类型转换以保证类型安全</li><li>生成<strong>桥方法</strong> 以再扩展时保持多态</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型，即 &lt;strong&gt;参数化类型&lt;/strong&gt;。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。&lt;/p&gt;
&lt;p&gt;参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。&lt;/p&gt;
&lt;p&gt;泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 枚举</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%20%E6%9E%9A%E4%B8%BE/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Java 枚举/</id>
    <published>2021-03-12T06:59:30.438Z</published>
    <updated>2021-03-12T06:59:30.438Z</updated>
    
    <content type="html"><![CDATA[<p>枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。</p><p><strong>使用<code>enum</code> 来标识枚举类</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>必须使用 <code>enum</code> 关键字声明</li><li>除了初始化，不能通过任何方式手动创建枚举实例</li><li>不可以被继承</li><li>JVM 保证线程安全</li><li>无法继承其他类</li></ol><a id="more"></a><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><strong>常量枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// RED</span></span><br></pre></td></tr></table></figure><p>上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。</p><p>通过字节码分析 <code>Color.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final 修饰，不能被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 声明的变量，都对应一个枚举实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回原数组的副本，防止数组的修改，引起内部 values 值的改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color[])$VALUE.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照名字获取枚举实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(com/example/Color, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态初始化</span></span><br><span class="line">    <span class="comment">// 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RED = <span class="keyword">new</span> Color(<span class="string">"RED"</span>, <span class="number">0</span>);</span><br><span class="line">        GREEN = <span class="keyword">new</span> Color(<span class="string">"GREEN"</span>, <span class="number">1</span>);</span><br><span class="line">        BLUE =  <span class="keyword">new</span> Color(<span class="string">"BLUE"</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</span><br><span class="line">            RED, GREEN, BLUE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的类中可以看出，<code>enum</code> 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 <code>jvm</code> 中运行的代码</p><p><code>Enum</code> 类接受一个继承自 <code>Enum</code> 的泛型（反编译阶段，<code>Java</code>中没有具体体现泛型，是应为泛型在编译阶段就会被 <code>JVM</code> 进行泛型擦除，替换为具体实现）</p><p>从枚举类以及反编译出来的字节码可以看出，枚举类第一个 <code>;</code> 前的变量，都会在字节码中体现为一个 <code>Color</code> 实例，且在 <code>clinit</code> 静态代码块中进行初始化。而静态块在类加载阶段，<code>JVM</code> 会保证枚举对象的线程安全。</p><p>生成的 <code>$VALUES[]</code> 可通过 <code>values()</code> 方法被外部获取实例。</p><h2 id="枚举-Enum-类分析"><a href="#枚举-Enum-类分析" class="headerlink" title="枚举 Enum 类分析"></a>枚举 Enum 类分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != var1.getClass() &amp;&amp; <span class="keyword">this</span>.getDeclaringClass() != var1.getDeclaringClass()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ordinal - var1.ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Enum</code> 类实现了 <code>Comparable</code> 接口，表明它是支持排序的，实现 <code>compareTo</code> ，方法定义为 <code>final</code> 且实现以来 <code>ordinal</code> 字段也是 <code>final</code> 类型，说明只能依据 <code>ordinal</code> 排序，排序规则不可变.</p><p><strong>ordinal:</strong> 表示枚举的顺序，从 <code>Color</code> 类中可以看出他是从 0 开始自然顺序增长，且其值是 <code>final</code> 类型，外部无法改变。</p><p><strong>name:</strong> 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）</p><p><strong>equals():</strong>  使用 <code>==</code> 判断两个枚举是否相等</p><h2 id="每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的"><a href="#每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的" class="headerlink" title="每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的"></a>每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的</h2><p>枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 <code>JVM</code> 中有且只有一个对应的实例</p><p><em>为达到这种效果，枚举通过下面的方式来完成</em></p><ol><li><p>类加载时创建，保证线程安全</p><p>枚举对象在静态块中创建，由类加载时进行初始化，<code>JVM</code> 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例</p></li><li><p>对序列化进行特殊处理，防止反序列化时创建对象</p><p>一旦实现 <code>Serializable</code> 接口之后，反序列化时每次调用 <code>readObject()</code> 方法返回的都是一个新创建出来的对象</p><p>而枚举在序列化时，<code>Java</code> 仅仅是将枚举对象的 <code>name</code> 属性输出到结果中，反序列化时则是通过枚举的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; var0, String var1)</span> </span>&#123;</span><br><span class="line">        Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No enum constant "</span> + var0.getCanonicalName() + <span class="string">"."</span> + var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>私有构造函数，无法正常 new 出对象</p></li><li><p>无法通过 <code>clone()</code> 方法， 克隆对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无法通过反射的方式创建枚举对象</p><p>枚举类型在 <code>JVM</code> 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 <code>Cannot reflectively create enum objects</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reflectTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 获取类对象</span></span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"com.example.Color"</span>);</span><br><span class="line">    <span class="comment">// 获取构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 设置访问权限</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">    Object refObj = constructor.newInstance(<span class="string">"name"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="keyword">enum</span> objects</span><br></pre></td></tr></table></figure></li></ol><h2 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h2><h3 id="枚举与单例模式"><a href="#枚举与单例模式" class="headerlink" title="枚举与单例模式"></a>枚举与单例模式</h3><p>传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// todo...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。</p><p>在 <code>Android</code> 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 <strong>双重检查锁</strong>，<strong>静态内部类</strong> 的方式实现单例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;enum&lt;/code&gt; 来标识枚举类&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;必须使用 &lt;code&gt;enum&lt;/code&gt; 关键字声明&lt;/li&gt;
&lt;li&gt;除了初始化，不能通过任何方式手动创建枚举实例&lt;/li&gt;
&lt;li&gt;不可以被继承&lt;/li&gt;
&lt;li&gt;JVM 保证线程安全&lt;/li&gt;
&lt;li&gt;无法继承其他类&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/基础知识/Java-反射/</id>
    <published>2021-03-12T06:59:30.438Z</published>
    <updated>2021-03-12T06:59:30.439Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是反射？</strong></p><p>反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。</p><p>一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作</p><p>反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 <code>new</code> 关键字来创建对象。</p><a id="more"></a><p><strong>反射的作用</strong></p><ol><li>实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现</li><li>通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger </li></ol><p><strong>Java Class 的文件结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_info constant_pool[constant_pool_count - <span class="number">1</span> ];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    <span class="comment">// 重要</span></span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[field_count];</span><br><span class="line">    <span class="comment">// 重要</span></span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;ClassBlock</span><br></pre></td></tr></table></figure><p><strong>field 字段结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fieldblock</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="keyword">char</span> *signature;</span><br><span class="line">    u2 access_flag;</span><br><span class="line">    u2 constant;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">uintptr_t</span> u;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l;</span><br><span class="line">            <span class="keyword">void</span> *p;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">        &#125; static_value;</span><br><span class="line">        u4 offset;</span><br><span class="line">    &#125;u;</span><br><span class="line">&#125;FieldBlock;</span><br></pre></td></tr></table></figure><p><strong>method</strong> </p><p>提供了 descriptor, access_flags, Code 等索引，并指向常量池；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    <span class="comment">// the paramters that the method takes and the value that it return</span></span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h3><p><strong>ClassLoader：</strong></p><p> 用于加载、连接、缓存 Class，可以通过纯  Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 <code>HashTable&lt;String, Class&gt;</code> 用于实现堆 Class 字节流节码后的缓存，如果 <code>HashTable</code> 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。</p><p><strong>初始化过程</strong></p><p>当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 <code>clinit()&gt;</code> 中的静态块与静态属性（取决于编码顺序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Smaple</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step 1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// step 2</span></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">       b = <span class="number">3</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sample s = <span class="keyword">new</span> Sample();</span><br><span class="line">        System.out.println(s.b);</span><br><span class="line">        <span class="comment">// b = 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Class.forName</strong></p><p><code>Class.forName()</code> 可以通过报名寻找到 Class 对象，比如： <code>Class.forName(&quot;java.lang.String&quot;)</code></p><p><strong>getDeclaredFields</strong></p><p><code>class.getDeclaredFields()</code> 方法实际调用的是 <code>native</code> 方法 <code>getDeclaredFields0()</code> 它在  JVM 主要实现步骤如下</p><ol><li>根据 Class 结构体信息，获取 <code>field_count</code> 和 <code>fields[]</code> 字段，这个字段在 load 过程就被放入了</li><li>根据 <code>field_count</code> 的大小分配内存和创建数组</li><li>将数组进行 <code>forEach</code> 循环，通过 <code>fields[]</code> 中的信息一次创建 Object 对象。</li><li>返回数组指针</li></ol><p>这个过程比较耗时：</p><ol><li>创建、计算、分配数组对象</li><li>对字段进行循环赋值</li></ol><p><strong>Method.invoke</strong></p><p>创建 Frame</p><p>如果对象 flag 为 native，交给 native_handler 进行处理</p><p>在 frame 中执行 Java 代码</p><p>弹出 Frame</p><p>返回执行结果的指针</p><p>主要慢在</p><ol><li>需要完全执行 ByteCode 而缺少 JIT 等优化</li><li>检查参数非常多，本来可以在编译器或者加载时完成</li></ol><p><strong>class.newInstance</strong></p><p>检测权限，预分配空间大小等参数</p><p>创建 Object 对象，并分配空间</p><p>通过<code>Method.invoke()</code> 调用构造函数</p><p>返回 Object 指针</p><p>主要慢在：</p><ol><li>参数检查不能优化或者一口</li><li>构造函数 Method.invoke 本身耗时</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;什么是反射？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作&lt;/p&gt;
&lt;p&gt;反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 &lt;code&gt;new&lt;/code&gt; 关键字来创建对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存管理</title>
    <link href="http://xiaoman.ren/2021/03/12/Java/Java%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://xiaoman.ren/2021/03/12/Java/Java 内存管理/</id>
    <published>2021-03-12T06:59:30.437Z</published>
    <updated>2021-03-22T15:53:56.462Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 <code>delete/free</code> 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true" alt="java runtime"></p><a id="more"></a><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。</p><p>此区域是唯一一个 Java 虚拟机规范中没有任何 <strong>OutOfMemoryError</strong> 情况的区域</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。</p><p>每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。</p><p><strong>局部变量表</strong> 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。</p><p><strong>StackOverflowError</strong>： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 <code>StackOverflowError</code> 异常</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。</p><h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。<strong>此区域唯一的目的就是存放对象实例</strong>，几乎所有的对象实例都再这里分配内存。</p><p>Java 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 <strong>分代收集算法</strong> ，所以 Java 堆中还可以细分为： 新生代和老生代</p><p>如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h3><p>方法区与 Java 堆一样，是哥哥线程共享的内存区域，<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据</strong>。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>GC</strong> 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。</p><h3 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h3><ul><li>虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，<strong>这块区域不需要进行 GC</strong></li><li>本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。<strong>不需要进行 GC</strong></li><li>程序计数器：线程独有，可以看作时当前线程执行的字节码行号。<strong>不需要进行 GC</strong></li><li>本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC</li><li>堆：对象实例和水族都是在堆上分配的， GC 也主要对这两类数据进行回收</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：<strong>循环引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Test instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// first</span></span><br><span class="line">        A a = <span class="keyword">new</span> Test(<span class="string">"a"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> Test(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//second</span></span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">    <span class="comment">//third</span></span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。</p><h5 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h5><p>以一系列叫做 <strong>GC Root</strong> 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。</p><p>但是，一个对象的 <code>finalize</code> 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 <code>finalize</code> 方法，如果未执行，则会先执行 <code>finalize</code> 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 <code>finalize</code> 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。</p><p><strong>注意：</strong> <code>finalize</code> 方法只会执行一次，如果第一次执行 <code>finalize</code> 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 <code>finalize</code> 方法，对象会被回收。</p><p><strong>GC Root</strong></p><p>那么，什么样的对象可以作为 GC Root 呢</p><ol><li><p>虚拟机栈（栈帧中的本地变量）中的引用对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中 JNI 引用的对象</p></li></ol><p><strong>虚拟机栈中的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a  充当了 GC Root 的作用， a 与原来指向的实例 <code>new Test()</code> 断开连接，所以对象会被回收。</p><p><strong>方法区中类静态属性引用的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当栈帧中的本地变量  <code>a = null</code> 时，由于 a 原来指向的对下个与 GC  Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 <code>instance</code> 赋值了变量的引用， <code>instance</code> 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p><p><strong>方法区中常量引用的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test instance = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量 <code>instance</code> 指向的对象并不会因为 a 指向的对象被回收而回收</p><p><strong>本地方法栈中的 JNI 引用的对象</strong></p><blockquote><p>所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。</p></blockquote><p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。</p><h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p><strong>步骤</strong>：</p><ol><li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li><li>对可回收对象进行回收</li></ol><p>操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –&gt; <strong>内存碎片</strong></p><p>假如我们想在内存中分配一块需要连续内存占用的 4M  或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。</p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。</p><p><strong>问题：</strong></p><p>比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。</p><h5 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h5><p>步骤：</p><ol><li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li><li>对可回收对象进行回收</li><li>将所有存活对象都往一端移动，紧邻排列。</li></ol><h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h5><p>Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代，这就是 JVM 的内存分代策略。注意: 在 HotSpot 中除了新生代和老年代，还有永久代</p><p><strong>新生代</strong></p><p>新生成的对象优先存放在新生代中，新生代对象存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收 70%~95% 的空间，回收效率很高。新生代中因为要进行一些复制操作，所以一般采用的 GC 回收算法是<strong>复制算法</strong>。 新生代又可以继续细分为 3 部分：<code>Eden</code>、<code>Survivor0（简称 S0）</code>、<code>Survivor1（简称S1）</code>。这 3 部分按照 8:1:1 的比例来划分新生代。</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/v2-72e5df4267ad17b0ce2754232a8be076_720w.jpg" alt="img"></p><ul><li>绝大多数刚刚被创建的对象会存放在 Eden 区。</li><li>当 <code>Eden</code> 区第一次满的时候，会进行垃圾回收。首先将 <code>Eden</code> 区的垃圾对象回收清除，并将存活的对象复制到 <code>S0</code>，此时 <code>S1</code> 是空的。</li><li>下一次 <code>Eden</code> 区满时，再执行一次垃圾回收。此次会将 <code>Eden</code> 和 <code>S0</code> 区中所有垃圾对象清除，并将存活对象复制到 <code>S1</code>，此时 <code>S0</code> 变为空。</li><li>如此反复在 <code>S0</code> 和 <code>S1</code> 之间切换几次（默认 15 次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将它们转移到老年代中。</li></ul><p><strong>老年代</strong></p><p>一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（比如长字符串或者大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代上。</p><p>我们可以使用 <code>-XX:PretenureSizeThreshold</code> 来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。老年代因为对象的生命周期较长，不需要过多的复制操作，所以一般采用<strong>标记压缩的回收算法</strong>。</p><blockquote><p><strong>注意</strong>：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代 GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的 <code>card table</code>，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 <code>card table</code> 即可，大大提高了性能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 &lt;code&gt;delete/free&lt;/code&gt; 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。&lt;/p&gt;
&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true&quot; alt=&quot;java runtime&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://xiaoman.ren/categories/Java/"/>
    
    
      <category term="Java" scheme="http://xiaoman.ren/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 屏幕适配</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/%E9%80%82%E9%85%8D/Android%20%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/适配/Android 屏幕适配/</id>
    <published>2021-03-12T06:59:30.437Z</published>
    <updated>2021-03-12T06:59:30.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要适配"><a href="#为什么要适配" class="headerlink" title="为什么要适配"></a>为什么要适配</h2><p>由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。</p><p>尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128142240773.png" alt="image-20210128142240773"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸指 <strong>屏幕对角线的长度</strong>，单位是 <em>英寸</em>，一英寸 = 2.54 厘米</p><blockquote><p>常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多</p></blockquote><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>屏幕分辨率是指在 横纵方向上的像素点数，单位是 <em>px</em> ，1px = 1个像素点。</p><p>一般以 纵向像素 <em> 横向像素，如 1920 </em> 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。</p><blockquote><p>单位:  px(pixel) ，1 px = 1像素点</p><p>Android 手机常见的分辨率： 320 <em> 480    480 </em> 800  720 <em> 1280  1080 </em> 1920</p><p>UI 设计图一般会以 px 作为统一的计量单位</p></blockquote><h3 id="屏幕像素密度"><a href="#屏幕像素密度" class="headerlink" title="屏幕像素密度"></a>屏幕像素密度</h3><p>屏幕像素密度是指 <strong>每英寸上的像素点</strong>， 单位是 <em>dpi</em>, 即 “dot per inch” 的缩写。</p><p>屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch</p><blockquote><p>假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi</p></blockquote><p>Android 手机对每类手机屏幕大小都有一个相应的屏幕像素密度</p><table><thead><tr><th>密度类型</th><th>代表的分辨率 px</th><th>屏幕像素密度 dpi</th></tr></thead><tbody><tr><td>低密度（ldpi）</td><td>240 * 320</td><td>120</td></tr><tr><td>中密度（mdpi）</td><td>320 * 480</td><td>160</td></tr><tr><td>高密度（hdpi）</td><td>480 * 800</td><td>240</td></tr><tr><td>超高密度（xhdpi）</td><td>720 * 1280</td><td>320</td></tr><tr><td>超超高密度（xxhdpi）</td><td>1080 * 1920</td><td>480</td></tr></tbody></table><h3 id="屏幕尺寸、分辨率、像素密度三者关系"><a href="#屏幕尺寸、分辨率、像素密度三者关系" class="headerlink" title="屏幕尺寸、分辨率、像素密度三者关系"></a>屏幕尺寸、分辨率、像素密度三者关系</h3><p>一部手机的分辨率是 <strong>宽 x 高</strong>， 屏幕大小是以寸为单位，三者关系为:</p><p>密度 dp = 像素 px / 屏幕大小 inch</p><p>密度（dpi） = $\frac {\sqrt{宽^2 + 高^2}}{屏幕大小} $</p><ol><li>密度即每英寸的像素点</li><li>勾股定理求出手机的对角线物理尺寸</li><li>再储以屏幕大小即可</li></ol><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128150307492.png" alt="image-20210128150307492"></p><h3 id="密度无关像素"><a href="#密度无关像素" class="headerlink" title="密度无关像素"></a>密度无关像素</h3><p><code>density-independent pixel</code> 叫做 <code>dp</code>  或 <code>dip</code> ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。</p><blockquote><p>Android 开发时用 dp 而不是 px 单位设置图片大小，是  Android 特有的单位</p><p>场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 <em> 800 分辨率的设备上应为 240 px. 在 320 </em> 480 的设备上设置为 160 px。</p><p>如果使用 dp 为单位，在两种分辨率下，  160dp 都显示为屏幕一半的长度。</p></blockquote><h3 id="dp-与-px-的转换"><a href="#dp-与-px-的转换" class="headerlink" title="dp 与 px 的转换"></a>dp 与 px 的转换</h3><p><code>px = dp * (dpi / 160)</code></p><table><thead><tr><th>密度类型</th><th>代表的分辨率 px</th><th>屏幕密度 dpi</th><th>换算（px/dp)</th><th>比例</th></tr></thead><tbody><tr><td>低密度 ldpi</td><td>240 x 320</td><td>120</td><td>1dp = 0.75px</td><td>3</td></tr><tr><td>中密度 mdpi</td><td>320 x 480</td><td>160</td><td>1dp = 1px</td><td>4</td></tr><tr><td>高密度 hdpi</td><td>480 x 800</td><td>240</td><td>1dp = 1.5px</td><td>6</td></tr><tr><td>超高密度 xhdpi</td><td>720 x 1280</td><td>320</td><td>1dp = 2px</td><td>8</td></tr><tr><td>超超高密度 xxhdpi</td><td>1080 x 1920</td><td>480</td><td>1dp = 3px</td><td>12</td></tr></tbody></table><p>在 Android 中，规定 以 <code>160dpi</code> 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px</p><h3 id="独立比例像素"><a href="#独立比例像素" class="headerlink" title="独立比例像素"></a>独立比例像素</h3><p><code>sp</code>, <code>scale-independent pixels</code>, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="使用备用布局-使用限定符"><a href="#使用备用布局-使用限定符" class="headerlink" title="使用备用布局-使用限定符"></a>使用备用布局-使用限定符</h3><ul><li>尺寸限定符</li><li>使用最小宽度限定符</li><li>布局别名</li><li>屏幕方向限定符</li></ul><p><strong>最小宽度限定符： </strong></p><p>通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。</p><h3 id="创建可拉抻的九宫格位图"><a href="#创建可拉抻的九宫格位图" class="headerlink" title="创建可拉抻的九宫格位图"></a>创建可拉抻的九宫格位图</h3><p>九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。</p><h3 id="布局选择"><a href="#布局选择" class="headerlink" title="布局选择"></a>布局选择</h3><ul><li>线性布局（LinearLayout)</li><li>相对布局（RelativeLayout）</li><li>帧布局（FrameLayout）</li><li>绝对布局（AbsoluteLayout）</li><li>约束布局（ConstraintLayout）</li></ul><h3 id="使用自适应尺寸"><a href="#使用自适应尺寸" class="headerlink" title="使用自适应尺寸"></a>使用自适应尺寸</h3><ul><li>wrap_content</li><li>match_parent</li><li>weight</li><li>dp</li></ul><p>不要使用 px</p><h3 id="百分比适配"><a href="#百分比适配" class="headerlink" title="百分比适配"></a>百分比适配</h3><ol><li>以某一分辨率为基准，生成所有分辨率对应像素数列表</li><li>将生成像素数列表存放在 res 目录下对应的 value 文件下</li><li>根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以</li></ol><h3 id="使用约束布局"><a href="#使用约束布局" class="headerlink" title="使用约束布局"></a>使用约束布局</h3><p>ConstraintLayout</p><h3 id="今日头条适配方案"><a href="#今日头条适配方案" class="headerlink" title="今日头条适配方案"></a>今日头条适配方案</h3><p><code>px 值 = dp 值 * metrics.density</code>  这里的 <code>density</code> 是手机的屏幕密度，由系统提供。不同的手机的 <code>density</code> 不同，所以我们不能直接使用系统的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要适配&quot;&gt;&lt;a href=&quot;#为什么要适配&quot; class=&quot;headerlink&quot; title=&quot;为什么要适配&quot;&gt;&lt;/a&gt;为什么要适配&lt;/h2&gt;&lt;p&gt;由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。&lt;/p&gt;
&lt;p&gt;尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="适配" scheme="http://xiaoman.ren/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android 版本适配</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/适配/Android 版本适配/</id>
    <published>2021-03-12T06:59:30.437Z</published>
    <updated>2021-03-12T06:59:30.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h3><p><code>targetSdkVersion</code>： 目标 SDK 版本，也就是我们最高适配的 SDK 版本</p><p>不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。</p><p>旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 <code>ctx.getApplicatioinInfo().targetSdkVersion()</code> 的判断，因此只要 APK 的 <code>targetSdkVersion</code> 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。</p><a id="more"></a><h3 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h3><p><code>compileSdkVersion</code> 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 <strong>在编译的时候检查代码的错误和警告，提示开发者修改和优化</strong></p><h3 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h3><p><code>minSdkVersion</code>: 最小 SDK 版本，也就是我们最低支持的 SDK 版本</p><ul><li>告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK</li><li>默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。</li></ul><p>如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种</p><ul><li><p>运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(android.os.Build.VERSION_SDK_INIT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>保证功能的完整性，通过低版本的 API 实现功能</p></li></ul><h2 id="Android-6-0-适配"><a href="#Android-6-0-适配" class="headerlink" title="Android 6.0 适配"></a>Android 6.0 适配</h2><h3 id="运行时权限请求"><a href="#运行时权限请求" class="headerlink" title="运行时权限请求"></a>运行时权限请求</h3><p>从 <code>Android 6.0(api &gt;= 23)</code> 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种</p><ul><li>正常权限。在 <code>AndroidManifest</code> 列出了正常权限，系统将自动授予该权限</li><li>危险权限。在 <code>AndroidManifest</code> 中列出了危险权限，用户必须明确批准您的应用使用这些权限。</li></ul><h2 id="Android-7-0-适配"><a href="#Android-7-0-适配" class="headerlink" title="Android 7.0 适配"></a>Android 7.0 适配</h2><h3 id="应用间共享文件限制"><a href="#应用间共享文件限制" class="headerlink" title="应用间共享文件限制"></a>应用间共享文件限制</h3><p>在 <code>Android 7.0</code> 系统上， Android 框架强制执行了 <code>ScrictMode API</code> 政策，禁止向应用外公开 <code>file://URI</code> 如果一项包含文件 <code>file://URI</code> 类型的 <code>Intent</code> 离开了你的应用，即调用 <code>Uri.from(file)</code> 传递文件路径给第三方应用，会出现 <code>FileUriExposedException</code> 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。</p><p>如果要在 <strong>应用见共享文件</strong> ，可以发送 <code>content://URI</code>类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 <code>FileProvider</code> 类</p><p>步骤如下：</p><ul><li><p>在 <code>AndroidManifest.xml</code> 清单文件中注册 <code>provider</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.demo.***.provider"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:resource</span>=<span class="string">"@xml/file_provider_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>export</code> 为 <code>false</code></p></li><li><p><code>grantUriPermissions</code> 表示授予 <code>URI</code> 临时访问权限</p></li></ul></li><li><p>指定共享目录</p><p>上面的 <code>android:resource=&quot;@xml/file_provider_paths&quot;</code> 指定了共享的目录，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 代表设备的根目录 new File("/") --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">name</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 代表 content.getFilesDir()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">files-path</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">"captured_media"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">path</span>=<span class="string">"captrued_media"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 代表 content.getCacheDir() --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">"cache"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">path</span>=<span class="string">"appCache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 代表 Environment.getExtrnalStorageDirectory() --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">name</span>=<span class="string">"data"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">path</span>=<span class="string">"Android"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 代表 content.getExternalFilesDirs()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">name</span>=<span class="string">"external"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代表 getExternalCacheDirs() --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">name</span>=<span class="string">"external"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>通过 `FileProvider` 打开下载完的 APK 实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">getOpenFileIntent</span><span class="params">(Context context, DownloadResponse downloadReponse)</span> </span>&#123;</span><br><span class="line">      File file = <span class="keyword">new</span> File(downloadResponse.getParentPath(), downloadResponse.getFileName());</span><br><span class="line">      <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">      intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">      intent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">      <span class="keyword">if</span>(Build.VERSION.SDK_INI &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">          intent.setFlag(Intern.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">          Uri contentUri = FileProvider.getUriForFile(context, <span class="string">"com.demo.***.provider"</span>， file);</span><br><span class="line">          intent.setDataAndType(contentUri, downloadResponse.getMimeType());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          intent.setDataAndType(Uri.fromFile(file), downloadResponse.getMimeType());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(!context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="系统广播删除"><a href="#系统广播删除" class="headerlink" title="系统广播删除"></a>系统广播删除</h3><p>Android N 管理了三项系统广播:<em>网络状态变更广播</em>、<em>拍照广播</em>  和 <em>录像广播</em></p><p>只有通过 <strong>动态注册</strong> 的方式才能收到网络变化的广播， 在 <code>AndroidManifest.xml</code> 中静态注册的无法收到</p><h2 id="Android-8-0-适配"><a href="#Android-8-0-适配" class="headerlink" title="Android 8.0 适配"></a>Android 8.0 适配</h2><h3 id="通知渠道"><a href="#通知渠道" class="headerlink" title="通知渠道"></a>通知渠道</h3><p>在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DownloadNotifier(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODE.O) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarings</span>(<span class="string">"all"</span>)</span><br><span class="line">        <span class="keyword">final</span> NotificationChanncl channel = <span class="keyword">new</span> NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotifationManager.IMPORTANCE_HIGH);</span><br><span class="line">        mManager.createNotificationChannel(channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悬浮窗（工具类-APP-使用）"><a href="#悬浮窗（工具类-APP-使用）" class="headerlink" title="悬浮窗（工具类 APP 使用）"></a>悬浮窗（工具类 APP 使用）</h3><p>8.0 新增了一种悬浮窗的窗口类型， <code>TYPE_APPLICATION_OVERLAY</code>, 如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的下方</p><ul><li>TYPE_PHONE</li><li>TYPE_PRIORITY_PHONE</li><li>TYPE_SYSTEM_ALERT</li><li>TYPE_SYSTEM_OVERLAY</li><li>TYPE_SYSTEM_ERROR</li><li>TYPE_TOAST</li></ul><p>如果该应用的 <code>targetSdkVersion &gt;= 26</code> ,则应用只能使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来创建悬浮窗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;<span class="comment">//8.0新特性</span></span><br><span class="line">   mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明窗口不允许锁定屏幕旋转"><a href="#透明窗口不允许锁定屏幕旋转" class="headerlink" title="透明窗口不允许锁定屏幕旋转"></a>透明窗口不允许锁定屏幕旋转</h3><p>之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">".HomeActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|screenSize"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@styple/Base.Theme.CirclePage"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>透明窗口</strong>+<strong>固定屏幕方向</strong> 会抛出异常</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation</span><br></pre></td></tr></table></figure><p>解决方案有两种：</p><ul><li>适配横屏，去掉固定屏幕方向的限制</li><li>仅在滑动开始的时候设置窗口透明</li></ul><h3 id="Apk-安装需要权限"><a href="#Apk-安装需要权限" class="headerlink" title="Apk 安装需要权限"></a>Apk 安装需要权限</h3><p>在安装 APK 是需要申请安装权限 <code>REQUEST_INSTALL_PACKAGES</code></p><h2 id="Android-9-0-适配"><a href="#Android-9-0-适配" class="headerlink" title="Android 9.0 适配"></a>Android 9.0 适配</h2><h3 id="明文-HTTP-请求限制"><a href="#明文-HTTP-请求限制" class="headerlink" title="明文 HTTP 请求限制"></a>明文 HTTP 请求限制</h3><p>9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止</p><ul><li><p>在 <code>res/xml</code> 文件夹啊下常见 <code>network_security_config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>AndroidManifest.xml</code> 的 <code>&lt;application</code> 标签下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>或者是改用 <code>HTTPS</code> 方式请求</p><h2 id="Android-10-0-适配"><a href="#Android-10-0-适配" class="headerlink" title="Android 10.0 适配"></a>Android 10.0 适配</h2><h3 id="分区存储"><a href="#分区存储" class="headerlink" title="分区存储"></a>分区存储</h3><p>如果还没有准备好适配的功能，可以在 <code>AndroidManifest.xml</code> 中添加 <code>requestLegacyExternalStorage</code> 来暂时处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:requestLegacyExternalStorage</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Android Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由<strong>于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。</strong></p><p><strong>沙盒</strong>就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 </p><blockquote><p>Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 <font color="red">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) </font>中</p></blockquote><p><strong>适配：</strong></p><ol><li>访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限，丙炔无需特定权限，就可以访问沙盒中的文件。</li><li>访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 <code>READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO</code>，时期内那个方法同原来的存储权限</li><li>访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件</li><li>访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件，</li></ol><h3 id="设备唯一标识符"><a href="#设备唯一标识符" class="headerlink" title="设备唯一标识符"></a>设备唯一标识符</h3><p>访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 <code>READ_PRIVILEGED_PHONE_STATE</code> 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 <code>READ_PHONE_STATE</code> 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((TelephonyManager)getActivity().getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();</span><br></pre></td></tr></table></figure><p><strong>但是，</strong>上面的代码会返回空值（targetASdkVersion &lt;= P）或者报错(targetSdkVersion == Q) ，且官网所说的 <code>READ_PRIVILEGED_PHONE_STATE</code> 权限只提供给系统 app，<font color="red"><strong>所以这个方法行不通</strong></font></p><p>Google 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String serial = <span class="keyword">null</span>;</span><br><span class="line">    String m_szDevIdShort = <span class="string">"35"</span> + </span><br><span class="line">        Build.BOARD.length() % <span class="number">10</span> + Build.BRAND.length() % <span class="number">10</span> + </span><br><span class="line">        Build.CPU_ABI.length() % <span class="number">10</span> + Build.DEVICE.length() % <span class="number">10</span> +</span><br><span class="line">        Build.DISPLAY.length() % <span class="number">10</span> + Build.HOST.length() % <span class="number">10</span> +</span><br><span class="line">        Build.ID.length() % <span class="number">10</span> + Build.MANUFACTURER.length() % <span class="number">10</span> +</span><br><span class="line">        Build.MODEL.length() % <span class="number">10</span> + Build.PRODUCT.length() % <span class="number">10</span> +</span><br><span class="line">        Build.TAGS.length() % <span class="number">10</span> + Build.TYPE.length() % <span class="number">10</span> +</span><br><span class="line">        Build.USER.length() % <span class="number">10</span>; <span class="comment">//13 位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        serial = android.os.Build.getSerial();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serial = Build.SERIAL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//API&gt;=9 使用serial号</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    <span class="comment">//serial需要一个初始化</span></span><br><span class="line">    serial = <span class="string">"serial"</span>; <span class="comment">// 随便一个初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//使用硬件信息拼凑出来的15位号码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非-SDK-接口限制"><a href="#非-SDK-接口限制" class="headerlink" title="非 SDK 接口限制"></a>非 SDK 接口限制</h3><p>为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。</p><p><strong>非 SDK 接口</strong> 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 <code>target &gt;= P</code> 或者 <code>target &gt;= Q</code> 的设备上被限制使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;h3 id=&quot;targetSdkVersion&quot;&gt;&lt;a href=&quot;#targetSdkVersion&quot; class=&quot;headerlink&quot; title=&quot;targetSdkVersion&quot;&gt;&lt;/a&gt;targetSdkVersion&lt;/h3&gt;&lt;p&gt;&lt;code&gt;targetSdkVersion&lt;/code&gt;： 目标 SDK 版本，也就是我们最高适配的 SDK 版本&lt;/p&gt;
&lt;p&gt;不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。&lt;/p&gt;
&lt;p&gt;旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 &lt;code&gt;ctx.getApplicatioinInfo().targetSdkVersion()&lt;/code&gt; 的判断，因此只要 APK 的 &lt;code&gt;targetSdkVersion&lt;/code&gt; 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="适配" scheme="http://xiaoman.ren/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android 磁盘空间优化</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/性能优化/磁盘空间优化/</id>
    <published>2021-03-12T06:59:30.435Z</published>
    <updated>2021-03-12T06:59:30.435Z</updated>
    
    <content type="html"><![CDATA[<p>资源类性能就像是撑起冰山一角的下面的冰层，我们称之为 <code>3 + 1 + 1</code> 。 <code>3 + 1</code>  时传统的 -磁盘、cpu 和 内存，加 1 是与环境密切相关的网络；最后一个加 1 则是因为移动网络而显得特别重要的电池（耗电）。</p><p>因为冰山一角体现出来的交互类性能，包括流畅度、时延等，实际上都是资源问题。例如流畅度问题，可以是内存的垃圾回收太频繁导致的，因为有些 GC 会 STOP THE WORLD, 又可以是 CPU 问题， decode 图片开了过多的子线程，导致主线程的 CPU  资源被争抢；更可以是再主线程中读/写磁盘，磁盘读/写耗时抖一抖、页面也就跟着卡一下。所以关注资源类性能，其实是关注问题的本质去解决问题的方式。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>再没有SSD 磁盘前，大家都觉着 HDD 很好用。对于外行来说，磁盘 I/0 性能总是最容易被忽略的，经理会更集中再 CPU 上。但内行人都知道，性能无非是 CPU 密集型和 I/O 密集型，磁盘 I/O 就是其中之一。</p><p>在设备长时间使用，磁盘空间不足。应用触发大量随机写操作，都会导致磁盘的负载，磁盘 I/O 的耗时会产生剧烈的波动， App 能做的只有一件事儿，即减少磁盘 I/O d 操作量，特别是主线程的操作量。</p><a id="more"></a><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>那么我们要如何发现、定位、解决这些磁盘 I/O 的性能问题呢？</p><table><thead><tr><th>工具</th><th>问题</th><th>能力</th></tr></thead><tbody><tr><td>Systrace/Strace</td><td>主线程I/O，I/O操作耗时过长</td><td>发现</td></tr><tr><td>STRICTMODE</td><td>主线程I/O</td><td>发现+ 定位</td></tr><tr><td>I/O Monitor</td><td>主线程I/O，多余I/O，Buffer 国小等</td><td>发现+ 定位</td></tr><tr><td>SQL I/O Monitor</td><td>主线程I/O，全表扫描，不合理事务等</td><td>发现+ 定位</td></tr></tbody></table><h4 id="STRICTMODE"><a href="#STRICTMODE" class="headerlink" title="STRICTMODE"></a><strong>STRICTMODE</strong></h4><p>严苛模式，在 Application 的 <code>onCreate()</code> 中定义，也是入门级的必备工具。可以发现并定位磁盘 I/O 问题中影响最大的主线程 I/O，使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(DEVELOPER_MODE) &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                                  .detectDiskReads()</span><br><span class="line">                                  .detectDiskWrites()</span><br><span class="line">                                  .detectNetwork()</span><br><span class="line">                                  .penaltyLog()</span><br><span class="line">                                  .build());</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理也很简单，主要是文件操作(BlockGuardOs.java)、数据库操作、和 SharedPreferences 操作的接口中插入检查的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pwrite</span><span class="params">(FileDescriptor fd, ByteBuffer buffer,<span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onWriteToDisk();</span><br><span class="line">    <span class="keyword">return</span> os.pwrite(fd, buffer, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part of blockguard.Policy interface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWriteToDisk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((mPolicyMask &amp; DETECT_DISK_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tooManyViolationsThisLoop()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BlockGuard.BlockGuardPolicyException e = <span class="keyword">new</span> StrictModeDiskWriteViolation(mPolicyMask);</span><br><span class="line">    e.fillInStackTrace();</span><br><span class="line">    startHandlingViolationException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><h4 id="冗余的文件读写"><a href="#冗余的文件读写" class="headerlink" title="冗余的文件读写"></a>冗余的文件读写</h4><p>每次打开、关闭或者读 / 写文件，操作系统都需要从用户态到内核态的转换，这种状态的切换本身是很消耗性能的，所以为了提高文件的读 / 写效率，就需要减少用户态和内核态的切换。使用缓存可以避免重复读 / 写，对于需要多次访问的数据，在第一次取出数据时，将数据放到缓存中，下次再访问这些数据时，就可以从缓存中取出来。</p><p><strong>SharedPreferences</strong></p><p>Android 系统使用 SharedPreferences 文件来保存数据很方便，再需要保存数据时的地方一次 <code>commit</code> 就可以。但很多开发同学可能并不知道每调用一次 <code>commit()</code> 就会对应一次文件的打开和关闭，从而造成因 <code>commit()</code> 方法的随意调用而导致文件的重复打开和关闭。</p><p>也就是说，当我们有多个字段需要保存时，只保留最后一个 <code>commit()</code> 方法即可。使用缓存来保存多次写入的数据，延迟写入，从而减少写入次数。</p><h4 id="主线程写入文件"><a href="#主线程写入文件" class="headerlink" title="主线程写入文件"></a>主线程写入文件</h4><p>我们要避免再主线程中进行 I/O 操作，尤其是写操作。因为写入的放大效应会让平时十多毫秒的操作方法几十倍，因此我们可以把 I/O 操作放到子线程中去执行。</p><h4 id="I-O-效率低"><a href="#I-O-效率低" class="headerlink" title="I/O 效率低"></a>I/O 效率低</h4><p><strong>选择合理的操作对象</strong></p><p>当读写文件时，使用不恰当的输入/输出流对象，就会造成 I/O 效率低的现象。比如，当我们使用 <code>ObjectOutputStream</code> 序列化磁盘时，会把内存中的每个对象保存到磁盘中，在保存对象的时候，每个数据成员会到来一次 I/O 操作。</p><p>那么我们可以在 <code>ObjectOutputStream</code> 上面封装一个输出流 <code>ByteArrayOutputStream</code> ，先将对象序列化后的信息写入到缓存区中，然后再一次性的写入到磁盘中。<strong>可以通过使用缓冲区，有效的减少磁盘 I/O 的次数</strong></p><table><br>    <tr><br>        <th></th><th></th><th>读 / 写方式</th><br>    </tr><br>    <tr><br>        <td rowspan="3">序列化写磁盘</td><td>优化前</td><td>ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td rowspan="2">优化后</td><td>BufferedOutputStream + ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td>ByteArrayOutputStream + ObjectOutputStream</td><br>    </tr><br>    <tr><br>        <td rowspan="3">序列化读磁盘</td><td>优化前</td><td>ObjectInputStream</td><br>    </tr><br>    <tr><br>    <td rowspan="2">优化后</td><td>BufferedInputStream + ObjectInputStream</td><br>    </tr><br>    <tr><br>        <td>ByteArrayInputStream + ObjectInputStream</td><br>    </tr><br></table><p><strong>合理的设置 Buffer 的大小</strong></p><p>我们可以做一个有趣的实验，如果有一个 1M 大小的文件需要我们读取，我们看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">gethash</span><span class="params">(String fileName, String hashType)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    MessageDigest md5 = MessageDigest.getInstance(hashType);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> numRead = <span class="number">0</span>;(numRed = is.read(buffer)) &gt; <span class="number">0</span>;)&#123;</span><br><span class="line">        md5.update(buffer, <span class="number">0</span>, numRead);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    <span class="keyword">return</span> toHexString(md5.digest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，程序中设置的 Buffer 大小为 1KB， 也就是说 1M 的数据，要读取 1025 次才能确保全部读取完成。那就需要对文件执行 1025 次的访问，大大增加的访问次数，就会降低读写效率。当然 Buffer 有不是越大越好。如果 Buffer 太大， 会导致申请 Buffer 的时间过长，反而整体效率不高。这里推荐使用的 Buffer 大小为 8kb，和 Java 默认的 Buffer 大小一致， Buffer 大小至少应为 4kb。</p><h4 id="重复开关数据库"><a href="#重复开关数据库" class="headerlink" title="重复开关数据库"></a>重复开关数据库</h4><p>在 <code>SQLiteDatabase</code> 的源码中，<code>getWriteableDatebase()</code> 方法的注释说明：一旦打开数据库，该链接就会被缓存，供下次使用，只有当真不需要时，调用 <code>close</code> 关闭即可。</p><p>因为数据库的开启是要给耗时的过程，每次打开数据库，同时会有一些 I/O 操作，且不建议在主线程中进行。那么我们可以在数据库打开后，先不要关闭，在应用程序退出时再关闭。</p><h4 id="AUTOINCREMENT"><a href="#AUTOINCREMENT" class="headerlink" title="AUTOINCREMENT"></a>AUTOINCREMENT</h4><p>针对数据库 INTEGER 型主键使用。其作用是保证主键是严格单调递增的，但如果出现删除或设置最大值，就会导致旧值被复用等问题。严格上来说，也不是很安全。</p><p>SQLite 创建一个叫 sqlite_sequence 的内部表来记录该表使用的最大行数。如果指定使用 UTOINCREMENT 来创建表，则 sqlite_sequence 也随之创建， UPDATE、INSERT、DELETE 语句都会修改 sqlite_sequence 的内容。因为维护 sqlite_sequence 表带来的额外开销会导致 INSERT 的效率降低。</p><h4 id="Bitmap-解吗"><a href="#Bitmap-解吗" class="headerlink" title="Bitmap 解吗"></a>Bitmap 解吗</h4><p>随着 Android SDK 升级， Google 修改了 Bitmap 解码的实现。</p><ul><li>解码 Bitmap 不要使用 decodeFile，在 4.4 以上系统效率不高</li><li>解码 Bitmap 使用 decodeStream，同时传入 BufferedInputStream</li><li>decodeResource 同样存在性能问题，可以使用 decodeResourseStream</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;资源类性能就像是撑起冰山一角的下面的冰层，我们称之为 &lt;code&gt;3 + 1 + 1&lt;/code&gt; 。 &lt;code&gt;3 + 1&lt;/code&gt;  时传统的 -磁盘、cpu 和 内存，加 1 是与环境密切相关的网络；最后一个加 1 则是因为移动网络而显得特别重要的电池（耗电）。&lt;/p&gt;
&lt;p&gt;因为冰山一角体现出来的交互类性能，包括流畅度、时延等，实际上都是资源问题。例如流畅度问题，可以是内存的垃圾回收太频繁导致的，因为有些 GC 会 STOP THE WORLD, 又可以是 CPU 问题， decode 图片开了过多的子线程，导致主线程的 CPU  资源被争抢；更可以是再主线程中读/写磁盘，磁盘读/写耗时抖一抖、页面也就跟着卡一下。所以关注资源类性能，其实是关注问题的本质去解决问题的方式。&lt;/p&gt;
&lt;h2 id=&quot;磁盘&quot;&gt;&lt;a href=&quot;#磁盘&quot; class=&quot;headerlink&quot; title=&quot;磁盘&quot;&gt;&lt;/a&gt;磁盘&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;再没有SSD 磁盘前，大家都觉着 HDD 很好用。对于外行来说，磁盘 I/0 性能总是最容易被忽略的，经理会更集中再 CPU 上。但内行人都知道，性能无非是 CPU 密集型和 I/O 密集型，磁盘 I/O 就是其中之一。&lt;/p&gt;
&lt;p&gt;在设备长时间使用，磁盘空间不足。应用触发大量随机写操作，都会导致磁盘的负载，磁盘 I/O 的耗时会产生剧烈的波动， App 能做的只有一件事儿，即减少磁盘 I/O d 操作量，特别是主线程的操作量。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="资源类性能优化" scheme="http://xiaoman.ren/tags/%E8%B5%84%E6%BA%90%E7%B1%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>WebView 异常篇</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/WebView%20%E5%BC%82%E5%B8%B8%E7%AF%87/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/WebView 异常篇/</id>
    <published>2021-03-12T06:59:30.434Z</published>
    <updated>2021-03-22T15:59:29.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebView-漏洞"><a href="#WebView-漏洞" class="headerlink" title="WebView 漏洞"></a>WebView 漏洞</h2><h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><p>WebView 中，主要有三种漏洞问题</p><ol><li>任意代码执行漏洞</li><li>密码明文存储漏洞</li><li>域控制不严格漏洞</li></ol><a id="more"></a><h3 id="WebView-任意代码执行漏洞"><a href="#WebView-任意代码执行漏洞" class="headerlink" title="WebView 任意代码执行漏洞"></a>WebView 任意代码执行漏洞</h3><p>产生漏洞原因有三</p><ol><li>WebView 中 <code>addJavascriptInterface()</code> 接口</li><li>WebView 内置导出的 <code>searchBoxJavaBridge_</code> 对象</li><li>WebView 内置导出的 <code>accessibility</code> 和 <code>accessibilityTraversal</code> Object 对象</li></ol><h4 id="addJavascriptInterface-引起远程代码执行漏洞"><a href="#addJavascriptInterface-引起远程代码执行漏洞" class="headerlink" title="addJavascriptInterface() 引起远程代码执行漏洞"></a>addJavascriptInterface() 引起远程代码执行漏洞</h4><p><strong>产生原因：</strong></p><p>JS 调用 Android 的其中一个方式通过 <code>addJavascriptInterface</code> 接口进行映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webview.addJavascriptInterface(<span class="keyword">new</span> JsCallAndroidInterface(), <span class="string">"JsCallAndroidInterface"</span>);</span><br><span class="line"><span class="comment">// 参数一： Android 本地对象</span></span><br><span class="line"><span class="comment">// 参数二： JS 对象</span></span><br><span class="line"><span class="comment">// 通过对象映射将 Android 中的本地对象和 JS  中的对象进行关联，从而实现 JS 调用 Android 对象和方法</span></span><br></pre></td></tr></table></figure><p><strong>当 JS 拿到 Android 对象后，可以调用这对象中所有的方法，包括系统类（java.lang.Runtime), 从而进行任意代码执行</strong></p><blockquote><p>可以执行命令获取本地设备的 SD卡中的文件等信息，造成信息泄漏</p></blockquote><p>结合 Java 反射机制，具体获取系统类的描述</p><ul><li><p>Android 中的对象有一个公共方法， getClass()</p></li><li><p>该方法可以获取到当前类类型</p></li><li><p>该类有关键方法,Class.forName();</p></li><li><p>使用这个方法可以加载一个类</p></li><li><p>获取到类对象后，可以执行本地命令</p><p>JS 攻击本地核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmd</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 遍历 Window 对象</span></span><br><span class="line"><span class="comment">// 目的是为了找到包含 getClass() 的对象</span></span><br><span class="line"><span class="comment">// 因为 Android 映射的 JS 对象也在 Window 中，一定会拿到</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span><br><span class="line"><span class="comment">// 利用反射调用 forName() 得到 Runtime 类</span></span><br><span class="line">alert(obj);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 之后，可以调用静态方法来执行一些命令，比如访问文件</span></span><br><span class="line">        getMethod(<span class="string">"getRuntime"</span>, <span class="literal">null</span>).invoke(<span class="literal">null</span>, <span class="literal">null</span>).exec(cmd);</span><br><span class="line">        <span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私信息的危险</span></span><br><span class="line">        <span class="comment">// 如果执行完访问文件的命令后，就可以得到文件名信息等</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一些 APP 通过扫描二维码打开一个外部网页时，攻击者就可以执行这段 js 代码进行漏洞攻击</p></li></ul><p><strong>解决方案：</strong></p><ol><li>在 Android 4.2 版本之后<br>Google 在 Android 4.2 版本中规定对被调用的函数以 <code>@JavascriptInterface</code> 进行注解，从而避免漏洞攻击</li><li>在 Android 4.2 版本之前<br>在 Android 4.2 之前采用拦截 <code>prompt()</code> 进行漏洞修复<ol><li>继承 WebView ，重写 <code>addJavascriptInterface()</code> ，然后内部自己维护一个对象映射关系的 Map，将需要添加的 JS 接口放入 Map 中</li><li>每次当 WebView 加载页面前加载一段本地的 JS 代码<ol><li>让 JS 调用 Javascript 方法：通过调用 prompt() 把 js 中的信息（含特定表示、方法名等）传递到 Android 端</li><li>在 Android 的 onJsPrompt() 中，解析参数信息，再通过反射机制调用 Java 对象的方法，来实现 JS 调用 Android 的安全性</li></ol></li></ol></li></ol><h4 id="searchBoxJavaBridge-接口引起的远程代码执行漏洞"><a href="#searchBoxJavaBridge-接口引起的远程代码执行漏洞" class="headerlink" title="searchBoxJavaBridge_接口引起的远程代码执行漏洞"></a>searchBoxJavaBridge_接口引起的远程代码执行漏洞</h4><p><strong>产生原因</strong></p><ul><li>Android 3.0 以下， Android 系统默认通过 searchBoxJavaBridge_ 的 Js 接口给WebView 添加一个 JS映射对象， searchBoxJavaBridge_</li><li>该接口可能被利用，实现远程任意代码</li></ul><p><strong>解决方案：</strong></p><p>删除 searchBoxJavaBridge_ 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用该方法移除</span></span><br><span class="line">removeJavascriptInterface();</span><br></pre></td></tr></table></figure><h4 id="accessibility-和-accessibilityTraversal-接口引起远程代码执行漏洞"><a href="#accessibility-和-accessibilityTraversal-接口引起远程代码执行漏洞" class="headerlink" title="accessibility 和 accessibilityTraversal 接口引起远程代码执行漏洞"></a>accessibility 和 accessibilityTraversal 接口引起远程代码执行漏洞</h4><p>与上述基本相同</p><h3 id="密码明文存储漏洞"><a href="#密码明文存储漏洞" class="headerlink" title="密码明文存储漏洞"></a>密码明文存储漏洞</h3><p><strong>问题分析：</strong></p><p>WebView 默认开启密码保存功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ul><li>开启后，再用户输入密码时，会弹出提示框，询问用户是否保存密码</li><li>如果选择”是”，密码会被明文保存到 <code>/data/data/com.package.name/databases/webview.db</code> 中，这样就有被盗取密码的危险</li></ul><p><strong>解决方案:</strong></p><p>关闭密码保存提醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSettings.setSavePassword(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="域控制不严格漏洞"><a href="#域控制不严格漏洞" class="headerlink" title="域控制不严格漏洞"></a>域控制不严格漏洞</h3><p><strong>问题分析：</strong></p><p>再Android里的 <code>WebViewActrivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_webview);</span><br><span class="line">        webView = findViewById(R.id.webview);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// webView.getSettings().setAllowFileAccess(false);</span></span><br><span class="line">        <span class="comment">// webView.getSettings().setAllowFileAccessFromFileURLs(true);</span></span><br><span class="line">        <span class="comment">// webView.getSettings().setAllowUniversalAccessFromFileURLs(true);</span></span><br><span class="line">        <span class="comment">// url = file://data/local/tmp/attack.html</span></span><br><span class="line">        String url = i.getData().toString();</span><br><span class="line">        webView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个 WebViewActivity 再 Manifest.xml 设置 exported 属性，表示：当前 Activity 是否可以被另外一个 Application  的组件启动</p><p><code>android:exported=&quot;true&quot;</code></p><p>即 A 应用可以通过 B 应用到处的 Activity 让 B 应用加载一个恶意的 file 协议的 url，从而可以获取 B 应用的内部私有文件，从而带来数据泄漏威胁</p><blockquote><p>具体：当其他应用启动此 Activity 时，intent 中的 data  直接被当作 url 来加载（假设传入来的 url 时 file://data/local/tmp/attack.html），其他 App 通过使用显式 ComponentName 或者其他类似方式就可以轻松启动该 web ViewActivity，并加载恶意 url</p></blockquote><p>那么 WebView 中 getSettings（）函数对 WebView 安全性的影响</p><ul><li>setAllowFileAccess()</li><li>setAllowFileAccessFromFileURLs()</li><li>setAllowUniversalAccessFromFileURLs()</li></ul><ol><li><p><strong>setAllowFileAccess()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置是否允 WebView 使用 file 协议</span></span><br><span class="line">webView.getSettings().setAllowFileAccess(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 默认设置为 true，即允许再 File 域下任意执行 JavaScript 代码</span></span><br></pre></td></tr></table></figure><p>使用 File 域加载的 js 代码能够使用进行 <em>同源策略跨域访问</em>，从而导致隐私信息泄漏</p><blockquote><ol><li>同源策略跨域访问：对私有目录文件进行访问</li><li>针对 IM 类产品，泄漏的是聊天信息、联系人等等</li><li>针对浏览器类软件， 泄漏的是 cookie 信息</li></ol></blockquote><p>如果不允许使用 file 协议，则不会出现上述威胁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setAllowFileAccess(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>但同时也限制了 WebView 的功能，使得不能加载本地的 HTML 文件</p></li></ol><p>   <strong>解决方案</strong></p><ol><li><p>对于不需要使用 file 协议的应用，禁用 file 协议</p><p><strong>setAllowFileAccess(false);</strong></p></li><li><p>对于需要使用 file 协议的用用，禁止 file 协议加载 JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAllowFileAccess(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 禁用文件协议使用 JavaScript</span></span><br><span class="line">setJavaScriptEnabled(!url.startsWith(<span class="string">"file://"</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>setAllowFileAccessFromFileURLs()</li></ol><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebView-漏洞&quot;&gt;&lt;a href=&quot;#WebView-漏洞&quot; class=&quot;headerlink&quot; title=&quot;WebView 漏洞&quot;&gt;&lt;/a&gt;WebView 漏洞&lt;/h2&gt;&lt;h3 id=&quot;主要问题&quot;&gt;&lt;a href=&quot;#主要问题&quot; class=&quot;headerlink&quot; title=&quot;主要问题&quot;&gt;&lt;/a&gt;主要问题&lt;/h3&gt;&lt;p&gt;WebView 中，主要有三种漏洞问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任意代码执行漏洞&lt;/li&gt;
&lt;li&gt;密码明文存储漏洞&lt;/li&gt;
&lt;li&gt;域控制不严格漏洞&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="WebView" scheme="http://xiaoman.ren/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>Handler 消息机制</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%90%86/Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/原理/Handler 消息机制/</id>
    <published>2021-03-12T06:59:30.434Z</published>
    <updated>2021-03-12T06:59:30.434Z</updated>
    
    <content type="html"><![CDATA[<p>Handler 消息机制，在整个 Android 系统中，有着很重要的地位。</p><p>他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.</p><p>本文旨在对源码进行预览分析。</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 <code>Handler</code> 机制的核心秘密。</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true" alt="Handler 类图"></p><a id="more"></a><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a><strong>类图分析</strong></h4><p>从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类</p><p><strong>Message：</strong> 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。</p><p><strong>Handler:</strong>     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用</p><p><strong>Looper:</strong>       这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的<em>大心脏</em></p><h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><p>看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 <code>main()</code> 方法中。</p><p>在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  <code>application</code> 和 <code>activity</code> 的工作,接下来我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                    args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                                            LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码，我主要分析 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code></p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><p>这里的标题虽然不是 <code>prepareMainLooper()</code>  的一个主要原因是他们的核心内容是一样的，只不过，<code>prepareMainLooper()</code> 是系统帮我们创建了要给不可退出的<code>Looper</code>，而 <code>prepare()</code> 方法创建的 <code>Looper</code> 是可以退出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">      * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">      * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>说到 <code>Looper</code> 的创建工作，这里就需要讲一下 <code>ThreadLocal</code> ， 它的意思是<strong>帮助我们在自己线程中保存一份它自己的本地变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。</p><p>面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h3><p>继续看源码，<code>Looper.loop();</code> 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行</p><p>这部分的源码比较长，捡主要的看和说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//..............</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...............</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread 中的 <code>main()</code> 方法，在最后一行，执行了我们的 <code>Looper.loop()</code> 方法， 进入后，我们可以看到 <code>loop()</code> 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 <code>prepareMainLooper()</code>  ，这也是系统帮我们创建的一个主线程<code>main</code> 。</p><p>接下来就慢慢分析一下 <code>loop</code> 都做了什么事情</p><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true" alt="looper.loop()"></p><p>从流程图上，我们简述了一下 <code>loop()</code> 方法，都做了些什么事情，下面就展开讲都做了什么</p><ol><li>首先获取当前线程的 looper 对象，如果不存在，则抛出异常</li><li>接着获取当前 Looper 绑定的消息队列<code>MessageQueue</code></li><li>进入循环，开始获取消息 <code>queue.next()</code></li><li>调用 <code>msg.target.dispathMessage(msg)</code> 分发消息</li><li>msg.recycleUnchecked()</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><strong>作用：</strong></p><p><code>Handler</code> 暴露给开发这的功能一共就两块</p><ul><li>发送消息</li><li>处理消息</li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><ul><li>sendMessage(Message msg)</li><li>sendMessageEmpty()</li><li>sendMessageAtTime(Message msg, long uptimeMillis)</li><li>sendMessageDelay(Message msg, long delay)</li><li>post(Runnable r)</li><li>…</li></ul><p>所有的发送消息的方法，最终都会去执行<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>, 当我们创建一个<code>Handler</code> 对象时, 会从当前线程的 Looper 中获取当前的消息队列<code>mQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们开始发送一条消息时，调用 <code>sendMessageAtTime</code> ，会将消息压入到消息队列中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码我们看到，在压入队列前，我们会将当前的 <code>Handler</code> 对象赋值给 <code>Message</code> 中的 <code>target</code> ，这也就是为什么 <code>message</code> 中会持有 <code>Handler</code> 的引用的原因。</p><h3 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h3><p>在说处理消息之前，我们先看一下 <code>Handler</code> 对<strong>消息的分发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Handle system messages here.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>当我们给 <code>Message</code> 设置了 <code>callback</code> 时，会直接触发 <code>Message</code> 的 <code>callback</code> 逻辑</li><li>如果我们在创建 <code>Handler</code> 时，有设置过 <code>Callback</code> ，则会调用由我们传入进来的 <code>Callback</code> 方法</li><li>如果以上两种情况都没有设置，那么会触发 <code>Handler</code> 自己 <code>handleMessage()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码的注解我们可以看出，当我们继承/创建一个 <code>Handler</code> 时，需要我们必须去实现的一个方法（前提是你需要它）</p><p><code>dispatchMessage</code> 最终时由 <code>loop()</code> 方法在拿取消息队列中的信息时，获取到 <code>Message</code> 对象， 通过 <code>Message</code> 持有的 <code>target</code> 调用。</p><h3 id="移除消息"><a href="#移除消息" class="headerlink" title="移除消息"></a>移除消息</h3><p>这里我们需要注意，当我们使用 <code>Handler</code> 处理消息时，通常都是一些异步任务，这时创建 <code>Handler</code> 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 <code>Activity</code> 无法被回收的情况。处理这种情况的方案就是，在 <code>Activity</code> 销毁时，我们需要将 <code>Handler</code> 中的消息进行释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(@Nullable Object token)</span> </span>&#123;</span><br><span class="line">    mQueue.removeCallbacksAndMessages(<span class="keyword">this</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>一种消息的载体，其中包含 <code>handler</code> 对象和一个任意类型的对象以及两个 int 型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息的执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Message</code> 本身是一个<strong>链表</strong> 的数据结构，这种数据结构，在<code>MessageQueue</code> 中获取消息时，可以有效的针对 <code>Handler</code> 发送进来的消息进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br></pre></td></tr></table></figure><p><code>Message</code> 持有了一个 <code>Handler</code> 对象，因此即使我们在同一个线程里面创建了多个 <code>Handler</code> 的对象， 也不会出现消息错乱的现象。</p><p><strong>Callback</strong></p><p>同时 Message 也支持设置 <code>Callback</code> 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="doctag">@link</span> #obtain() Message.obtain()&#125;).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Message m = sPool;</span><br><span class="line">               sPool = m.next;</span><br><span class="line">               m.next = <span class="keyword">null</span>;</span><br><span class="line">               m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">               sPoolSize--;</span><br><span class="line">               <span class="keyword">return</span> m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>Message</code> 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 <code>obtain()</code> 函数去获取。通过 <code>obtain()</code> 函数我们可以看出， <code>Message</code> 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 <code>Message</code> 对象时，反而是增加了系统的内存开销，而 <code>Message</code> 为我们提供的利器得不到发挥。</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                    + <span class="string">"is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 <code>Message</code> 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>存放所有消息的容器，既然是 <code>Queue</code> 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 <code>Looper</code> 关联的 <code>Handler</code> 添加</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>由 <code>Handler</code> 触发，将数据压入到队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码看出，在消息压入队列中时，发生了排序操作，</p><p>当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 <code>Message</code> 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。</p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">// 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 为到执行时间，设置下一次系统唤醒消息需要的时间</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// prevMsg ，即是同步消息，</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h4><p>一般是由系统发出，多数情况是用来处理<code>View</code> 的刷新，由<code>ViewRootImpl</code> 调用 <code>postSyncBarrier</code>，将消息插入到链表的头部，我们可以注意到 <code>msg</code> 的 <code>target</code> 对象为空，因为 每一个 <code>Message</code> 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">        <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">            <span class="comment">// 创建一个同步消息</span></span><br><span class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间</span></span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                <span class="comment">// 断开链表，将同步消息，插入到要立即执行的消息后面</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有要立即执行的消息，将同步消息插入到链表第一个节点</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，<code>ViewRootImpl</code> 会，并给 msg 的 <code>target</code> 重新赋值，优先执行。直到找到一个异步消息为止</p><p>当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>由 <code>loop</code> 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler 消息机制，在整个 Android 系统中，有着很重要的地位。&lt;/p&gt;
&lt;p&gt;他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.&lt;/p&gt;
&lt;p&gt;本文旨在对源码进行预览分析。&lt;/p&gt;
&lt;h2 id=&quot;UML-类图&quot;&gt;&lt;a href=&quot;#UML-类图&quot; class=&quot;headerlink&quot; title=&quot;UML 类图&quot;&gt;&lt;/a&gt;UML 类图&lt;/h2&gt;&lt;p&gt;先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 &lt;code&gt;Handler&lt;/code&gt; 机制的核心秘密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true&quot; alt=&quot;Handler 类图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://xiaoman.ren/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>自定义 ViewGroup</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/%E8%87%AA%E5%AE%9A%E4%B9%89%20ViewGroup/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/自定义 ViewGroup/</id>
    <published>2021-03-12T06:59:30.434Z</published>
    <updated>2021-03-12T06:59:30.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View-Group-的测量布局流程"><a href="#View-Group-的测量布局流程" class="headerlink" title="View Group 的测量布局流程"></a>View Group 的测量布局流程</h2><p><strong>View Group绘制和布局流程中的重点</strong></p><ol><li><p>View 在 <code>onMeasure</code> 方法中进行自我测量和保存。</p></li><li><p>ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置</p></li><li><p>关注 onMeasure 和 onLayout</p></li><li><p>父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View</p></li><li><p>自定义 View/ViewGroup，只需要关注下面三种需求：</p><ol><li>对于已有的 Android 自带 View，我们只需要重写他的 <code>onMeasure</code> 方法即可,<strong>修改一下这个尺寸就完成需求</strong></li><li>对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 <code>onMeasure</code></li><li>需要重写 <code>onMeasure</code> 和 <code>onLayout</code> 2个方法，来完成一个复杂的 <code>ViewGroup</code> 的测量和布局。</li></ol></li><li><p>onMeasure 的说明</p><p>widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制</p></li><li><p>理解父 view 对子 view 的限制</p><p>实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。<strong>这些以 layout 开头的属性，都是设置给父 view 看的</strong></p><blockquote><p>父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制</p></blockquote></li></ol><a id="more"></a><h2 id="自定义-BannerView"><a href="#自定义-BannerView" class="headerlink" title="自定义 BannerView"></a>自定义 BannerView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerImageView</span> <span class="keyword">extends</span> <span class="title">ImageView</span></span>&#123;</span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="keyword">float</span> ratio;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BannerImageView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BannerImageView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.BannerImageView);</span><br><span class="line">        ratio = array.getFloat(R.styleable.BannerImageView_ratio, <span class="number">1.0f</span>);</span><br><span class="line">        array.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自己的测量走一遍，因为这个方法内部会调用 setMeasureDimension() 来保存测量结果</span></span><br><span class="line">        <span class="comment">// 只有保存了以后，才能取得这个测量结果，否则获取不到</span></span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取测量结果</span></span><br><span class="line">        <span class="keyword">int</span> tempWidth = getMeasureWidth();</span><br><span class="line">        <span class="keyword">int</span> tempHeight = (<span class="keyword">int</span>) (tempWidth * ratio);</span><br><span class="line">        <span class="comment">// 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的</span></span><br><span class="line">        setMeasureDimension(tempWidth, tempHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-View-，完全自己写-onMeasure-方法"><a href="#自定义-View-，完全自己写-onMeasure-方法" class="headerlink" title="自定义 View ，完全自己写 onMeasure 方法"></a>自定义 View ，完全自己写 onMeasure 方法</h2><p>对于完全自定义  View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 <code>resolveSize</code> 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasureState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span>(specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpce.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span>(specSize &lt; size) &#123;</span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result | (childMeasureState * MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全自定义 view onMeasure 方法：</p><ol><li>先算自己想要的宽高</li><li>直接拿 <code>resolveSize</code> 方法处理一下</li><li>最后 <code>setMeasuredDimension</code> 保存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadingView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 圆的半径</span></span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="comment">// 外部矩形的起点</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">10</span>, top = <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    Paint mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadingView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadingView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LoadingView);</span><br><span class="line">        radius = typedArray.getInt(R.styleable.LoadingView_radius, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> width = left + radius * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = top + radius * <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug</span></span><br><span class="line">        <span class="comment">// 不用这个，就完全没有父 View 的感受</span></span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 画矩形</span></span><br><span class="line">        RectF oval = <span class="keyword">new</span> Rectf(left, top ,left + radius * <span class="number">2</span>, top + radius * <span class="number">2</span>);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        canvas.drawRect(oval, mPaint);</span><br><span class="line">        <span class="comment">// 画圆弧</span></span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        mPaint.setStrokeWidth(<span class="number">2</span>);</span><br><span class="line">        canvas.drawArc(oval, -<span class="number">90</span>, <span class="number">360</span>, <span class="keyword">false</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-ViewGroup"><a href="#自定义-ViewGroup" class="headerlink" title="自定义 ViewGroup"></a>自定义 ViewGroup</h2><p>注意以下几点：</p><ol><li>一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局</li><li>ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用  measureChild() 这个方法</li><li>计算出 View Group 自己的尺寸并保存，<code>onMeasuredDinmension</code></li><li>逼不得已需要重写<code>measureChild</code> 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 <code>measureChild</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从左到右布局，如果不够放，就直接另起一行layout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFlowLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFlowLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFlowLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *layout 算法，就是不够放，就另外放一行</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment"> *  无非就是前面 onMeasure 结束以后，你可以拿到所有子 View 和自己的测量宽高，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childTop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childBottom = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 已使用的 width</span></span><br><span class="line">        <span class="keyword">int</span> usedWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// customlayout 自己可使用的宽度</span></span><br><span class="line">        <span class="keyword">int</span> layoutWidth = getMeasuredWidth();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            <span class="comment">// 取得这个子 View 要求的宽度和高度</span></span><br><span class="line">            <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果宽度不够，就另外启动一行</span></span><br><span class="line">            <span class="keyword">if</span>(layoutWidth - usedWidth &lt; childWidth) &#123;</span><br><span class="line">                childLeft = <span class="number">0</span>;</span><br><span class="line">                usedWidth = <span class="number">0</span>;</span><br><span class="line">                childTop += childHeight;</span><br><span class="line">                childBottom = childTop + childHeight;</span><br><span class="line">                childView.layout(<span class="number">0</span>, childTop, childRight, childBottom);</span><br><span class="line">                usedWidth = usedWidth + childWidth;</span><br><span class="line">                childLeft = childWidth;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            childRight = childLeft + childWidth;</span><br><span class="line">            childBottom = childTop + childHeight;</span><br><span class="line">            childView.layout(childLeft, childTop, childRight, childBottom);</span><br><span class="line">            childLeft += childWidth;</span><br><span class="line">            usedWidth += childWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先取出 SimpleFlowLayout 的父 View 对他的测量限制</span></span><br><span class="line">        <span class="comment">// 只有知道了自己的宽高，才能限制子 View 的宽高</span></span><br><span class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> usedWidth = <span class="number">0</span>; <span class="comment">// 已使用宽度</span></span><br><span class="line">        <span class="keyword">int</span> remaining = <span class="number">0</span>;<span class="comment">// 剩余可用宽度</span></span><br><span class="line">        <span class="keyword">int</span> totalHeight = <span class="number">0</span>; <span class="comment">// 总高度</span></span><br><span class="line">        <span class="keyword">int</span> lineHeight = <span class="number">0</span>; <span class="comment">// 当前行高</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; getChildCount(); i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            LayoutParams lp = childView.getLayoutParams();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 先测量子View</span></span><br><span class="line">            measureChild(childView, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            <span class="comment">// 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度</span></span><br><span class="line">            remaining = widthSize - usedWidth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行</span></span><br><span class="line">            <span class="keyword">if</span>(childView.getMeasuredWidth &gt; remaining) &#123;</span><br><span class="line">                <span class="comment">// 另外启动一行</span></span><br><span class="line">                usedWidth = <span class="number">0</span>;</span><br><span class="line">                totalHeight += lineHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 已使用 width 进行累加</span></span><br><span class="line">            usedWidth += childView.getMeasuredWidth();</span><br><span class="line">            <span class="comment">// 当前 view 的高度</span></span><br><span class="line">   lineHeight = childView.getMeasuredHeight();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 如果 SimpleFlowLayout 的高度为 wrap_content  的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度</span></span><br><span class="line">        <span class="keyword">if</span>(heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            heightSize = totalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View-Group-的测量布局流程&quot;&gt;&lt;a href=&quot;#View-Group-的测量布局流程&quot; class=&quot;headerlink&quot; title=&quot;View Group 的测量布局流程&quot;&gt;&lt;/a&gt;View Group 的测量布局流程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;View Group绘制和布局流程中的重点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;View 在 &lt;code&gt;onMeasure&lt;/code&gt; 方法中进行自我测量和保存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关注 onMeasure 和 onLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义 View/ViewGroup，只需要关注下面三种需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于已有的 Android 自带 View，我们只需要重写他的 &lt;code&gt;onMeasure&lt;/code&gt; 方法即可,&lt;strong&gt;修改一下这个尺寸就完成需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 &lt;code&gt;onMeasure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要重写 &lt;code&gt;onMeasure&lt;/code&gt; 和 &lt;code&gt;onLayout&lt;/code&gt; 2个方法，来完成一个复杂的 &lt;code&gt;ViewGroup&lt;/code&gt; 的测量和布局。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onMeasure 的说明&lt;/p&gt;
&lt;p&gt;widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解父 view 对子 view 的限制&lt;/p&gt;
&lt;p&gt;实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。&lt;strong&gt;这些以 layout 开头的属性，都是设置给父 view 看的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="View" scheme="http://xiaoman.ren/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView 总结</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/RecyclerView%20%E6%80%BB%E7%BB%93/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/RecyclerView 总结/</id>
    <published>2021-03-12T06:59:30.433Z</published>
    <updated>2021-03-12T06:59:30.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List-View-的局限性"><a href="#List-View-的局限性" class="headerlink" title="List View 的局限性"></a>List View 的局限性</h2><ol><li>只有纵向列表一种布局</li><li>没有支持动画的  API</li><li>接口设计和系统不一致<ol><li>setOnItemClickListener()</li><li>setOnItemLongClickListener()</li><li>setSelection()</li></ol></li><li>没有强制实现 ViewHolder</li><li>性能不如 RecyclerView</li></ol><a id="more"></a><h2 id="RecyclerView-优势"><a href="#RecyclerView-优势" class="headerlink" title="RecyclerView 优势"></a>RecyclerView 优势</h2><ol><li>默认支持 Linear、Grid、Staggered Grid 三种布局</li><li>友好的 ItemAnimator 动画 API</li><li>强制实现 ViewHolder</li><li>解耦的架构设计</li><li>相对 ListView 性能更好</li></ol><p><img src="https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true" alt="image-20200709164241306"></p><p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p><p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p><p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p><p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p><p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p><p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p><h2 id="RecyclerView-的绘制"><a href="#RecyclerView-的绘制" class="headerlink" title="RecyclerView 的绘制"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p><h4 id="自动测量原理："><a href="#自动测量原理：" class="headerlink" title="自动测量原理："></a><strong>自动测量原理：</strong></h4><p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p><p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p><p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p><ul><li>STEP_START</li><li>STEP_LAYOUT</li><li>STEP_ANIMATIONS</li></ul><p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p><ul><li><p>dispatchLayoutStep1:  负责记录状态</p></li><li><p>dispatchLayoutStep2：负责布局</p></li><li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li></ul><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mAdapterHelper.hasUpdates() </span><br><span class="line">              || mLayout.getWidth() != getWidth() </span><br><span class="line">              || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// first 2 steps are done in onMeasure but looks like we have to run again due to changed size</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p><h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p><h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    </span><br><span class="line">    mState.mLayoutStep = State.STATE_ANIMATIONS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!mAnchorInfo.mValid </span><br><span class="line">      || mPendingScrollPosition != NO_POSITION </span><br><span class="line">      || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTIONTAIL</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout </span><br><span class="line">            ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">            : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayouStateToFillEnd(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很负责，大致流程如下</p><ul><li>找到 anchor点</li><li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li><li>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</li></ul><p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p><p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">        recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="keyword">while</span>((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start-layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>recycleViewsFromStart</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="keyword">int</span> dt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> limit = dt;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">if</span>(mShouldReverseLayout) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++)&#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span>(mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">              || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">        recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAndRecycleViewAt</span><span class="params">(<span class="keyword">int</span> index, Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = getChildAt(index);</span><br><span class="line">    removeViewAt(index);</span><br><span class="line">    recycler.recycleView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((layoutState.mInfinite || remainningSpace &gt; <span class="number">0</span>) </span><br><span class="line">     &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">    layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要又剩余空间，就会执行 layoutChunk 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)</span></span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    </span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span>(layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p><p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123;</span><br><span class="line">    addView(view);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addView(view, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p><p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p><h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>最后一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span>(mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);</span><br><span class="line">            mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span>(record == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;record.flags |= FLAT_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p><h3 id="缓存逻辑"><a href="#缓存逻辑" class="headerlink" title="缓存逻辑"></a>缓存逻辑</h3><p>缓存共分为四层</p><ol><li>Scrap  内存缓存</li><li>Cache 内存缓存: 不发生 bindView</li><li>ViewCacheExtension 用户自定义缓存</li><li>Recycled View Pool 缓存池</li></ol><p><img src="https://pic2.zhimg.com/80/v2-a8d1b3f8f1d3b96db61ef34b3934c7b9_720w.jpg" alt="img"></p><p>RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> fromScrap = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">fromScrap = holder != <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(hoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="keyword">if</span>(mAdapter.hasStableIds())&#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fallback to recycler</span></span><br><span class="line">            holder = getRecyclerViewPool().getRecyclerView(type);</span><br><span class="line">            <span class="keyword">if</span>(holder != <span class="keyword">null</span>)&#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span>(FORCE_INVALIDATE_DISPLAY_LIST)&#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(holder == <span class="keyword">null</span> )&#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 LayoutParams 的代码</span></span><br><span class="line">    <span class="keyword">return</span> holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 View 的逻辑可以整理为</p><ul><li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li><li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li><li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li><li>搜索 mRecyclerPool, 如果找到则返回 Holder</li><li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li></ul><p><strong>对于 View 的回收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(holder.isRecyclable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123;</span><br><span class="line">            <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                cachedViewSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">                mCachedViews.add(holder);</span><br><span class="line">                cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder);</span><br><span class="line">            recycled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p><h2 id="与-AdapterView-比较"><a href="#与-AdapterView-比较" class="headerlink" title="与 AdapterView 比较"></a>与 AdapterView 比较</h2><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">AdapterView</th><th style="text-align:center">RecyclerView</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Simple click listener</td><td style="text-align:center">OnItemTouchListener</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Simple Divider</td><td style="text-align:center">ItemDecoration</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ListView and GridView</td><td style="text-align:center">LinearLayoutManager<br>GridLayoutManager</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">RecyclerBin</td><td style="text-align:center">Recycler</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Header and Footer</td><td style="text-align:center">Partial refresh</td></tr></tbody></table><h5 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h5><p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p><h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p><p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p><h5 id="布局类型"><a href="#布局类型" class="headerlink" title="布局类型"></a>布局类型</h5><p>AdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager</p><p>ListView 只提供了一种 LinearLayoutManager 方式</p><h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ul><li>RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作</li><li>ListView 不支持单个 Item  的刷新，只能整个列表进行 <code>notifyDataSetChanged</code> ， RecyclerView 提供了 <code>itemChange</code>, <code>ItemInsert</code>, <code>ItemRemoved</code> 等方法，减少了 性能的开销</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;List-View-的局限性&quot;&gt;&lt;a href=&quot;#List-View-的局限性&quot; class=&quot;headerlink&quot; title=&quot;List View 的局限性&quot;&gt;&lt;/a&gt;List View 的局限性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;只有纵向列表一种布局&lt;/li&gt;
&lt;li&gt;没有支持动画的  API&lt;/li&gt;
&lt;li&gt;接口设计和系统不一致&lt;ol&gt;
&lt;li&gt;setOnItemClickListener()&lt;/li&gt;
&lt;li&gt;setOnItemLongClickListener()&lt;/li&gt;
&lt;li&gt;setSelection()&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;没有强制实现 ViewHolder&lt;/li&gt;
&lt;li&gt;性能不如 RecyclerView&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="View" scheme="http://xiaoman.ren/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>WebView 使用篇</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/WebView%20%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/WebView 使用篇/</id>
    <published>2021-03-12T06:59:30.433Z</published>
    <updated>2021-03-22T15:59:20.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h2><p><strong>Android 调用 JS</strong> </p><ul><li>通过 <code>WebView</code> 的 <code>loadUrl()</code></li><li>通过 <code>WebView</code> 的 <code>evaluateJavascript()</code></li></ul><p><strong>JS 调用 Android</strong></p><ul><li>通过 <code>WebView</code> 的 <code>addJavascriptInterface()</code> 进行对象映射</li><li>通过 <code>WebView</code> 的 <code>shouldOverrideUrlLoading()</code> 方法回调拦截 <code>Url</code></li><li>通过 <code>WebChromeClient</code> 的 <code>onAlert(),onJsConfirm(), onJsPrompt()</code> 方法回调拦截 JS 对话框 <code>alert(),confrim(),permpt()</code>  的消息</li></ul><a id="more"></a><h2 id="Android-调用-WebView"><a href="#Android-调用-WebView" class="headerlink" title="Android 调用 WebView"></a>Android 调用 WebView</h2><h3 id="方式一：-WebView-loadUrl"><a href="#方式一：-WebView-loadUrl" class="headerlink" title="方式一： WebView.loadUrl()"></a>方式一： WebView.loadUrl()</h3><ul><li>点击 Android 按钮，调用 WebView JS 中的 callJs()</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">chartset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function callJs()&#123;</span></span><br><span class="line"><span class="undefined">            alert("Android 调用 JS 的 callJs（）");</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    WebView webView;</span><br><span class="line">    Button button;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_activity);</span><br><span class="line">        webView = (WebView)findViewById(R.id.webview);</span><br><span class="line">        WebSettings setting = webView.getSettings();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 JS 交互权限</span></span><br><span class="line">        setting.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 允许 JS 弹窗</span></span><br><span class="line">        setting.setJavaScriptCanOpenWindowsAutomatically(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 载入 js 代码</span></span><br><span class="line">        webView.loadUrl(<span class="string">"file://android_asset/javascript.html"</span>);</span><br><span class="line">        button = (Button)findViewById(R.id.buttong);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                webView.post(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                   <span class="comment">// 调用 JS 方法名要对应上</span></span><br><span class="line">                    webView.loadUrl(<span class="string">"javascript::callJs()"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于设置了弹窗检查调用结果，所以需要支持 js 对话框</span></span><br><span class="line">        <span class="comment">// webview 只是载体，内容的渲染需要使用 webviewChromeClient 类去实现</span></span><br><span class="line">        <span class="comment">// 通过设置 WebChromeClient 对象处理 JavaScript 的对话框</span></span><br><span class="line">        <span class="comment">// 设置 JS 的 Alert 函数</span></span><br><span class="line">        webView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsAlert</span><span class="params">(WebView view, String url, String message, <span class="keyword">final</span> JsResult result)</span> </span>&#123;</span><br><span class="line">                AlertDialog.Builder dialog = AlertDialog.Builder(TestActivity.<span class="keyword">this</span>);</span><br><span class="line">                dialog.setTitle(<span class="string">"alert"</span>);</span><br><span class="line">                dialog.setMessage(message);</span><br><span class="line">                dialog.setPositiveButton(android.R.string.ok, <span class="keyword">new</span> DialogInterface.OnClickListener()&#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                        result.confirm();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                dialog.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">                dialog.create().show();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：-WebView-evaluateJavascript"><a href="#方式二：-WebView-evaluateJavascript" class="headerlink" title="方式二： WebView.evaluateJavascript()"></a>方式二： WebView.evaluateJavascript()</h3><p>优点：比第一种效率高，使用更简洁</p><blockquote><ol><li>该方法的执行不会使页面刷新， <code>loadUrl()</code> 则会执行刷新</li><li>Android 4.4 版本后才可以使用</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.evluateJavascript(<span class="string">"javascript:callJs()"</span>, <span class="keyword">new</span> ValueCallback&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处为 JS 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h3><table><thead><tr><th>调用方法</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>使用 loadUrl()</td><td>方便，简洁</td><td>效率低<br>获取返回值麻煩</td><td>不需要获取返回值，对性能要求不高时</td></tr><tr><td>使用 evluateJavascript()</td><td>效率高</td><td>向下兼容性差，仅 Android 4.4 以上可用</td><td>Android 4.4 以上</td></tr></tbody></table><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>两种混合使用，可保证 Android 4.4 上下都可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 版本变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line"><span class="keyword">if</span>(version &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    webView.loadUrl(<span class="string">"javascript:callJs()"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webView.evluateJavascript(<span class="string">"javascript:callJs()"</span>, <span class="keyword">new</span> ValueCallback&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// js 返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-调用-Android"><a href="#JS-调用-Android" class="headerlink" title="JS 调用 Android"></a>JS 调用 Android</h2><ol><li>通过 <code>WebView</code> 的  <code>addJavascriptInterface()</code> 进行映射</li><li>通过 <code>WebChromeClient</code> 的 <code>shouldOverrideUrlLoading()</code> 方法拦截 Url</li><li>通过 <code>WebChromeClient</code> 的 <code>onJsAlert(), onJsConfirm(), onJsPrompt()</code> 方法拦截 JS 对话框 <code>alert(), confirm(), pormpt()</code> 消息</li></ol><h3 id="方式一：addJavascriptInterface-进行映射"><a href="#方式一：addJavascriptInterface-进行映射" class="headerlink" title="方式一：addJavascriptInterface() 进行映射"></a>方式一：<code>addJavascriptInterface()</code> 进行映射</h3><p><strong>定义一个与 JS 对象映射关系的 Android 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsCallAndroidInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 JS 需要调用的方法</span></span><br><span class="line">    <span class="comment">// 被 JS 调用的方法必须加入 @JavascriptInterface 注解</span></span><br><span class="line">    <span class="comment">// 这部分代码执行在异步线程中</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载 JS 代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function callAndroid()&#123;</span></span><br><span class="line"><span class="undefined">                // 由于对象映射，所以需要调用 test 对象等于调用 Android 映射对象</span></span><br><span class="line"><span class="undefined">                test.hello("js 调用 Android 的 hello");</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"button1"</span> "<span class="attr">callAndroid</span>()"&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在  Android 里通过 WebView 设置 Android 类和 JS 代码的映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setting.setJavascriptEnable(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Android to js 类对象映射到 js 对象</span></span><br><span class="line">webView.addJavascriptIntercept(<span class="keyword">new</span> JsCallAndroidInterface(), <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>使用简单，仅将 Android 对象和 JS 对象映射即可</p><p>存在严重的漏洞问题，容易造成系统信息的泄漏</p></blockquote><h3 id="方式二：-shouldOverrideUrlLoading-方法拦截-Url"><a href="#方式二：-shouldOverrideUrlLoading-方法拦截-Url" class="headerlink" title="方式二： shouldOverrideUrlLoading() 方法拦截 Url"></a>方式二： <code>shouldOverrideUrlLoading()</code> 方法拦截 Url</h3><p>原理：</p><ul><li>Android 通过 WebViewClient 的回调方法 <code>shouldOverriderUrlLoading()</code> 拦截 URL</li><li>解析此 URL 的协议</li><li>如果检测到了预先约定好的协议，就回调相关方法</li></ul><blockquote><p>也就是 JS 调用 Android 的方法</p></blockquote><p><strong>一：在 JS 中约定所需要的 URL 协议</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function callAndroid()&#123;</span></span><br><span class="line"><span class="undefined">                document.location = "js://webview?arg1=111%arg2=112";</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span> = <span class="string">"button1"</span> <span class="attr">onclick</span>=<span class="string">"callAndroid()"</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 JS 通过 Android 的 <code>webView.loadUrl(&quot;file:///android_asset/javascript.html&quot;);</code> 加载后，就会回调 <code>shouldOverrideUrlLoading()</code> </p><p><strong>二：在 Android 通过 WebViewClient 重写 shouldOverrideUrlLoading()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    WebView mWebView;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_activity);</span><br><span class="line">        mWebView = findViewById(R.id.webview);</span><br><span class="line">        </span><br><span class="line">        WebSettings settings = mWebView.getSettings();</span><br><span class="line">        <span class="comment">// 设置于 JS 交互权限</span></span><br><span class="line">        settings.setJavascriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 允许 JS 弹框</span></span><br><span class="line">        settings.setJavascriptCanOpenWindowsAutomatically(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        mWebView.loadUrl(<span class="string">"file:///android_asset/javascript.html"</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span></span>&#123;</span><br><span class="line">                <span class="comment">// 根据协议参数，判断是否由需要的 url</span></span><br><span class="line">                <span class="comment">// 一般根据 scheme（协议格式） 和 authority（协议名）判断</span></span><br><span class="line">                <span class="comment">// 假设传入的时 url ="js://webview?arg1=111&amp;arg2=222"</span></span><br><span class="line">                </span><br><span class="line">                Uri uri = Uri.parse(url);</span><br><span class="line">                <span class="comment">// 如果 url 的协议为事先约定好的 JS 协议， 就解析参数</span></span><br><span class="line">                <span class="keyword">if</span>(uri.getScheme().equals(<span class="string">"js"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果 authority 为事先约定好的 webview，表示符合约定协议</span></span><br><span class="line">                    <span class="comment">// 拦截 url ，执行 Android 的放法</span></span><br><span class="line">                    <span class="keyword">if</span>( url.getAuthority().equals(<span class="string">"webview"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 执行 js 需要的调用逻辑</span></span><br><span class="line">                        Log.d(TAG,<span class="string">"js 调用了 Android 的方法"</span>);</span><br><span class="line">                        HashMap&lt;String, String&gt; param = <span class="keyword">new</span> HashMap();</span><br><span class="line">                        Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不存在方式 1 的漏洞</p><p>缺点：JS 获取 Android 方法的返回值复杂</p><p>​        如果 JS 想要 Android 方法的返回值，只能通过 webView.loadUrl() 去执行 js 方法，把返回值传递回去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// Android: TestActivity</span></span><br><span class="line">&gt; mWebView.loadUrl(<span class="string">"javascript:returnResult("</span> + result + <span class="string">")"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// js: Javascript.html</span></span><br><span class="line">&gt; <span class="function">function <span class="title">returnResult</span><span class="params">(result)</span> </span>&#123;</span><br><span class="line">&gt;     alert(result);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="方式三：-onJsAlert-onJsConfirm-onJsPrompt-方法拦截-JS-对话框-alert-confirm-pormpt-消息"><a href="#方式三：-onJsAlert-onJsConfirm-onJsPrompt-方法拦截-JS-对话框-alert-confirm-pormpt-消息" class="headerlink" title="方式三： onJsAlert(), onJsConfirm(), onJsPrompt() 方法拦截 JS 对话框 alert(), confirm(), pormpt() 消息"></a>方式三： <code>onJsAlert(), onJsConfirm(), onJsPrompt()</code> 方法拦截 JS 对话框 <code>alert(), confirm(), pormpt()</code> 消息</h3><p>JS 中，有三个常用的对话框方法</p><table><thead><tr><th>方法</th><th>作用</th><th>返回值</th><th>备注</th></tr></thead><tbody><tr><td>alert()</td><td>弹出警告框</td><td>没有</td><td>在文本中加入 \n 可换行</td></tr><tr><td>confirm()</td><td>弹出确认框</td><td>两个返回值</td><td>1. 返回布尔值<br>2. 通过该值判断点击的是确认还是取消： true 表示确认， false 表示取消</td></tr><tr><td>prompt()</td><td>弹出输入框</td><td>任意设置返回值</td><td>1. 点击 “确认”： 返回输入框中的值<br>2. 点击 “取消”： 返回 null</td></tr></tbody></table><p>通过 Android 的 <code>WebChromeClient</code> 中 <code>onJsAlert(), onJsConfirm(), onJsPrompt()</code> 方法拦截 JS 对话框 <code>alert(), confirm(), pormpt()</code> 消息，并解析</p><p>如拦截 <code>prompt()</code></p><blockquote><p>常用的拦截是： 拦截 JS 的输入框 prompt() 方法</p><p>因为只有 prompt() 方法可以返回任意类型值，操作最全面、方便、灵活。alert() 没有返回值; confirm() 只能返回两种</p></blockquote><p><strong>加载 js 代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson_Ho<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined">function clickprompt()&#123;</span></span><br><span class="line"><span class="undefined">    // 调用prompt（）</span></span><br><span class="line"><span class="undefined">    var result=prompt("js://demo?arg1=111&amp;arg2=222");</span></span><br><span class="line"><span class="undefined">    alert("demo " + result);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"button1"</span> "<span class="attr">clickprompt</span>()"&gt;</span>点击调用Android代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当使用 <code>mWebView.loadUrl(&quot;file:///android_asset/javascript.html&quot;)</code> 加载 JS 代码后，就会触发 <code>onJsPrompt()</code> </p><blockquote><p>如果拦截警告框 <code>alert()</code> ，则触发 <code>onJsAlert()</code></p><p>如果拦截确认框 <code>confirm()</code> 则触发 <code>onJsConfirm()</code></p></blockquote><p><strong>在 Android 中通过 WebChromeClient  重写 onJsPrompt()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据协议参数，判断是否是需要的 URL</span></span><br><span class="line">        <span class="comment">// 与 方法二相同</span></span><br><span class="line">        Uri uri = Uri.parse(url);</span><br><span class="line">        <span class="keyword">if</span>(uri.getScheme().equals(<span class="string">"js"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(uri.getAuthority().equalse(<span class="string">"webview"</span>)) &#123;</span><br><span class="line">       <span class="comment">// 执行 js 需要的逻辑</span></span><br><span class="line">                Log.d(TAG, message);</span><br><span class="line">                HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 参数 result: 代表消息框的返回值（输入值）</span></span><br><span class="line">                result.confirm(<span class="string">"js 调用了 Android 方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法对比-1"><a href="#方法对比-1" class="headerlink" title="方法对比"></a>方法对比</h3><table><thead><tr><th>调用方式</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>addJavascriptInterface() 映射关系</td><td>方便简洁</td><td>Android 4.2 一下存在漏洞</td><td>Android 4.2 以上相对简单的互调场景</td></tr><tr><td>重写 shouldOverrideUrlLoading()</td><td>不存在漏洞问题</td><td>使用复杂，需要进行协议约束；从 Native 层往 web 层传递数据比较麻煩</td><td>不需要返回值情况下的互调场景（ios 使用的比较多）</td></tr><tr><td>拦截 JS 对话框</td><td>不存在漏洞</td><td>需要近些协议约束</td><td>能满足大多数情况下的互调情况</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>类型</th><th>调用方式</th><th>优点</th><th>缺点</th><th>使用场景</th><th>建议</th></tr></thead><tbody><tr><td>Android 调用 JS</td><td>loadUrl()</td><td>简单</td><td>效率低，获取返回值麻煩</td><td>不需要获取返回值，对性能要求不高</td><td>混合使用</td></tr><tr><td></td><td>evaluateJavascript()</td><td>效率高</td><td>仅支持 Android 4.4 以上</td><td>Android 4.4 以上</td><td></td></tr><tr><td>JS 调用 Android</td><td>addJavascriptInterface()</td><td>简洁</td><td>Android 4.2 以下存在漏洞</td><td>Android 4.2 以上相对简单的调用场景</td><td></td></tr><tr><td></td><td>shouldOverrideUrlLoading()</td><td>不存在漏洞问题</td><td>使用复杂，需要进行协议约束；从 Native 层往 web 层传递数据比较麻煩</td><td>不需要返回值的情况下</td><td></td></tr><tr><td></td><td>拦截 JS 弹框</td><td>不存在漏洞问题</td><td>需要进行协议约束；从 Native 层往 web 层传递数据比较麻煩</td><td>能满足大多数情况下的调用场景</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交互方式&quot;&gt;&lt;a href=&quot;#交互方式&quot; class=&quot;headerlink&quot; title=&quot;交互方式&quot;&gt;&lt;/a&gt;交互方式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Android 调用 JS&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;WebView&lt;/code&gt; 的 &lt;code&gt;loadUrl()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;WebView&lt;/code&gt; 的 &lt;code&gt;evaluateJavascript()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;JS 调用 Android&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;WebView&lt;/code&gt; 的 &lt;code&gt;addJavascriptInterface()&lt;/code&gt; 进行对象映射&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;WebView&lt;/code&gt; 的 &lt;code&gt;shouldOverrideUrlLoading()&lt;/code&gt; 方法回调拦截 &lt;code&gt;Url&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;WebChromeClient&lt;/code&gt; 的 &lt;code&gt;onAlert(),onJsConfirm(), onJsPrompt()&lt;/code&gt; 方法回调拦截 JS 对话框 &lt;code&gt;alert(),confrim(),permpt()&lt;/code&gt;  的消息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="WebView" scheme="http://xiaoman.ren/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>RandomLayout 随机摆放布局</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/RandomLayout/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/RandomLayout/</id>
    <published>2021-03-12T06:59:30.433Z</published>
    <updated>2021-03-12T06:59:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>随机摆放布局，先上效果</p><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210208162638517.png" alt="image-20210208162638517"></p><p>在有效空间内，随机摆放子 View ，并保障子 View 不会重叠。类似的需求，在开发过程中也会经常遇到。从图中看，随机摆放，那就不能使用常规的 <code>LinearLayout</code> <code>RelateLayout</code> 或者是 <code>RecyclerView</code> 这些。因为他们都不满足随机性。<br><a id="more"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，我们需要一个容器，<code>ViewGroup</code> <code>LinearLayout</code> 都可以给我们选择</p><p>然后，重写布局函数，确认宽高、测量子 View 等</p><p>其次，我们要保证随机性，那么就需要一个 <code>Random</code> 函数，并存储各个子 View 的坐标，确认重复性</p><p>最后，布局子 View</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>创建一个 <code>RandomLayout</code> 继承 <code>LinearLayout</code></li><li>重写 <code>onMeasure</code> 计算父布局及子布局的宽高和模式，并存储</li><li>重写 <code>onLayout</code> ，计算子 View 位置以及判定是否重合<ol><li>创建一个 <code>ArrayList&lt;Point&gt;</code> 用来存储子 View 的左顶点坐标，摆放时，遍历集合，找到重合立即重新生成，没有则继续</li><li>重合判定条件； <code>abs(rPoint.x - oPoint.x) &lt;= childWidth &amp;&amp; abs(rPoint.y - oPoint.y) &lt;= childHeight</code>, 意思是说：两个点的横纵距离均小于当前 View 的 宽和高 </li></ol></li><li>布局子 View</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomLayout</span></span>(context: Context, attributes: AttributeSet) : LinearLayout(context, attributes) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mWidth: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mHeight: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childWidth: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childHeight: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> childPointList = ArrayList&lt;Point&gt;(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onMeasure 获得上下容器的宽和高及计算模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">        mWidth = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        mHeight = mWidth<span class="comment">/* * 3 / 2*/</span></span><br><span class="line">        <span class="comment">// 测量所有的 childView 宽和高</span></span><br><span class="line">        setMeasuredDimension(mWidth, mHeight)</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布局，循环子 view ，并为其布局</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, left: <span class="type">Int</span>, top: <span class="type">Int</span>, right: <span class="type">Int</span>, bottom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom)</span><br><span class="line">        <span class="comment">// 获取所有子 View 的总数</span></span><br><span class="line">        <span class="comment">// 循环设置每一个子View的位置</span></span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(index)</span><br><span class="line">            childWidth = child.measuredWidth</span><br><span class="line">            childHeight = child.measuredHeight</span><br><span class="line">            <span class="comment">// 获取 xy 坐标</span></span><br><span class="line">            layoutChild(child, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子 View 布局</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">layoutChild</span><span class="params">(child: <span class="type">View</span>, index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 先随机生成一个坐标点，然后判断是否有重叠，重叠则重新生成新的点</span></span><br><span class="line">        <span class="keyword">var</span> rPoint = randomPointFactory()</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;<span class="comment">// 第一个点不需要处理</span></span><br><span class="line">            <span class="keyword">while</span> (isOverLapping(rPoint)) &#123;</span><br><span class="line">                <span class="comment">// 判断有没有重叠的部分，如果有就返回 true， 重新创建并比较</span></span><br><span class="line">                rPoint = randomPointFactory()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (childPointList.size != childCount) &#123;</span><br><span class="line">            <span class="comment">// 把没有重合的店放到集合中去</span></span><br><span class="line">            childPointList.add(rPoint)</span><br><span class="line">        &#125;</span><br><span class="line">        child.layout(rPoint.x, rPoint.y, rPoint.x + childWidth, rPoint.y + childHeight)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">randomPointFactory</span><span class="params">()</span></span>: Point &#123;</span><br><span class="line">        <span class="comment">// 随机获取俩个数，作为每个子View的左上角坐标，最大为父布局的 XY 最小为 0</span></span><br><span class="line">        <span class="keyword">val</span> random = Random</span><br><span class="line">        <span class="keyword">val</span> x: <span class="built_in">Int</span> = random.nextInt(mWidth - childWidth) % ((mWidth - childWidth) - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> y: <span class="built_in">Int</span> = random.nextInt(mHeight - childHeight) % ((mHeight - childHeight) - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> Point(x, y)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 重叠判定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isOverLapping</span><span class="params">(rPoint: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        childPointList.indices.forEach &#123; index -&gt;</span><br><span class="line">            <span class="keyword">val</span> oPoint = childPointList[index]</span><br><span class="line">            <span class="keyword">if</span> (abs(rPoint.x - oPoint.x) &lt;= childWidth &amp;&amp; abs(rPoint.y - oPoint.y) &lt;= childHeight) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow()</span><br><span class="line">        childPointList.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addChildView</span><span class="params">(item: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        addView(item)</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机摆放布局，先上效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210208162638517.png&quot; alt=&quot;image-20210208162638517&quot;&gt;&lt;/p&gt;
&lt;p&gt;在有效空间内，随机摆放子 View ，并保障子 View 不会重叠。类似的需求，在开发过程中也会经常遇到。从图中看，随机摆放，那就不能使用常规的 &lt;code&gt;LinearLayout&lt;/code&gt; &lt;code&gt;RelateLayout&lt;/code&gt; 或者是 &lt;code&gt;RecyclerView&lt;/code&gt; 这些。因为他们都不满足随机性。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="View" scheme="http://xiaoman.ren/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义View</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%20View/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/Android 自定义 View/</id>
    <published>2021-03-12T06:59:30.432Z</published>
    <updated>2021-03-12T06:59:30.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Android开发进阶的必经之路"><a href="#Android开发进阶的必经之路" class="headerlink" title="Android开发进阶的必经之路"></a>Android开发进阶的必经之路</h3><h3 id="为什么要自定义View"><a href="#为什么要自定义View" class="headerlink" title="为什么要自定义View"></a>为什么要自定义View</h3><h3 id="自定义View的基本方法"><a href="#自定义View的基本方法" class="headerlink" title="自定义View的基本方法"></a>自定义View的基本方法</h3><p>自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();<br>View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。</p><ul><li>测量：onMeasure()决定View的大小；</li><li>布局：onLayout()决定View在ViewGroup中的位置；</li><li>绘制：onDraw()决定绘制这个View。</li></ul><a id="more"></a><h3 id="自定义控件分类"><a href="#自定义控件分类" class="headerlink" title="自定义控件分类"></a>自定义控件分类</h3><ul><li>自定义View: 只需要重写onMeasure()和onDraw()</li><li>自定义ViewGroup: 则只需要重写onMeasure()和onLayout()</li></ul><h2 id="自定义View基础"><a href="#自定义View基础" class="headerlink" title="自定义View基础"></a>自定义View基础</h2><h3 id="View的分类"><a href="#View的分类" class="headerlink" title="View的分类"></a>View的分类</h3><p>视图View主要分为两类</p><table><thead><tr><th>类别</th><th>解释</th><th>特点</th></tr></thead><tbody><tr><td>单一视图</td><td>即一个View，如TextView</td><td>不包含子View</td></tr><tr><td>视图组</td><td>即多个View组成的ViewGroup，如LinearLayout</td><td>包含子View</td></tr></tbody></table><h3 id="View类简介"><a href="#View类简介" class="headerlink" title="View类简介"></a>View类简介</h3><ul><li>View类是Android中各种组件的基类，如View是ViewGroup基类</li><li>View表现为显示在屏幕上的各种视图</li></ul><blockquote><p>Android中的UI组件都由View、ViewGroup组成。</p></blockquote><ul><li><p>View的构造函数：共有4个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果View是在Java代码里面new的，则调用第一个构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果View是在.xml里声明的，则调用第二个构造函数</span></span><br><span class="line"><span class="comment">// 自定义属性是从AttributeSet参数传进来的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用</span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line"><span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//API21之后才使用</span></span><br><span class="line">    <span class="comment">// 不会自动调用</span></span><br><span class="line">    <span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line">    <span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="AttributeSet与自定义属性"><a href="#AttributeSet与自定义属性" class="headerlink" title="AttributeSet与自定义属性"></a>AttributeSet与自定义属性</h3><p>　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：</p><ol><li>通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">2. 在xml中为相应的属性声明属性值</span><br><span class="line">3. 在运行时（一般为构造函数）获取属性值</span><br><span class="line">4. 将获取到的属性值应用到View</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### View视图结构</span><br><span class="line"></span><br><span class="line">1. PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个</span><br><span class="line">2. DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout</span><br><span class="line">3. ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等</span><br><span class="line"></span><br><span class="line">![activity](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png)</span><br><span class="line"></span><br><span class="line">对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：</span><br><span class="line"></span><br><span class="line">![view_arch](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png)</span><br><span class="line"></span><br><span class="line">一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。</span><br><span class="line"></span><br><span class="line">### Android坐标系</span><br><span class="line"></span><br><span class="line">Android的坐标系定义为：</span><br><span class="line"></span><br><span class="line">- 屏幕的左上角为坐标原点</span><br><span class="line">- 向右为x轴增大方向</span><br><span class="line">- 向下为y轴增大方向</span><br><span class="line">  ![zuobiaoxi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png)</span><br><span class="line"></span><br><span class="line">&gt; 区别于一般的数学坐标系</span><br><span class="line">&gt; ![zuobiaoxi_qubie](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png)</span><br><span class="line"></span><br><span class="line">###  View位置（坐标）描述</span><br><span class="line"></span><br><span class="line">View的位置由4个顶点决定的</span><br><span class="line">4个顶点的位置描述分别由4个值决定：</span><br><span class="line"></span><br><span class="line">&gt; 请记住：View的位置是相对于父控件而言的）</span><br><span class="line"></span><br><span class="line">- Top：子View上边界到父view上边界的距离</span><br><span class="line">- Left：子View左边界到父view左边界的距离</span><br><span class="line">- Bottom：子View下边距到父View上边界的距离</span><br><span class="line">- Right：子View右边界到父view左边界的距离</span><br><span class="line"></span><br><span class="line">### 位置获取方式</span><br><span class="line"></span><br><span class="line">View的位置是通过view.getxxx()函数进行获取：（以Top为例）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 获取Top位置</span><br><span class="line">public final int getTop() &#123;  </span><br><span class="line">    return mTop;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 其余如下：</span><br><span class="line">  getLeft();      //获取子View左上角距父View左侧的距离</span><br><span class="line">  getBottom();    //获取子View右下角距父View顶部的距离</span><br><span class="line">  getRight();     //获取子View右下角距父View左侧的距离</span><br></pre></td></tr></table></figure></li></ol><p>与MotionEvent中 get()和getRaw()的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get() ：触摸点相对于其所在组件坐标系的坐标</span></span><br><span class="line"> event.getX();       </span><br><span class="line"> event.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span></span><br><span class="line"> event.getRawX();    </span><br><span class="line"> event.getRawY();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxiweizhi.png" alt="zuobiaoxiweizhi"></p><h3 id="Android中颜色相关内容"><a href="#Android中颜色相关内容" class="headerlink" title="Android中颜色相关内容"></a>Android中颜色相关内容</h3><p>Android支持的颜色模式：<br><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color1.png" alt="color1"></p><p>以ARGB8888为例介绍颜色定义:<br><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color2.png" alt="color2"></p><h2 id="View树的绘制流程"><a href="#View树的绘制流程" class="headerlink" title="View树的绘制流程"></a>View树的绘制流程</h2><h3 id="View树的绘制流程是谁负责的？"><a href="#View树的绘制流程是谁负责的？" class="headerlink" title="View树的绘制流程是谁负责的？"></a>View树的绘制流程是谁负责的？</h3><p>view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      .....</span><br><span class="line">      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      .....</span><br><span class="line">      performLayout(lp, mWidth, mHeight);</span><br><span class="line">      .....</span><br><span class="line">      performDraw();</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="view的添加"><a href="#view的添加" class="headerlink" title="view的添加"></a>view的添加</h3><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_qiyuan.png" alt></p><h3 id="view的绘制流程"><a href="#view的绘制流程" class="headerlink" title="view的绘制流程"></a>view的绘制流程</h3><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_traversals.png" alt="view_traversals"></p><h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><ol><li><p>系统为什么要有measure过程？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Hello World!"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。</p></li><li><p>measure过程都干了点什么事？</p></li><li><p>对于自适应的尺寸机制，如何合理的测量一颗View树？</p></li><li><p>那么ViewGroup是如何向子View传递限制信息的？</p></li><li><p>ScrollView嵌套ListView问题？</p></li></ol><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_requestlayout.png" alt="view_requestlayout"></p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><ol><li>系统为什么要有layout过程？</li><li>layout过程都干了点什么事？</li></ol><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_performlayout.png" alt="view_performlayout"></p><h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><ol><li>系统为什么要有draw过程？</li><li>draw过程都干了点什么事？</li></ol><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_invalidate.png" alt="view_invalidate"></p><h2 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h2><p>ayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。</p><p>事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类</p><h3 id="MarginLayoutParams"><a href="#MarginLayoutParams" class="headerlink" title="MarginLayoutParams"></a>MarginLayoutParams</h3><p>MarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的</p><ul><li>属性优先级问题<br>MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级</li></ul><blockquote><p>margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin</p></blockquote><ul><li>属性覆盖问题<br>优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释</li></ul><blockquote><p>Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value</p></blockquote><h3 id="LayoutParams与View如何建立联系"><a href="#LayoutParams与View如何建立联系" class="headerlink" title="LayoutParams与View如何建立联系"></a>LayoutParams与View如何建立联系</h3><ul><li>在XML中定义View</li><li>在Java代码中直接生成View对应的实例对象</li></ul><h3 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法1：添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法2：在指定位置添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index View将在ViewGroup中被添加的位置（-1代表添加到末尾）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = generateDefaultLayoutParams();<span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法3：添加一个子View</span></span><br><span class="line"><span class="comment"> * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams params = generateDefaultLayoutParams();  <span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">    params.width = width;</span><br><span class="line">    params.height = height;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addViewInner() will call child.requestLayout() when setting the new LayoutParams</span></span><br><span class="line">    <span class="comment">// therefore, we call requestLayout() on ourselves before, so that the child's request</span></span><br><span class="line">    <span class="comment">// will be blocked at our level</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTransition.addChild(<span class="keyword">this</span>, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkLayoutParams(params)) &#123; <span class="comment">// ① 检查传入的LayoutParams是否合法</span></span><br><span class="line">        params = generateLayoutParams(params); <span class="comment">// 如果传入的LayoutParams不合法，将进行转化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123; <span class="comment">// ② 是否需要阻止重新执行布局流程</span></span><br><span class="line">        child.mLayoutParams = params; <span class="comment">// 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.setLayoutParams(params); <span class="comment">// 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = mChildrenCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addInArray(child, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell our children</span></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.assignParent(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.mParent = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义LayoutParams"><a href="#自定义LayoutParams" class="headerlink" title="自定义LayoutParams"></a>自定义LayoutParams</h3><ol><li>创建自定义属性</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=<span class="string">"xxxViewGroup_Layout"</span>&gt;</span><br><span class="line">        &lt;!-- 自定义的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">"layout_simple_attr"</span> format=<span class="string">"integer"</span>/&gt;</span><br><span class="line">        &lt;!-- 使用系统预置的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">"android:layout_gravity"</span>/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>继承MarginLayout</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> simpleAttr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gravity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c, attrs);</span><br><span class="line">        <span class="comment">// 解析布局属性</span></span><br><span class="line">        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);</span><br><span class="line">        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, <span class="number">0</span>);</span><br><span class="line">        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        typedArray.recycle();<span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重写ViewGroup中几个与LayoutParams相关的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查LayoutParams是否合法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> SimpleViewGroup.LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成默认的LayoutParams</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LayoutParams常见的子类"><a href="#LayoutParams常见的子类" class="headerlink" title="LayoutParams常见的子类"></a>LayoutParams常见的子类</h3><p>在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：</p><ul><li>ViewGroup.MarginLayoutParams</li><li>FrameLayout.LayoutParams</li><li>LinearLayout.LayoutParams</li><li>RelativeLayout.LayoutParams</li><li>RecyclerView.LayoutParams</li><li>GridLayoutManager.LayoutParams</li><li>StaggeredGridLayoutManager.LayoutParams</li><li>ViewPager.LayoutParams</li><li>WindowManager.LayoutParams</li></ul><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：</p><ul><li><p>UNSPECIFIED<br>不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到）</p></li><li><p>EXACTLY<br>精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。</p></li><li><p>AT_MOST<br>当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。<br>MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取尚未显示的view的宽和高</span></span><br><span class="line"><span class="keyword">int</span> tempWidth =View.MeasureSpec.makeMeasureSpec(<span class="number">0</span>,View.MeasureSpec.UNSPECIFIED);</span><br><span class="line"><span class="keyword">int</span> tempHeight =View.MeasureSpec.makeMeasureSpec(<span class="number">0</span>,View.MeasureSpec.UNSPECIFIED);</span><br><span class="line">view.measure(tempWidth,tempHeight);</span><br><span class="line"><span class="keyword">int</span> realHeight=view.getMeasuredHeight(); </span><br><span class="line"><span class="keyword">int</span> realWidth=view.getMeasuredWidth();</span><br></pre></td></tr></table></figure></li></ul><h3 id="MeasureSpecs-的意义"><a href="#MeasureSpecs-的意义" class="headerlink" title="MeasureSpecs 的意义"></a>MeasureSpecs 的意义</h3><p>通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法</p><h3 id="MeasureSpec值的确定"><a href="#MeasureSpec值的确定" class="headerlink" title="MeasureSpec值的确定"></a>MeasureSpec值的确定</h3><p>MeasureSpec值到底是如何计算得来的呢?</p><p>对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">     <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">         <span class="keyword">final</span> View child = children[i];</span><br><span class="line">         <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">             <span class="comment">//测量指定的View</span></span><br><span class="line">             measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>测量指定的View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"><span class="comment">//根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">              mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">              mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">      child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个</span></span><br><span class="line"><span class="comment">   * 最可能符合条件的child view的测量规格。  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> spec 父控件的测量规格</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> padding 父控件里已经占用的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> childDimension child view布局LayoutParams里的尺寸</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> child view 的测量规格</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec); <span class="comment">//父控件的测量模式</span></span><br><span class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec); <span class="comment">//父控件的测量大小</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">          <span class="comment">//如果child的布局参数有固定值，比如"layout_width" = "100dp"</span></span><br><span class="line">          <span class="comment">//那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果child的布局参数是"match_parent"，也就是想要占满父控件</span></span><br><span class="line">          <span class="comment">//而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果child的布局参数是"wrap_content"，也就是想要根据自己的逻辑决定自己大小，</span></span><br><span class="line">          <span class="comment">//比如TextView根据设置的字符串大小来决定自己的大小</span></span><br><span class="line">          <span class="comment">//那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛</span></span><br><span class="line">          <span class="comment">//所以测量模式就是AT_MOST，测量大小就是父控件的size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">          <span class="comment">//同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">//child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小</span></span><br><span class="line">          <span class="comment">//但同样的，child的尺寸上限也是父控件的尺寸上限size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//child想要根据自己逻辑决定大小，那就自己决定呗</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">              <span class="comment">// be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">              <span class="comment">// big it should be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/measurespec3.png" alt="measurespec3"><br>针对上表，这里再做一下具体的说明</p><ul><li><p>对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定</p></li><li><p>对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。</p><pre><code>1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。</code></pre></li></ul><h3 id="View-（ViewGroup）的measure方法"><a href="#View-（ViewGroup）的measure方法" class="headerlink" title="View （ViewGroup）的measure方法"></a>View （ViewGroup）的measure方法</h3><p>  最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    ...</span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">//设置size</span><br><span class="line">    setMeasuredDimension(1,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onMeasure()</span><br><span class="line"><span class="comment">//1. 测量自身</span></span><br><span class="line"><span class="comment">//2. 为每个子View计算测量的限制信息 Mode / Size</span></span><br><span class="line"><span class="comment">//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure</span></span><br><span class="line"><span class="comment">//4. 获取子View测量完成后的尺寸</span></span><br><span class="line"><span class="comment">//5. ViewGroup根据自身的情况，计算自己的尺寸</span></span><br><span class="line"><span class="comment">//6. 保存自身的尺寸</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onLayout()</span><br><span class="line"><span class="comment">//1. 遍历子View for</span></span><br><span class="line"><span class="comment">//2. 确定自己的规则</span></span><br><span class="line"><span class="comment">//3. 获取子View的测量尺寸</span></span><br><span class="line"><span class="comment">//4. 确定子View的left,top,right,bottom</span></span><br><span class="line"><span class="comment">//6. 调用child.layout</span></span><br></pre></td></tr></table></figure><hr><ol><li><p><strong>简介</strong>：点、线、矩形、多边形、 弧、圆等。</p></li><li><p><strong>Paint</strong></p><p>2.1 常用属性</p><p>​    mPaint.setARGB();//设置画笔的A、R、G、B值 </p><p>​    mPaint.setStyle();//设置画笔的风格(空心或实心)</p><p>​    mPaint.setColor();//设置画笔的颜色</p><p>​    mPaint.setAlpha();//设置画笔的Alpha </p><p>​    mPaint.setAntiAlias();// 设置画笔的锯齿效果</p><p>​    mPaint.setTextSize();</p><p>​    mPaint.setStrokeWidth();//设置空心边框的宽度</p><p>   2.2 常用style </p><p>​        Paint.Style.FILL   //填充</p><p>​        Paint.Style.STROKE//空心</p><p>   2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 </p></li><li><p><strong>常用的画图方法</strong></p><p>3.1 drawPoint(x,y,paint)//点</p><p>3.2 drawLine(startX,startY,endX,endY,paint)//线</p><p>3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线</p><p>3.4 drawRect(l,t,r,b,paint)//矩形</p><p>3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度</p><p>3.6 drawtCircle(circleX,circleY,radius，paint)//圆</p><p>3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线</p><p>3.8 drawOval(l,t,r,b,paint)//椭圆</p><p>3.9 drawText(text,startX，startY,paint)//文本</p><p>3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时</p><p>3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量</p><p>3.12 drawPath(path,paint)//画路径</p></li></ol><p>   4.<strong>Path的用法</strong>//<span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzRkOWMzZmVjMDEwMnZ5aHMuaHRtbA==" title="http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html">http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html<i class="fa fa-external-link"></i></span></p><ol start="5"><li><p><strong>Canvas常用方法</strong></p><p>5.1 save()//将已经绘制好的图像保存起来</p><p>5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用</p><p>5.3 restoreToCount//</p><p>5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y）</p><p>5.5 rotate()//将坐标系旋转一定的角度</p><p>5.6 drawColor()//设置画布的颜色  </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;Android开发进阶的必经之路&quot;&gt;&lt;a href=&quot;#Android开发进阶的必经之路&quot; class=&quot;headerlink&quot; title=&quot;Android开发进阶的必经之路&quot;&gt;&lt;/a&gt;Android开发进阶的必经之路&lt;/h3&gt;&lt;h3 id=&quot;为什么要自定义View&quot;&gt;&lt;a href=&quot;#为什么要自定义View&quot; class=&quot;headerlink&quot; title=&quot;为什么要自定义View&quot;&gt;&lt;/a&gt;为什么要自定义View&lt;/h3&gt;&lt;h3 id=&quot;自定义View的基本方法&quot;&gt;&lt;a href=&quot;#自定义View的基本方法&quot; class=&quot;headerlink&quot; title=&quot;自定义View的基本方法&quot;&gt;&lt;/a&gt;自定义View的基本方法&lt;/h3&gt;&lt;p&gt;自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();&lt;br&gt;View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测量：onMeasure()决定View的大小；&lt;/li&gt;
&lt;li&gt;布局：onLayout()决定View在ViewGroup中的位置；&lt;/li&gt;
&lt;li&gt;绘制：onDraw()决定绘制这个View。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="View" scheme="http://xiaoman.ren/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>WebView 性能篇</title>
    <link href="http://xiaoman.ren/2021/03/12/Android%20%E5%9F%BA%E7%A1%80/View/Android%20WebView/"/>
    <id>http://xiaoman.ren/2021/03/12/Android 基础/View/Android WebView/</id>
    <published>2021-03-12T06:59:30.432Z</published>
    <updated>2021-03-12T06:59:30.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a><strong>问题</strong>：</h2><h3 id="为什么-WebView-的加载速度那么慢"><a href="#为什么-WebView-的加载速度那么慢" class="headerlink" title="为什么 WebView 的加载速度那么慢?"></a><strong>为什么</strong> <strong>WebView 的加载速度那么慢?</strong></h3><ol><li><p>js 解析效率</p><p>如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢</p></li><li><p>页面资源的下载</p><p>一般加载一个 H5 页面，都会产生比较多的 <strong>串行</strong> 网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢</p></li><li><p>耗费流量</p><p>每次 H5 页面加载时，都需要重新加载 Android WebView 的 H5 页面，每加载一个页面，就会产生很多请求，导致同一个页面被加载多次</p></li></ol><a id="more"></a><h3 id="那如何解决呢？"><a href="#那如何解决呢？" class="headerlink" title="那如何解决呢？"></a><strong>那如何解决呢？</strong></h3><ul><li>前端H5 缓存机制（WebView 自带）</li><li>资源预加载</li><li>资源拦截</li></ul><h4 id="前端-H5-缓存机制"><a href="#前端-H5-缓存机制" class="headerlink" title="前端 H5 缓存机制"></a>前端 H5 缓存机制</h4><p><strong>定义：</strong> 缓存、离线存储</p><ul><li>意味着 H5 网页加载后会存储在缓存区域，在无网络情况下也可以访问</li><li>WebView 的本质时在 Android 中嵌入 H5 页面，所以 Android  WebView 自带的缓存机制就是 H5 页面的缓存机制</li><li>Android WebView 除了新的 file_system 缓存机制还不支持，其他的都支持</li></ul><p><strong>作用：</strong></p><ul><li>离线浏览：用户可以在没有网络时，访问 H5 页面</li><li>提高页面加载速度 &amp; 减少流量消耗：直接使用已缓存的资源，不需要重新请求和加载</li></ul><p><strong>应用：</strong></p><ul><li>缓存机制：如何将加载过的网页数据保存到本地（保存）</li><li>缓存模式：加载网页时如何读取之前保存到本地的网页缓存（读取）</li></ul><h5 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h5><p>Android WebView 自带的缓存机制有 5 种：</p><ol><li>浏览器缓存机制</li><li>Application Cache 缓存机制</li><li>Dom Storage 缓存机制</li><li>Web Sql Database 缓存机制</li><li>Indexed Database 缓存机制</li><li>File System 缓存机制（H5 页面新加入的缓存机制）</li></ol><h5 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h5><p><strong>原理：</strong>根据 HTTP 协议头里的 <code>cache-control</code> 或 <code>Expires</code> 和 <code>Last-Modified</code> 和 <code>Etag</code> 等字段来控制文件缓存的机制</p><ol><li><p><code>Cache-Control</code> 用于控制文件在本地缓存有效时长<br>如服务器返回 <code>Cache-Control:max-age=600</code>，则表示文件在本地应该缓存，且有效时长是  600s。在接下来的 600s 内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件</p></li><li><p><code>Expires</code>: 与 <code>Cache-Control</code> 功能相同，即控制缓存的有效时间</p><ol><li>Expires 是 Http 1.0 标准中的字段， Cache-Control 是 Http 1.1 中新增字段</li><li>当这两个同时出现时， Cache-Control 优先级高</li></ol></li><li><p><code>Last-Modified</code> 标识文件在服务器上的最新更新时间<br>下次请求时，如果文件缓存过期，浏览器通过 <code>If-Modified-Since</code> 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回 304 告诉前端继续使用缓存；如果有修改，则返回 200， 同时返回新文件。</p></li><li><p>Etag 功能和 <code>Last-Modified</code> 一样，标识文件再服务器上的最新更新时间</p><p>不同的是， Etag 的取值是一个对文件进行标识的特征字串</p><p>再向服务器查询文件是否有更新时，浏览器通过 <code>If-None-Match</code>  字段把特征字串发送给服务器，由服务器和文件的最新特征字串进行匹配，来判断文件是否有更新。</p><p>Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中要给就可以。</p></li></ol><p><strong>常用方法：</strong></p><ul><li>Cache-Control 与 Last-Modified 一起使用</li><li>Expires 和 Etag 一起使用</li></ul><p>即 一个控制缓存有效时间，一个用户在缓存失效后，向服务器查询是否有更新</p><p><strong><em>浏览器缓存机制是浏览器内核的机制，一般都是标准的实现</em></strong>, 缓存的内容，受存储空间约束，同时也有被清除的风险</p><h5 id="Application-Cache-缓存机制"><a href="#Application-Cache-缓存机制" class="headerlink" title="Application Cache 缓存机制"></a>Application Cache 缓存机制</h5><p><strong>原理：</strong></p><ul><li><p>以文件为单位进行缓存，且文件有一定更新机制（类似于浏览器缓存机制）</p></li><li><p>AppCache 有啷个关键点 manifest 属性和 manifest 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo_html.appcache"</span>&gt;</span></span><br><span class="line">// HTML 在头中通过 manifest 属性引用 manifest 文件</span><br><span class="line">// manifest 文件：就是上面以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件</span><br><span class="line">// 浏览器在首次加载 HTML 文件时，会解析 manifest 属性，并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 原理说明如下：</span><br><span class="line">// AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件</span><br><span class="line">// 因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)</span><br><span class="line">发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新</span><br><span class="line">// manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制</span><br><span class="line">// 如用户手动清了 AppCache 缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新</span><br><span class="line">// AppCache 的缓存文件，与浏览器的缓存文件分开存储的，因为 AppCache 在本地有 5MB（分 HOST）的空间限制</span><br></pre></td></tr></table></figure></li></ul><p><strong>特点：</strong></p><p>方便构建 WebApp 的缓存， 准们为 WebApp 离线使用而开发的缓存机制</p><p><strong>应用场景：</strong></p><p>存储静态文件（js， css，字体文件等）</p><p>是对浏览器缓存机制的补充，不是替代</p><p><strong>实现方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置WebView的settings来实现</span></span><br><span class="line">WebSettings settings = getSettings();</span><br><span class="line"></span><br><span class="line">String cacheDirPath = context.getFilesDir().getAbsolutePath()+<span class="string">"cache/"</span>;</span><br><span class="line">settings.setAppCachePath(cacheDirPath);</span><br><span class="line"><span class="comment">// 1. 设置缓存路径</span></span><br><span class="line"></span><br><span class="line">settings.setAppCacheMaxSize(<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 2. 设置缓存大小</span></span><br><span class="line"></span><br><span class="line">settings.setAppCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 3. 开启Application Cache存储机制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意</span></span><br><span class="line"><span class="comment">// 每个 Application 只调用一次 WebSettings.setAppCachePath() 和</span></span><br><span class="line">WebSettings.setAppCacheMaxSize()</span><br></pre></td></tr></table></figure><h5 id="Dom-Storage-缓存机制"><a href="#Dom-Storage-缓存机制" class="headerlink" title="Dom Storage 缓存机制"></a>Dom Storage 缓存机制</h5><p><strong>原理：</strong></p><p>通过存储 key - value 来提供</p><blockquote><p>Dom Storage 分为 sessiongStorage 和 localStorae, 两者基本相同，区别于作用范围</p><p>sessionStorage：具备临时性，即存储与页面相关的数据，在离开页面后无法使用</p><p>localStorage：具备持久性，即保存的数据在页面关闭后还可以使用</p></blockquote><p><strong>特点：</strong></p><p>存储空间大（5mb）存储空间对于不同浏览器不同</p><p>存储安全、边界：Dom Storage 存储的数据在本地，不需要经常和服务器交互</p><p><strong>应用场景：</strong></p><p>存储临时，简单的数据，类似于 Android 的 SharedPreference 机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSettings().setDomStorageEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="Web-SQL-Database-缓存机制"><a href="#Web-SQL-Database-缓存机制" class="headerlink" title="Web SQL Database 缓存机制"></a>Web SQL Database 缓存机制</h5><p><strong>原理：</strong></p><p>基于 SQL 的数据库存储机制</p><p><strong>特点：</strong></p><p>充分利用数据库的有时，可方便对数据进行 CUDA</p><p><strong>场景</strong></p><p>适合数据库的结构化数据</p><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置WebView的settings实现</span></span><br><span class="line">WebSettings settings = getSettings();</span><br><span class="line"></span><br><span class="line">String cacheDirPath = context.getFilesDir().getAbsolutePath()+<span class="string">"cache/"</span>;</span><br><span class="line">settings.setDatabasePath(cacheDirPath);</span><br><span class="line"><span class="comment">// 设置缓存路径</span></span><br><span class="line"></span><br><span class="line">settings.setDatabaseEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 开启 数据库存储机制</span></span><br></pre></td></tr></table></figure><h5 id="IndexDB-缓存机制"><a href="#IndexDB-缓存机制" class="headerlink" title="IndexDB 缓存机制"></a>IndexDB 缓存机制</h5><p>属于 NoSQL 数据库，通过存储字符串的 Key - Value 来提供。</p><p><strong>特点</strong></p><p>可存储复杂，数据量大的结构化数据</p><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置WebView的settings实现</span></span><br><span class="line">WebSettings settings = getSettings();</span><br><span class="line"></span><br><span class="line">settings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 只需设置支持JS就自动打开IndexedDB存储机制</span></span><br><span class="line"><span class="comment">// Android 在4.4开始加入对 IndexedDB 的支持，只需打开允许 JS 执行的开关就好了。</span></span><br></pre></td></tr></table></figure><h5 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h5><p><strong>原理：</strong></p><p>为 H5 页面的数据，提供一个虚拟的文件系统</p><ul><li>可进行文件的 CUDA，就像 Native App 访问本地文件系统一样</li><li>虚拟的文件系统运行在沙盒中</li><li>不同 WebApp 的虚拟文件系统的互相隔离的，虚拟文件系统与本地文件系统也是互相隔离的。</li></ul><p>虚拟文件系统提供了两种类型的存储空间：临时和持久</p><ul><li>临时的存储空间：由浏览器自动分配，但可能被浏览器回收</li><li>持久性存储空间：需要显示申请；自己管理（浏览器不会回收，也不会清除内容）；内存空间大小通过配额管理，首次申请时会一个初始的配额，配额用完需要再次申请。</li></ul><p><strong>特点：</strong></p><ul><li>可存储数据体积较大的二进制数据</li><li>可预加载资源文件</li><li>可直接编辑文件</li></ul><p><strong>场景：</strong></p><p>通过文件系统管理数据</p><p><strong>使用</strong></p><p>由于 file system 时 H5 新加入的缓存机制， Android WebView 暂时不支持</p><h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><table><thead><tr><th>存储静态资源文件（js等）</th><th>浏览器缓存机制<br>Application Cache 存储机制</th></tr></thead><tbody><tr><td>存储，临时、简单的数据</td><td>Dom Stroage 缓存机制</td></tr><tr><td>存储复杂、数据量大的结构化数据</td><td>indexedDB缓存机制</td></tr><tr><td>在 Android WebView 中进行设置</td></tr></tbody></table><h5 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h5><p><strong>WebView 的 5 种缓存模式</strong></p><ul><li>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</li><li>LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据</li><li>LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式</li><li>LOAD_NO_CACHE： 不使用缓存，只从网络获取</li><li>LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = mWebView.getSettings();</span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br></pre></td></tr></table></figure><h4 id="资源预加载"><a href="#资源预加载" class="headerlink" title="资源预加载"></a>资源预加载</h4><p><strong>定义：</strong></p><p>提早加载将需要使用的 H5 页面，即 <em>提前构建缓存</em></p><p>使用时直接取过来用，而不是用时才加载</p><h5 id="预加载-WebView-对象"><a href="#预加载-WebView-对象" class="headerlink" title="预加载 WebView 对象"></a>预加载 WebView 对象</h5><ul><li>此处主要分为 2 方面，首次使用 WebView 对象 和 后续使用 WebView 对象</li></ul><table><thead><tr><th>类型</th><th>原因</th><th>思路</th><th>实现</th></tr></thead><tbody><tr><td>首次使用 WebView 对象</td><td>首次初始化 WebView 会比第二次初始化慢很多<br>初始化后，即使 WebView 已释放，但一些多个 WebView 公用的全局服务 / 资源对象仍未释放<br>第二次初始化时则不需要在生成，从而快。</td><td>1. 用用启动时初始化一个全局的 WebView 对象<br>2. 当用户需要加载 H5 页面时，则直接使用该 WebView 对象加载并显示</td><td>在 Android  的 BaseApplication 里初始化要给 web View 对象</td></tr><tr><td>后续使用 WebView 对象</td><td>多次创建 WebView 对象会耗费很多时间和资源</td><td>1. 自身构建 WebView 服用池<br>2. 当用户需要使用 WebView 加载 H5 时，直接使用该 WebView 对象池加载和展示</td><td>采用  2个/多个 webView 重复使用，而不需要每次打开 H5 都新建</td></tr></tbody></table><p>对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑；</p><p>所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度</p><ol><li><p>首先将一些资源文件放在本地的 <code>assets</code> 目录，然后重写 WebViewClient 的 <code>shouldInterceptRequest(WebView view, String url)</code> 和  <code>shouleInterceptRequest(WebView view, WebResourceRequest request)</code> 这两个方法，对访问地址进行拦截，当 <code>url</code> 地址命中本地配置的 <code>url</code> 时，使用本地资源替代，否则就使用网络上的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">    <span class="comment">// 设置不使用系统浏览器打开，直接显示在当前 WebView</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">        view.loadUrl(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldIntercepteReqeuest</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果命中本地资源，使用本地资源替代</span></span><br><span class="line">        <span class="keyword">if</span>(mDataHelper.hasLocalResource(url))&#123;</span><br><span class="line">            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);</span><br><span class="line">            <span class="keyword">if</span>(response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldInterceptRequest(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容 5.0 以上的设备</span></span><br><span class="line">    <span class="meta">@TargetApi</span>(VERSION_CODE.LOLLIPOP)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, WebResourceRequest request)</span> </span>&#123;</span><br><span class="line">        String url = request.getUrl().toString();</span><br><span class="line">        <span class="keyword">if</span>(mDataHelper.hasLocalResource(url)) &#123;</span><br><span class="line">            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);</span><br><span class="line">            <span class="keyword">if</span>(response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouleInterceptRequest(view, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>DataHelper 是一个工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; mMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String imageDir = <span class="string">"images/"</span>;</span><br><span class="line">        String pngSuffix = <span class="string">".png"</span>;</span><br><span class="line">        mMap.put(<span class="string">"http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8"</span>, <span class="string">"css/style.css"</span>);</span><br><span class="line">        mMap.put(<span class="string">"http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png"</span>,imageDir + <span class="string">"cropped-ryg.png"</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLocalResource</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.containsKey(url);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResourceResponce <span class="title">getReplacedWebResourceResponse</span><span class="params">(Context context, String url)</span> </span>&#123;</span><br><span class="line">        String localResourcePath = mMap.get(url);</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(localResourcePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = context.getApplicationContext().getAssets().open(localResourcePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String mimeType;</span><br><span class="line">        <span class="keyword">if</span>(url.contans(<span class="string">"css"</span>)) &#123;</span><br><span class="line">            mimeType = <span class="string">"text/css"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.contains(<span class="string">".jpg"</span>)) &#123;</span><br><span class="line">            mimeType = <span class="string">"image/jpeg"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mimeType = <span class="string">"image/png"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        WebResourceResponse response = <span class="keyword">new</span> WebResourceResponse(mimeType, <span class="string">"utf-8"</span>, is);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="WebView-的缓存"><a href="#WebView-的缓存" class="headerlink" title="WebView 的缓存"></a><strong>WebView 的缓存</strong></h3><p>在不配置本地资源的时候，我们第一次打开页面，产生了 n  多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。<img src="https://github.com/xiaomanwong/static_file/blob/master/images/image-20201027164335807.png?raw=true" alt="image-20201027164335807"></p><p>我们观察到，这个请求的 response 的 headers 中的参数，<code>Last-Modified,ETag, Expires, Cache-Control</code> </p><p><strong>Cache-Control：</strong> 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 <code>Http/1.1</code>  标准中的字段。</p><p><strong>Expires：</strong> 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 <code>HTTP/1.0</code> 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。</p><p><strong>Last-Modified:</strong> 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 <code>If-Modified-Since</code> 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。</p><p><strong>ETag：</strong> ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 <code>If-None-Match</code> 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。</p><blockquote><p>常见用法是， <code>Cache-Control</code> 与 <code>Last-Modified</code> 一起使用， <code>Expires</code> 和 <code>ETag</code> 一起使用。但实际情况可能并不是这样</p></blockquote><p><strong>设置 WebView 使用这些内容</strong></p><p>想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = mWebView.getSettings();</span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br></pre></td></tr></table></figure><p><strong>WebView 的 5 种缓存模式</strong></p><ul><li>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</li><li>LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据</li><li>LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式</li><li>LOAD_NO_CACHE： 不使用缓存，只从网络获取</li><li>LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取</li></ul><p>在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。</p><h2 id="WebView-的速度方案"><a href="#WebView-的速度方案" class="headerlink" title="WebView 的速度方案"></a>WebView 的速度方案</h2><h3 id="WebView-的初始化"><a href="#WebView-的初始化" class="headerlink" title="WebView 的初始化"></a>WebView 的初始化</h3><p>本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。</p><h3 id="预加载数据"><a href="#预加载数据" class="headerlink" title="预加载数据"></a>预加载数据</h3><p>就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘</p><p>简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 <code>shouleInterceptRequest</code> 方法。</p><h3 id="离线包"><a href="#离线包" class="headerlink" title="离线包"></a>离线包</h3><p>离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。</p><p><strong>资源：</strong></p><ul><li>H5： 每个代码包都有一个唯一且递增的版本号</li><li>Native：提供包下载且解压资源文件到对应目录</li><li>服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址</li></ul><p><strong>流程：</strong></p><ul><li>前端更新代码打包后按版本号上传至指定的服务器上</li><li>每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包</li><li>客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/h2&gt;&lt;h3 id=&quot;为什么-WebView-的加载速度那么慢&quot;&gt;&lt;a href=&quot;#为什么-WebView-的加载速度那么慢&quot; class=&quot;headerlink&quot; title=&quot;为什么 WebView 的加载速度那么慢?&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么&lt;/strong&gt; &lt;strong&gt;WebView 的加载速度那么慢?&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;js 解析效率&lt;/p&gt;
&lt;p&gt;如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面资源的下载&lt;/p&gt;
&lt;p&gt;一般加载一个 H5 页面，都会产生比较多的 &lt;strong&gt;串行&lt;/strong&gt; 网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;耗费流量&lt;/p&gt;
&lt;p&gt;每次 H5 页面加载时，都需要重新加载 Android WebView 的 H5 页面，每加载一个页面，就会产生很多请求，导致同一个页面被加载多次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://xiaoman.ren/categories/Android/"/>
    
    
      <category term="WebView" scheme="http://xiaoman.ren/tags/WebView/"/>
    
  </entry>
  
</feed>
