<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/17/hello-world/"/>
      <url>/2019/04/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/17/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
      <url>/2019/04/17/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h1><p><strong>事件分发的三个方法</strong></p><ol><li><p>dispatchTouchEvent(MotionEvent event) </p><p> 判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件；</p></li><li><p>onInterceptTouchEvent(MotionEvent event) </p><p> 通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件；</p></li><li><p>onTouchEvent(MotionEvent event) </p><p> 当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。</p></li></ol><a id="more"></a><p><strong>关于事件分发的一些结论：</strong></p><ol><li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束；</li><li>正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理；</li><li>某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。</li><li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。</li><li>如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。</li><li>ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</li><li>View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。</li><li>View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。</li><li>View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。</li><li>onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。</li><li>事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（<em>解决滑动冲突，内部拦截法</em>）。</li><li>事件的传递过程：Activity -&gt; Window(PhoneWindow) -&gt; View -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent。</li><li>当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 判断字符串是否是数字的方法</title>
      <link href="/2019/04/16/Java-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/16/Java-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>使用 Java自带的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric (String str) &#123;</span><br><span class="line">    for (int i = str.length(); --i &gt;=0) &#123;</span><br><span class="line">          if (!Character.isDigit(str.charAt(i))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用正则表达式</li></ul><p>方法一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric(String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;);</span><br><span class="line">    return pattern.matcher(str).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric(String str) &#123;</span><br><span class="line">    if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123;</span><br><span class="line">          return s.matches(&quot;^[0-9]*$&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static boolean isNumeric (String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;);</span><br><span class="line">    return pattern.matcher(str).matcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ASCII 码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNumeric (String str) &#123;</span><br><span class="line">    for (int i = str.length(); --i&gt;=0;) &#123;</span><br><span class="line">        int chr = str.charAt(i);</span><br><span class="line">        if (chr &lt; 48 || chr &gt; 57) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是不是浮点型数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isDouble(String str) &#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;);</span><br><span class="line">    return pattern.matcher(str).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 中设置全屏的方法</title>
      <link href="/2019/04/16/Android-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/16/Android-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置</p><h1 id="一-在代码中设置"><a href="#一-在代码中设置" class="headerlink" title="一. 在代码中设置"></a>一. 在代码中设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BaseActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(saveInstanceState);</span><br><span class="line">        // 无title</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        // 全屏</span><br><span class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强调一点: <strong> 设置全屏的两段代码,必须在 <code>setContentView()</code> 之前调用,不然会报错 </strong></p><h1 id="二-在配置文件中修改"><a href="#二-在配置文件中修改" class="headerlink" title="二. 在配置文件中修改"></a>二. 在配置文件中修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest </span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  package=&quot;com.android.test&quot;</span><br><span class="line">  android:versionCode=&quot;1&quot;</span><br><span class="line">  ndroid:versionName=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;application android:icon=&quot;@drawable/icon&quot;</span><br><span class="line">    android:lable=&quot;@string/app_name&gt;</span><br><span class="line">    &lt;activity android:name=&quot;.BaseActivity&quot; </span><br><span class="line">        android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot;</span><br><span class="line">        android:lable=&quot;@string/app_name&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">  &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 获取 IP 地址</title>
      <link href="/2019/04/16/Android-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80/"/>
      <url>/2019/04/16/Android-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求,</p><p><strong>第一种方法: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);  </span><br><span class="line">WifiInfo wifiInfo = wifiManager.getConnectionInfo();  </span><br><span class="line"><span class="keyword">int</span> ipAddress = wifiInfo.getIpAddress();</span><br></pre></td></tr></table></figure><p>通过这种方式获取到的 IP 地址为一串数字,我们并不能看懂,因此我们需要通过下面的方法进行转换:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ip = (ipAddress &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;8 &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;16 &amp; 0xff) + &quot;.&quot; + (ipAddress &gt;&gt; 24 &amp; 0xff);</span><br></pre></td></tr></table></figure><p>这样转换之后,我们获取到的 IP 地址就是我们平时认识的, 比如: 192.168.1.108</p><p>这种方法在飞行模式下获取到的 IP 地址为 0.0.0.0</p><p><strong>第二种方法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  public String getLocalIpAddress() &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123;  </span><br><span class="line">            NetworkInterface intf = en.nextElement();  </span><br><span class="line">            for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123;  </span><br><span class="line">                InetAddress inetAddress = enumIpAddr.nextElement();  </span><br><span class="line">                if (!inetAddress.isLoopbackAddress()) &#123;  </span><br><span class="line">                    return inetAddress.getHostAddress().toString();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; catch (SocketException ex) &#123;  </span><br><span class="line">        Log.e(LOG_TAG, ex.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是比较通用的,在WiFi和3G/4G 状态下,都可以获取到正确的地址.比如: fe80::8e3a:e3ff:fe45:a018</p><p>这种方法在手机处于飞行状态下时, 获取到的 IP 地址为 null</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 在一个应用中启动另外一个应用</title>
      <link href="/2019/04/16/Android-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/"/>
      <url>/2019/04/16/Android-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Android 在一个应用中启动另外一个应用<br>Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动.</p><p>综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式.</p><h1 id="1-通过-APP-启动另一个-APP"><a href="#1-通过-APP-启动另一个-APP" class="headerlink" title="1. 通过 APP 启动另一个 APP"></a>1. 通过 APP 启动另一个 APP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String packageName = &quot;com.android.calendar&quot;;</span><br><span class="line">Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);</span><br><span class="line">intent.putExtra(&quot;type&quot;, true);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException.</p><p>通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 <code>android.intent.action.MAIN</code> 的 Activity 启动.</p><p>这里介绍两种方式,检测目标应用是否已经安装</p><p><strong> 方法一: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getPackageName().getLaunchIntentForPackage(packageName);</span><br><span class="line">if (intent == null) &#123;</span><br><span class="line">  // 这里判断 Intent 为空, 说明应用不存在 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);</span><br><span class="line">if (packageInfo == null) &#123;</span><br><span class="line">    // 这里如果 packageInfo 为 null, 说明应用不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-打开另外一个-APP-指定的-Activity"><a href="#2-打开另外一个-APP-指定的-Activity" class="headerlink" title="2. 打开另外一个 APP 指定的 Activity"></a>2. 打开另外一个 APP 指定的 Activity</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);</span><br><span class="line">intent.setComponent(componeneName);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>值得注意: </p><ul><li>需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.SecurityException: Permission Denial: starting  Intent </span><br><span class="line">&#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord</span><br><span class="line">&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125;  (pid=11545,     uid=10071) not exported from uid 10067</span><br></pre></td></tr></table></figure><ul><li>在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; </span><br><span class="line">have you declared this activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio Dependencies Library Resolve</title>
      <link href="/2019/04/16/Android-Studio-Dependencies-Library-Resolve/"/>
      <url>/2019/04/16/Android-Studio-Dependencies-Library-Resolve/</url>
      
        <content type="html"><![CDATA[<p>在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了.</p><p>先说点不正经的:</p><ol><li>你可以把你自己引入的包去掉,使用依赖包</li><li>放弃治疗</li></ol><p>哈哈,言归正传:</p><p>当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 <code>build.gradle</code> 中将我们不需要的包删除掉.</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子:"></a>举个栗子:</h2><p>当我使用 <code>com.squareup.retrofit2:adapter-rxjava:2.1.0</code> 时, 它默认依赖使用 <code>RxJava 1.5.0</code> 版本. 当我使用 <code>io.reactivex.rxjava2:rxjava:2.0.6</code> 时, 就会引起包冲突.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p>build.gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line"></span><br><span class="line">    compile (&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;)&#123;</span><br><span class="line">        exclude group: &apos;io.reactivex&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    compile &apos;io.reactivex.rxjava2:rxjava:2.0.6&apos;</span><br><span class="line">    compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git command</title>
      <link href="/2019/04/16/git-command/"/>
      <url>/2019/04/16/git-command/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><table><thead><tr><th style="text-align:center">修改记录</th><th style="text-align:center">修改时间</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">添加删除远程分支</td><td style="text-align:center">2018年07月26日13:59:22</td><td style="text-align:center">删除远程分支命令</td></tr><tr><td style="text-align:center">更新fork仓库</td><td style="text-align:center">2018年08月10日14:16:08</td><td style="text-align:center">添加fork的仓库，从主仓库更新代码的命令</td></tr></tbody></table><p>整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^</p><h2 id="Git-文件的三种状态"><a href="#Git-文件的三种状态" class="headerlink" title="Git 文件的三种状态"></a>Git 文件的三种状态</h2><ol><li>已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。</li><li>已修改：表示修改了某个文件，但还没有提交保存</li><li>已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。</li></ol><h2 id="远程仓库与本地代码的配置"><a href="#远程仓库与本地代码的配置" class="headerlink" title="远程仓库与本地代码的配置"></a>远程仓库与本地代码的配置</h2><p>将本地已经有的项目上传到远程空仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;project path&gt;</span><br><span class="line">git init</span><br><span class="line">git remote add origin &lt;远程仓库地址&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;提交日志&apos;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="Git-基本配置"><a href="#Git-基本配置" class="headerlink" title="Git 基本配置"></a>Git 基本配置</h2><ol><li>配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。</li></ol><p>使用 <code>--global</code> 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 <code>--global</code> 选项重新配置，新的配置位于当前项目的 <code>.git/config</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &apos;&apos;yourname&apos;&apos;</span><br><span class="line">git config --global user.email  yourname@gmail.com</span><br></pre></td></tr></table></figure><ol start="2"><li>基础命令</li></ol><blockquote><p>git init</p></blockquote><p>通过此命令会在当前目录创建一个<code>.git</code>的隐藏目录，这是<code>git</code>的第一步。</p><blockquote><p>git status</p></blockquote><p><code>git status</code>是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行<code>git commit</code> 还是执行<code>git add</code> 操作。</p><blockquote><p>git add</p></blockquote><p>将一个或多个文件添加到 <code>git</code>仓库中，只有通过 <code>git add</code> 添加的文件才会被版本控制管理。</p><p>添加单个文件 <code>git add HelloWorld2.java</code></p><p>添加多个文件 <code>git add --a</code></p><p>添加当前目录所有文件 <code>git add .</code></p><blockquote><p>git rm –cached <file></file></p></blockquote><p>将文件从<code>git</code>追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除</p><blockquote><p>git commit</p></blockquote><p>执行过 <code>git add</code> 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交</p><p>带 log 的提交： <code>git commit -m &#39;first commit&#39;</code></p><p>通过编辑器提交: <code>git commit</code></p><p>带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.</p><blockquote><p>git log</p></blockquote><p>查看历史提交记录， 包括<strong>提交人</strong>、<strong>时间</strong>、<strong>信息</strong>、<strong>信息指纹</strong>等.</p><p>查看提交记录： <code>git log</code></p><p>单行展示记录： <code>git log --pretty=oneline</code></p><p>展示全部信息： <code>git log --pretty=fuller</code></p><blockquote><p>git clone &lt;远程仓库地址&gt;</p></blockquote><p>拉取远程仓库代码,此项目并不一定是你所创建</p><p>例如： <code>git clone git@github.com:bboyfeiyu/AndroidEventBus.git</code></p><p>执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码</p><blockquote><p>git remote</p></blockquote><p>将本地已经<code>init</code>过的工程链接到远程的空仓库中，以此来完成远程版本库的创建</p><p>链接远程版本库： <code>git remote add origin &lt;远程地址&gt;</code></p><blockquote><p>git branch</p></blockquote><p>分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作</p><p>查看分支： <code>git branch</code></p><p>查看带提交信息的分支信息： <code>git branch -v</code></p><p>创建分支： <code>git branch &lt;分支名称&gt;</code></p><p>创建并切换分支： <code>git branch -b &lt;分支名称&gt;</code></p><p>切换分支： <code>git checkout &lt;分支名称&gt;</code></p><p>推送分支： <code>git push origin &lt;分支名称&gt;</code></p><p>删除分支： <code>git branch -d &lt;分支名称&gt;</code></p><p>删除远程分支： <code>git push origin :&lt;分支名称&gt;</code></p><p>合并分支： <code>git merge &lt;分支名称&gt;</code></p><blockquote><p>git tag </p></blockquote><p>会列出所有的 <code>tag</code> 标签信息</p><p>在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，<strong><em>这是一个很重要的功能</em></strong> </p><p>建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。</p><p>查看本地/远程 tag 标签：<code>git tag</code></p><p>查看模糊 tag 标签： <code>git tag -l &#39;v1.4.2.*&#39;</code></p><p>查看备注 tag 标签： <code>git tag -ln</code></p><p>查看标签信息： <code>git show &lt;标签名&gt;</code></p><p>创建本地 tag 标签： <code>git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot;</code></p><p>删除本地 tag 标签： <code>git tag -d &lt;标签名&gt;</code></p><p>推送远程 tag 标签： <code>git push origin &lt;标签名&gt;</code></p><p>推送全部 tag 标签： <code>git push origin -tags</code></p><p>删除远程 tag 标签： <code>git push origin :refs/tags/&lt;标签名&gt;</code></p><p><strong>查看远程机状态</strong></p><blockquote><p>git remote 用来管理， fork 的项目，与主项目的更新操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add upstream git@github.com:XXX/XXX.git</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/master</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="使用中的一些技巧"><a href="#使用中的一些技巧" class="headerlink" title="使用中的一些技巧"></a>使用中的一些技巧</h2><p><strong>命名别名</strong><br>复杂并超长的命令，可以通过起别名的方式方便在终端中书协</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.ck checkout</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><p>然后就可以很愉快的使用git命令了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git st</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开发一个Android IoT App</title>
      <link href="/2019/04/16/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App/"/>
      <url>/2019/04/16/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App/</url>
      
        <content type="html"><![CDATA[<h1 id="构建-Android-IoT-App"><a href="#构建-Android-IoT-App" class="headerlink" title="构建 Android IoT App"></a>构建 Android IoT App</h1><p>本文翻译自<a href="http://www.survivingwithandroid.com/2017/01/building-iot-app-android-things-android-iot-appplication-development.html" target="_blank" rel="noopener">Building IoT APP for Android Things in 3 step</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 <a href="http://www.survivingwithandroid.com/2017/01/android-things-android-internet-of-things.html" target="_blank" rel="noopener">Android Things and how it works</a> 是很有必要的。</p><h2 id="名词索引"><a href="#名词索引" class="headerlink" title="名词索引"></a>名词索引</h2><p>Android IoT App ： 安卓物联网应用</p><p>Raspberry Pi 3 ： 树莓派 3</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这篇文章的目标是：</p><ol><li>使用 Android Things 构建一个简单的 RGB Led 控制器</li><li>使用 Android API 构建 Android IoT UI 开发</li></ol><p>我们会使用 <code>Raspberry Pi 3</code> 作为 <a href="http://www.survivingwithandroid.com/2016/08/iot-rapid-prototyping-board.html" target="_blank" rel="noopener">IoT 开发板</a>,你也可以使用其他的开发板去开发 Android Things。</p><p>此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。</p><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 <code>Raspberry</code>， 每个颜色一个，原理图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-ce68329a358d9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引脚原理图"> </p><p>共阳极 RGB LED 灯非常常见，因此 <code>Raspberry Pi 3</code> 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 <code>Raspberry</code> 引脚：</p><ul><li>Pin 29</li><li>Pin 31</li><li>Pin 33</li></ul><p>这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。</p><p>现在，我们使用  <code>Android Studio</code> 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    provided &apos;com.google.android.things:androidthings:0.1-devpreview&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 <code>RGBThingsActivity</code> 类，并在 <code>onCreate</code> 方法中处理 <code>Pin</code> 通信。</p><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>使用 <code>GPIO</code> 引脚与 RGB LED 传递信息。 <code>GPIO</code> 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。</p><p>Android Things SDK 提供了一个 <code>PeripheralManagerService</code> 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   PeripheralManagerService manager = new PeripheralManagerService();</span><br><span class="line">   blueIO = manager.openGpio(&quot;BCM5&quot;);</span><br><span class="line">   blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);</span><br><span class="line">   greenIO = manager.openGpio(&quot;BCM6&quot;);</span><br><span class="line">   greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);</span><br><span class="line">   redIO = manager.openGpio(&quot;BCM13&quot;);</span><br><span class="line">   redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);</span><br><span class="line">   redIO.setValue(false);</span><br><span class="line">   blueIO.setValue(false);</span><br><span class="line">   greenIO.setValue(false);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">   Log.w(TAG, &quot;Unable to access GPIO&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 <a href="https://developer.android.com/things/hardware/raspberrypi-io.html" target="_blank" rel="noopener">Respberry Pin reference</a> ,下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-0957d79bc802bd94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树莓派引脚图"></p><p>可以了解到 <code>Respberry Pi 3</code> 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueIO = manager.openGpio(&quot;BCM5&quot;);</span><br></pre></td></tr></table></figure><p>开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。</p><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;Switch android:text=&quot;Red&quot;</span><br><span class="line">         android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:id=&quot;@+id/switchRed&quot;</span><br><span class="line">         android:layout_marginTop=&quot;20dp&quot;/&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;Switch android:text=&quot;Green&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:id=&quot;@+id/switchGreen&quot;</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;/&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;Switch android:text=&quot;Blue&quot;</span><br><span class="line">         android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:id=&quot;@+id/switchBlue&quot;</span><br><span class="line">         android:layout_marginTop=&quot;20dp&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>在 <code>onCreate</code> 方法中，我们设置 layout 布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate (Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(saveInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理用户开关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Switch switchRed = (Switch)findViewById(R.id.switchRed);</span><br><span class="line">switch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCheckedChanged (CompoundButton buttonView, boolean isChecked)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            redIO.setValue(!isChecked);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Log.w(TAG,&quot;Red GPIO Error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们必须为其他引脚重复同一段代码。最终结果如下：</p><p>因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。</p><p><a href="https://www.youtube.com/embed/KT_FAqMbbNQ" target="_blank" rel="noopener">最终结果展示–需要翻墙 youtube 上观看</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/KT_FAqMbbNQ" frameborder="0" allowfullscreen></iframe><p>最后，要使用我们的应用程序，我们必须在 <code>Manifest.xml</code> 文件中条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt;</span><br></pre></td></tr></table></figure><p>并且声明我的 <code>Activity</code> 是一个 IoT Activity， 启动脚本为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。</p><p>使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins + gradle + git 构建 Android CI 构建环境</title>
      <link href="/2019/04/16/Jenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/04/16/Jenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。</p><p>目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。</p><p>然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。</p><p>因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。</p><p>对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。</p><p>对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。</p><p>CI 的基本工作流程如下：<br><img src="http://upload-images.jianshu.io/upload_images/1550996-5101eac8d87352a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p><p>我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本文使用 Linux Ubuntu 系统为大家介绍环境的搭建</p><h2 id="环境工具"><a href="#环境工具" class="headerlink" title="环境工具"></a>环境工具</h2><pre><code>1. PC 机(mac/linux)2. Java JDK3. Android SDK4. Gradle5. Git6. Tomcat7. Jenkins</code></pre><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Java-环境-安装"><a href="#Java-环境-安装" class="headerlink" title="Java 环境 安装"></a>Java 环境 安装</h3><p>Java JDK, Android SDK, Gradle 可从<a href="http://androiddevtools.cn" target="_blank" rel="noopener">AndroidDevTools</a>处下载获取。</p><h3 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h3><p>git 可通过终端进行安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>安装完成之后通过<code>git --version</code> 检查是否成功</p><p>安装后 git 存储在 <code>/usr/bin/git</code>下</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>通过 Jenkins <a href="https://jenkins.io/index.html" target="_blank" rel="noopener">官方网站</a>下载最新Jenkins.war包</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-d2654c0a1383423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins 下载"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>打开 <code>vi /etc/profile</code></p><p>将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq</p><p>其中环境位置根据自己的所在位置进行相应的更改</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-ffd5f1b87d0e5bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环境变量"></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins</p><p>将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。</p><p>启动后，在浏览器中输入： <code>localhost:8080/jenkins</code></p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-cbdb39d4f2f4a85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jenkinsmain.png"></p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>系统管理-&gt; 插件管理-&gt;可选插件：</p><p>在搜索框中搜索以下插件，并进行安装</p><p>git plugin<br>gitlab plugin<br>grade plugin<br>Android Lint Plugin<br>Build Pipeline plugin<br>build timeout plugin<br>build name plugin<br>change assembly-version plugin<br>credentials binding plugin<br>description setter plugin<br>Dynamic parameter plugin<br>Email Extension plugin<br>FindBugs plugin<br>JaCoco plugin<br>Unit attachments plugin<br>Project Description plugin<br>Timestamper<br>Workspace cleanup plugin</p><p>安装完成后，重启。</p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><p>系统管理-&gt;系统设置：</p><p>配置Android 环境，将地址指向本机的 SDK 目录<br><img src="http://upload-images.jianshu.io/upload_images/1550996-5987aabcffb290c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android environment"></p><p>系统管理-&gt;全局工具配置</p><p>配置 Java， Git ， Gradle 目录等</p><p>JDK：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-b9e29a1ec2b746e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java JDK"></p><p>Git：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-9c4e88d64fcc2ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git"></p><p>Gradle：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-9fbabc7d5c7ca319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle"></p><p>到此，环境配置，已基本完成。</p><p>下面我们开始进行项目够将操作</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="创建Job"><a href="#创建Job" class="headerlink" title="创建Job"></a>创建Job</h3><p>新建-&gt;构建一个自由风格的软件项目:</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-2390d86256678c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建CI工程"></p><h3 id="参数化构建"><a href="#参数化构建" class="headerlink" title="参数化构建"></a>参数化构建</h3><p>通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。</p><p>在这里我们先看看 build.gradle 中的构建信息:</p><p>在项目的 moudle 下 build.gradle 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">def getDate () &#123;</span><br><span class="line">    def date = new Date()</span><br><span class="line">    def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;)</span><br><span class="line">    return formattedDate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def verName = APP_VERSION</span><br><span class="line">def verCode = 14</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ....</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          keyAlias &apos;&apos;</span><br><span class="line">          keyPassword &apos;&apos;</span><br><span class="line">          storeFile file (&apos;&apos;)</span><br><span class="line">          storePassword &apos;&apos;</span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">      applicationId &quot;cn.zhuangbudong.example&quot;</span><br><span class="line">      minSdkVersion 18</span><br><span class="line">      targetSdkVersion 25</span><br><span class="line">      multiDexEnabled true</span><br><span class="line">      versionCode verCode</span><br><span class="line">      versionName verName</span><br><span class="line"></span><br><span class="line">      resValues(&quot;string&quot;, &apos;app_version&apos;, verName)</span><br><span class="line">  &#125;</span><br><span class="line">  buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      signingConfig signingConfigs.release</span><br><span class="line">      minifyEnabled false</span><br><span class="line">      proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   lintOptions &#123;</span><br><span class="line">    abortOnError false</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   dexOptions &#123;</span><br><span class="line">      javaMaxHeapSize &apos;2g&apos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">        def newName</span><br><span class="line">        def timeNow</span><br><span class="line">        def oldFile = output.outputFile</span><br><span class="line">        def outDirectory = oldFile.parent</span><br><span class="line">        if (&quot;true&quot;.equals(IS_JENKINS)) &#123; </span><br><span class="line">            timeNow = JENKINS_TIME</span><br><span class="line">            outDirectory = &quot;/media/nexd/work/android/package/release/&quot;</span><br><span class="line">            newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; </span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            timeNow = getDate()</span><br><span class="line">            if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; </span><br><span class="line">               newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_debug.apk&quot;  </span><br><span class="line">          &#125; else &#123; </span><br><span class="line">               newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       output.outputFile = new File(outDirectory, newName)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>gradle.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APP_VERSION=2.0.2</span><br><span class="line">IS_JENKINS=false</span><br><span class="line">JENKINS_TIME=&apos;&apos;</span><br></pre></td></tr></table></figure><p>在工程中添加以上代码，并在Jenkins中为这些参数赋值。</p><p>下面介绍 Jenkins 参数配置</p><p>勾选参数化构建过程，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1550996-20f69e63a527814c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="参数化构建"></p><p>按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-e0f4ceb7015ac0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JENKINS_TIME"><br><img src="http://upload-images.jianshu.io/upload_images/1550996-6e3f8d0311399d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APP_VERSION"><br><img src="http://upload-images.jianshu.io/upload_images/1550996-673c2465bcdc9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IS_JENKINS"><br><img src="http://upload-images.jianshu.io/upload_images/1550996-a82221191b980ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ENVIRONMENT"></p><h3 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h3><p>此处负责从版本库中拉去最新的代码</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-6dcbd8dd2dd9456c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git 仓库"></p><p>此处如果需要验证，点击 Add， 选择： Username with password</p><p>在对应窗口输入用户名和密码信息<br><img src="http://upload-images.jianshu.io/upload_images/1550996-8af978712a010864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户身份验证"></p><p>点击添加。</p><p>使用 gitlab 进行源码库管理。</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-beb6ff8faa9843f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="触发器构建"></p><h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><p>此处只是在Jenkins在打包时，配置任务名称即可。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-45b210c5df916dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建环境"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>这里是最重要滴，配置以下命令，才能进行打包签名等等。</p><p>如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。</p><p>同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-4e4e6e139fc1e856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建"></p><h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><p>当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-63b6bcb7b2dfd551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="邮件发送"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr/&gt;</span><br><span class="line">(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">项目名称：$&#123;PROJECT_NAME&#125;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">构建编号：$&#123;BUILD_NUMBER&#125;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">构建状态：$&#123;BUILD_STATUS&#125;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">测试报告：&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&quot;&gt;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">构建地址：&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">构建报告：&lt;a href=&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;</span><br><span class="line">变更集:$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr/&gt;</span><br></pre></td></tr></table></figure><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>回到 Jenkins 首页，点击创建的项目，点击 build with parameters:</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-58ecc4965ab845ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Build with Parameters"></p><p>点击开始构建，启动 Jenkins 构建任务。</p><p>构建成功时，显示为蓝色， 失败为红色，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1550996-4b2fc4b1190ddcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建结果"></p><p>构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。</p><p>谢谢~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>adb command</title>
      <link href="/2019/04/16/adb-command/"/>
      <url>/2019/04/16/adb-command/</url>
      
        <content type="html"><![CDATA[<ol><li><p>查看PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全部日志</span><br><span class="line">adb logcat</span><br><span class="line"></span><br><span class="line">按照 PID 筛选日志</span><br><span class="line">adb logcat | grep &lt;PID&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询链接设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure></li><li><p>重启机器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure></li><li><p>杀死进程服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure></li><li><p>重启进程服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure></li><li><p>获取机器 Mac 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure></li><li><p>安装 APK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">普通安装</span><br><span class="line">adb install &lt;file path&gt;</span><br><span class="line"></span><br><span class="line">保留数据和缓存文件</span><br><span class="line">adb install -r &lt;file path&gt;</span><br><span class="line"></span><br><span class="line">安装到 SD 卡上</span><br><span class="line">adb install -s &lt;file path&gt;</span><br></pre></td></tr></table></figure></li><li><p>卸载 APK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通卸载</span><br><span class="line">adb uninstall &lt;package name&gt;</span><br><span class="line"></span><br><span class="line">保留数据和缓存文件</span><br><span class="line">adb uninstall -k &lt;package name&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看 CPU 占用率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell top</span><br><span class="line"></span><br><span class="line">查看内存占用前 6 的 app</span><br><span class="line">adb shell top -m 6</span><br><span class="line"></span><br><span class="line">刷新一次内存</span><br><span class="line">adb shell top -n 1</span><br></pre></td></tr></table></figure></li><li><p>杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell kill &lt;pid&gt;</span><br></pre></td></tr></table></figure></li><li><p>将 System 分区重新挂在为可读写分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb remount</span><br></pre></td></tr></table></figure></li><li><p>从本地复制文件到设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &lt;local&gt; &lt;remote&gt;</span><br></pre></td></tr></table></figure></li><li><p>从设备复制文件到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &lt;remote&gt; &lt;local&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看 WiFi 密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure></li><li><p>查看 bug 报告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb bugreport</span><br></pre></td></tr></table></figure></li><li><p>跑 monkey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -v -p your.package.name 500</span><br></pre></td></tr></table></figure></li><li><p>截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure></li><li><p>录屏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/demo.mp4</span><br></pre></td></tr></table></figure></li><li><p>查看安装列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
