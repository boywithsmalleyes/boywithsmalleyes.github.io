<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2021%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数组是一片物理上连续的大小确定的存储空间 数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。 利用索引进行查询速度快，无法真正的删除 List具有连续有序性，可重复性，可扩容性，访问比较便捷 ArrayList原理与特点 实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。 123456789101112131415161718192021222324252627 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ensureCapacityInternal(size + 1); // Increments modCount!! // 移位操作 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;public E remove(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) // 移位操作 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 扩容机制： ArrayList 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。 123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // oldCapacity &gt;&gt; 1 等价于 oldCapacity / 2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; LinkedList是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 node 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。 因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。 因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢 12345678910111213141516171819public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // 从前面查找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 从后面查找 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 //插入数据 public void add(int index, E element) &#123; if (index == size) linkLast(element); else // 插入时，有时也需要遍历，这里可以忽略 linkBefore(element, node(index)); &#125; void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125;// 移除数据 private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; Vector和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 synchronized，因此性能比 ArrayList 差，每次扩容申请双倍空间也可以自定义。 Set具有不可重复性，无序性，不可查找的特点 HashSetHashSet 的内部使用 HashMap 来存储数据，即 add 时，将元素当作 HashMap 的 Key 来使用，这也符合 Set 集合不可重复性的特点。 此类集合不可以直接获取容器中的 value， 可通过遍历 迭代器 来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 ConCurrentException 。 LinkedHashSet同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。 List 和 Set 的区别 是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许 元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合 List 可以通过下标来访问元素， 而 Set 不能 HashMap数组 和 单链表 的组合， 数组用来存储 key，链表用来存储实际的 value put(K key, V value);当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值， 当链表为空时，通过 resize() 函数帮我创建一个新链表，默认长度为 16 （1 &lt;&lt; 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗) 当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** 装箱过程，计算 hash 值的过程。* */static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // tab[i = (n - 1) &amp; hash] // n 是数组的长度，经过 &amp; 和 hash 值的位运算（模运算：求余数的运算，等价于=&gt; （hash % n）），获得该元素在数组中的索引 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K, V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; Hash 碰撞/冲突在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值 解决方案： 链表法： 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 get() 函数获取数据时，拿到一个链表，就遍历，找到 hash 值相同的那个节点，并返回。 避免冲突： 阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。 扩容方案： 加载因子：loadFactor 默认值是 0.75 阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android 使用空间换时间。 HashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。 比如： length1 = 10，(非 2 的次幂)，对应的二进制数是 1001 length2 = 16(2 的 4 次幂)，对应的二进制数是 1111 当产生一个 hash 值，为 6（0110）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110 当产生一个 hash 值，为 7（0111）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111 由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞 当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。 当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。 开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。 SparseArray原理与特点 由 双数组 构成，两个数组分别存储 Key 和 Value ，并一一对应。 查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升） 通过获取 key 的索引找到其对应的 value 值，也就具备了 查询速度快 的特点（也是数组的特点） 删除元素时，仅将元素标记位 “DELETE” 状态，不发生移位等操作，因此速度上会比 ArrayList 快 因为是标记为 “DELETE” ，因此算法是可以达到复用，再利用二分查找，被标记为 “DELETE” 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。 缺点是，Key 只能是 int 类型数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public void put(int key, E value) &#123; // 二分查找，快速定位传入的 key 所在位置 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); // 如果存在，直接替换同位置数据 if (i &gt;= 0) &#123; mValues[i] = value; &#125; else &#123; // 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值 i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; // 扩容机制，2倍 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125; &#125;public static int[] insert(int[] array, int currentSize, int index, int element) &#123; int[] newArray = new int[growSize(currentSize)]; System.arraycopy(array, 0, newArray, 0, index); newArray[index] = element; System.arraycopy(array, index, newArray, index + 1, array.length - index); return newArray; &#125; public static int growSize(int currentSize) &#123; // 2 倍扩容机制 return currentSize &lt;= 4 ? 8 : currentSize * 2; &#125; // 移除数据，仅标记 DELETE 状态 public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125; &#125; 扩容机制： 同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。 ArrayMap是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 hashcode 作为 key，弥补了 SparseArray 只能是 int 型。使用双数组的形式，又弥补了 HashMap 的对内存消耗的问题。 LinkedHashMap是 HashMap 的子类， put 和 remove 函数使用的就是 HashMap 的，没有太大却别，主要区别在于 get 函数， LinkedHashMap 在每次 get 出一个数据后，会将这个数据放在链表的尾部。 LinkedHashMap 的应用，在 LRUCache 和 DiskLRUCache 中使用，其算法名称 最少/最小使用算法 ，也就是说，利用了 LinkedHashMap 的 get 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。 队列 Queue 和 栈 Stack 队列的特点是 先入先出 栈的特点是 先入后出 栈特点： 后进先出； 所有的操作都是围绕栈顶部来完成 算法的基本思想： 可以用一个单链表来实现 只关心上一次的操作 处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作 123456789101112131415161718192021222324252627// 查找下一个比自己大的数的距离public void stackSwap(int[] nums) &#123; // 定义一个栈，用来缓存当前的最大值的索引 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 定义一个数组，用来存储对应数据的间距 int[] interval = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++) &#123; if(!stack.empty())&#123; // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位 int size = stack.size(); for(int j = 0; j &lt; size; j++) &#123; // 拿出栈顶数据的索引 int topIndex = stack.peek(); if(nums[i] &gt; num[topIndex]) &#123; interval[topIndex] = i - topIndex; stack.pop(); &#125; &#125; &#125; // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入 // 或找不到一个比当前数据大的数据时，将当前数据压入栈 stack.push(i); &#125; &#125; 队列和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。 实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。 应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2021%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高频数据结构和算法数据结构 数组/字符串 链表 栈 队列 双端队列 树 数组 优点： 可以在 O（1） 的时间里根据下标查询某个元素 缺点： 构建时必须时一段连续的空间 查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间 删除和添加某个元素时，同样需要耗费O(n) 的时间 链表单链表： 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起 双链表： 与单链表不同的时，双链表的每个节点中都含有两个引用字段 优点： 灵活的内存空间 能在 O(1) 时间内删除或添加元素 缺点： 查询元素需要O(n)时间 解题技巧： 利用快慢指针（有时需要3个） 构建一个虚假的链表头 练习： eg: k 个一组反转链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null 12345678910// 假设 k = 3prev = null;curr = head;n = k;while(curr &amp;&amp; n-- &gt; 0) &#123; next = curr.next; curr.next = prev; prev = curr; curr = next;&#125; 栈特点： 后进先出； 所有的操作都是围绕栈顶部来完成 算法的基本思想： 可以用一个单链表来实现 只关心上一次的操作 处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作 123456789101112131415161718192021222324252627// 查找下一个比自己大的数的距离public void stackSwap(int[] nums) &#123; // 定义一个栈，用来缓存当前的最大值的索引 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 定义一个数组，用来存储对应数据的间距 int[] interval = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++) &#123; if(!stack.empty())&#123; // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位 int size = stack.size(); for(int j = 0; j &lt; size; j++) &#123; // 拿出栈顶数据的索引 int topIndex = stack.peek(); if(nums[i] &gt; num[topIndex]) &#123; interval[topIndex] = i - topIndex; stack.pop(); &#125; &#125; &#125; // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入 // 或找不到一个比当前数据大的数据时，将当前数据压入栈 stack.push(i); &#125; &#125; 队列和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。 实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。 应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。 双端队列可以利用双链表实现 队列 排序算法冒泡数据像鱼吐泡泡一样，从底部向上浮出 12345678910111213141516public void maopao(int[] num) &#123; for(int i = 0; i &lt; num; i++) &#123; for(int j = 0; j &lt; num.length - 1 - i; j++) &#123; if(num[j] &gt; num[j+1]) &#123; swap(num, j, j + 1); &#125; &#125; &#125;&#125;public void swap(int[] num, int src, int des) &#123; int temp = num[src]; num[src] = num[des]; num[des] = temp; System.out.println(Arrays.toString(num));&#125; 插入向已排列好的数组中插入数据 1234567891011public void charu(int[] num) &#123; for(int i = 1; i &lt; num.length; i++) &#123; int k = i; // 记录当前最小值的索引 for(int j = (i -1); j &gt;= 0; j--) &#123; if(num[k] &lt; num[j]) &#123; swap(num, k, j); k = j; &#125; &#125; &#125;&#125; 选择先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较 1234567891011121314public void xuanze(int[] num) &#123; for (int i = 0; i &lt; num.length; i++) &#123; int minIndex = i; // 已排序数组的最大值 for(int j = i + 1; j &lt; num.length; j++) &#123; if(num[minIndex] &gt; num[j]) &#123; minIndex = j; // 找到未排序部分的最小值索引 &#125; &#125; // 与已排序部分最大值比较，小则交换 if(num[minIndex] &lt; num[i])&#123; swap(num, minIndex, i) &#125; &#125;&#125; 归并利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果 利用二叉树，左右两边同时排序，最后将两部分合并再一起 递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow） 1234567891011121314151617181920212223242526272829public void guibing(int[] num, int left, int right) &#123; if (left &gt;= right) return; // 临界点判断，终止递归 int mid = (right + left) &gt;&gt; 1; // 取中间值 guibing(nums, left, mid); guibing(nums, mid + 1, right); merge(nums, left, right, mid);&#125;public void merge(int[] nums, int start, int length, int mid) &#123; int[] copy = nums.clone(); // index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界 int index = start, left = start, right = mid + 1; while(index &lt;= length) &#123; if (left &gt; mid) &#123; // 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充 nums[index++] = copy[right++]; &#125; else if(right &gt; length)&#123; // 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充 nums[index++] = copy[left++]; &#125; else if(copy[right] &lt; copy[left])&#123; // 右侧数据比左侧数据小，将右侧数据填充 nums[index++] = copy[right++]; &#125; else &#123; // 左侧数据比右侧数据小，将左侧数据填充 nums[index++] = copy[left++]; &#125; &#125; System.out.println(Arrays.toString(nums));&#125; 快排同样利用递归的思想。 先随机选择一个数，然后让比它小的放在左边，大的放在右边 然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边 12345678910111213141516171819202122232425262728293031public void kuaisu(int[] num, int low, int high) &#123; if(low &gt; high) return; int p = partition(nums, low, high); kuaisu(nums, low, p - 1); kuaisu(nums, p + 1, high);&#125; // 先随机一个索引，然后将他放在最后面。 // 在定义两个指针 // i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置 // j: 当前第一个值public void partition(int[] num, int low, int high) &#123; // 先将最小值， copy 到最后一个位置 int random = randRang(low, high); swap(num, random, high); // i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置 int i, j; // 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小 for(i = low, j = low, j &lt; high, j++) &#123; if(num[j] &lt; num[high]) &#123; // num[j] 当前值 // num[high] 随机数，基准值 swap(num, i++, j); &#125; &#125; // 将基准值还原到对应位置 swap(num, i, j); return i;&#125;private int randRang(int low, int high) &#123; return new Random().nextInt(high) % (high - low + 1) + low;&#125;]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide]]></title>
    <url>%2F2021%2F01%2F29%2F%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%2FGlide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 Picasso 和 ImageLoader 两套框架。 都各有特色。这里主要还是讲一下 Glide 。基础用法： 1Glide.with(this).load(url).into(imageView); 在 Android 开发中，我们通常最简单的使用 Glide 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。 从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，with load 和 into，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。 函数 主要功能 with 1. 初始化Glide对象2. 创建空白的 Fragment 管理生命周期机制3. 创建一个 RequestManager 管理任务 load 最终构建出 RequestBuilder ，记录传入的数据 into 1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象2. 活动缓存3. 内存缓存4. HttpUrlConnection 工作流程Glide 通过 with 函数，给自己的实例化，并创建一个空白的 Fragment 来管理生命周期并绑定 ReqeustManager 。继续通过 load() 函数构建一个 RequestBuilder() 并缓存我们的参数，继续通过 into 创建一个 Request 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 ActivityResources 有没有数据，再检查内存缓存 LRUResourceCache ，如果两级缓存都未命中，则启动一个异步任务 DecodeJob, 去检查 DiskCache 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 HttpUrlConnection ，解析 InputStream 进行采样，最终拿到 Bitmap，将 Bitmap 转换成 Drawable 并讲数据缓存到磁盘中。 with从上面的表格中，我们可以看出来 with 函数，就是用来帮我创建 Glide 对象，并创建一个空白的 Fragment 来管理生命周期。其具体的工作流程如图： 由上面的时序图，我们可以顺序的分析，我们一步步去分析。 Glide.with() Glide.with() 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。 1234567891011121314151617181920212223242526272829@NonNullpublic static RequestManager with(@NonNull Context context) &#123; return getRetriever(context).get(context);&#125;@NonNullpublic static RequestManager with(@NonNull Activity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull Fragment fragment) &#123; return getRetriever(fragment.getContext()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull android.app.Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull View view) &#123; return getRetriever(view.getContext()).get(view);&#125; getRetriever() getRetriever() 通过 Glide 的 get 函数，帮我们初始化了一个 Glide 对象。 1234@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; return Glide.get(context).getRequestManagerRetriever();&#125; get(context) 可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。 123456789101112private static volatile Glide glide;@NonNullpublic static Glide get(@NonNull Context context) &#123; if (glide == null) &#123; synchronized (Glide.class) &#123; if (glide == null) &#123; checkAndInitializeGlide(context, annotationGeneratedModule); &#125; &#125; &#125; return glide;&#125; checkAndInitializeGlide() &amp; initializeGlide() 最终通过构造者模式，完成了对 Glide 对象的初始化，同时在构造者中，也对很多 Glide 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。 1234567891011121314private static void checkAndInitializeGlide( if (isInitializing) &#123; throw new IllegalStateException( "You cannot call Glide.get() in registerComponents()," + " use the provided Glide instance instead"); &#125; isInitializing = true; initializeGlide(context, generatedAppGlideModule); isInitializing = false;&#125;private static void initializeGlide(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule) &#123; Glide glide = builder.build(applicationContext); Glide.glide = glide;&#125; 到这里， Glide 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。 并且代码按照流程，get() 的深度代码已经完成，程序会逐步回到 getRetriever() 函数中，去执行 getRequestManagerRetriever ， getRequestManagerRetriever 是通过Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 with()函数 的 get() 去创建 RequestManager get(Fragment fragment) 这时候，我们发现，现在代码已经跳转到 RequestManagerRetriever 类中 RequestManagerRetriever RequestManagerRetriever 是一个管理类，负责生产 Fragment 对象，根据我们传入的 Context 上下文的定义不同，最终会帮我们创建不同的生命周期管理。 123456789101112131415161718192021222324252627@NonNullpublic RequestManager get(@NonNull Fragment fragment) &#123; if (Util.isOnBackgroundThread()) &#123; // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题 return get(fragment.getContext().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible()); &#125;&#125;public RequestManager get(@NonNull Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException("You cannot start a load on a null Context"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题 return getApplicationManager(context);&#125; Note: 如果当前任务工作在后台线程或者传入的 Context 对象是一个 Application 级别的，那 Glide 就会帮我们创建一个和 Application 同生命周期的 RequestManager 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成内存的泄漏。 因此我们使用时，尽量不要传入里类似的。 如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 Glide 就会帮我们创建个空白的 Fragment， supportFragmentGet 和 fragmentGet 两种方案是用来做 androidX 和 android.app中不同 fragment 的适配 supportFragmentGet 创建管理生命周期的 Fragment, androidx 对应的是 supportFragmentGet() ， android.app 对应的是 fragmentGet()， 这里以 supportFragmentGet() 为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@NonNullprivate RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123; // 创建/获取当前空白的 Fragment SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint, isParentVisible); // 获取空白 Fragment 中的 RequestManager 对象 // 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中 RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); &#125; // 返回 reqeustManager 对象 return requestManager;&#125;@NonNullprivate SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123; // 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); // 如果为空，说明空白的 Fragment 还没有被添加进去 if (current == null) &#123; // pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象 // 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象， // 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment， // 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap current = pendingSupportRequestManagerFragments.get(fm); // 第一保障 // 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建 if (current == null) &#123; // 创建一个新的空白 Fragment current = new SupportRequestManagerFragment(); current.setParentFragmentHint(parentHint); if (isParentVisible) &#123; // 调用生命周期方法，让所有的监听者开始任务（后面会说） current.getGlideLifecycle().onStart(); &#125; // 将创建好的 Fragment 存入到集合中 pendingSupportRequestManagerFragments.put(fm, current); // Handler 通知父容器，这里添加了一个 Fragment fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); // 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障） handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125; Note: 这里有一个比较困惑的地方就是，将已经创建好的 Fragment 添加到集合中去后，又通过 Handler 消息，将这个 Fragment 从集合中移除，这是为什么呢？ 其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，fragment 的添加也是通过 Handler 来完成的，但 Handler 消息的执行时间不能保证，因此通过 Handler 再发一次消息，让移除操作在 Fragment 添加完成之后去执行，就一定能够得到保障。 只有当 Fragment 被添加进入父容器之后， fm.findFragmentByTag 才能获取到对象。这也是为了保证每个父容器都只有一个空白 Fragment 的两次保障。 类关系图至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图 SupportRequestManagerFragment 内部绑定了 ActivityFragmentLifecycle ，通过 Fragment 生生命周期变化，来引导 RequestManager 完成图片的请求和后续的显示 我们查看下源码： 1234567891011121314151617181920212223242526272829303132333435public class SupportRequestManagerFragment extends Fragment &#123; private static final String TAG = "SupportRMFragment"; private final ActivityFragmentLifecycle lifecycle; @SuppressLint("ValidFragment") public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) &#123; // 构造器创建了 ActivityFramgentLifecycle this.lifecycle = lifecycle; &#125; // 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧 @Override public void onStart() &#123; super.onStart(); lifecycle.onStart(); &#125; @Override public void onStop() &#123; super.onStop(); lifecycle.onStop(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); lifecycle.onDestroy(); unregisterFragmentWithRoot(); &#125; @NonNull ActivityFragmentLifecycle getGlideLifecycle() &#123; return lifecycle; &#125;&#125; 当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。 load 我们将 Glide.with(this).load(url).into(view); 拆分开来写，如下： 123RequestManager requestManager = Glide.with(this);RequestBuilder requestBuilder = requestManager.load(url);requestBuilder.into(view); 可以看出， load 函数，我们传入了一个 String 类型的 Url， 最终返回给我们一个 RequestBuilder 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 RequestBuilder 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 Drawable 。 Glide 也为我们提供了丰富的 load api， 我们可以传入 url, bitmap, byte[], Drawable, Uri, File, Integer 等等， RequestBuilder 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 Drawable 给图片容器，也就是后面我们要说的 into 函数。 intointo 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。 但我们先按照这个残图先分析一下。 当 into(imageview) 被调用后 1234567891011121314151617181920212223242526272829public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) &#123; Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&lt;?&gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) &#123; switch (view.getScaleType()) &#123; case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. &#125; &#125; Glide 显示对图片进行了解析，获取图片的尺寸等信息。 1234567891011121314151617private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options, Executor callbackExecutor) &#123; Preconditions.checkNotNull(target); if (!isModelSet) &#123; throw new IllegalArgumentException("You must call #load() before calling #into()"); &#125; Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target;&#125; 继续，创建了一个 Request ，这个 Request 的真实对象是 SingleRequest ，并通过 requestManager 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。]]></content>
      <tags>
        <tag>三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 数学公式编辑]]></title>
    <url>%2F2021%2F01%2F29%2FTools%2FMarkdown%20%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Markdown中公式编辑教程markdown中公式编辑教程标签： Mathjax 公式编辑 markdown 一般公式分为两种形式，行内公式和行间公式。 行内公式： %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.) 行间公式： %3D \int_0^\infty t^{z-1}e^{-t}dt\%2C.) 对应的代码块为： 12$ \Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,. $$$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$ 行内公式是在公式代码块的基础上前面加上$ ，后面加上$ 组成的，而行间公式则是在公式代码块前后使用$$ 和$$ 。 下面主要介绍数学公式中常用的一些符号。 希腊字母 名称 大写 code 小写 code alpha A A α \alpha beta B B β \beta gamma Γ \Gamma γ \gamma delta Δ \Delta δ \delta epsilon E E ϵ \epsilon zeta Z Z ζ \zeta eta H H η \eta theta Θ \Theta θ \theta iota I I ι \iota kappa K K κ \kappa lambda Λ \Lambda λ \lambda mu M M μ \mu nu N N ν \nu xi Ξ \Xi ξ \xi omicron O O ο \omicron pi Π \Pi π \pi rho P P ρ \rho sigma Σ \Sigma σ \sigma tau T T τ \tau upsilon Υ υ \upsilon phi Φ \Phi ϕ \phi chi X X χ \chi psi Ψ \Psi ψ \psi omega Ω \Omega ω \omega 上标与下标 上标和下标分别使用^ 与_ ，例如$x_i^2$表示的是：。 默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{..} 包裹起来的内容。如果使用$10^10$ 表示的是，而$10^{10}$ 才是。同时，大括号还能消除二义性，如x^5^6 将得到一个错误，必须使用大括号来界定^的结合性，如${x^5}^6$ ：或者$x^{5^6}$ ：。 括号小括号与方括号 使用原始的( ) ，[ ] 即可，如$(2+3)[4+4]$ ：) 使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如$\left(\frac{x}{y}\right)$ ：) 大括号 由于大括号{} 被用于分组，因此需要使用\{和\}表示大括号，也可以使用\lbrace 和\rbrace来表示。如$\{a\*b\}:a\∗b$ 或$\lbrace a\*b\rbrace :a\*b$ 表示。 尖括号 区分于小于号和大于号，使用\langle 和\rangle 表示左尖括号和右尖括号。如$\langle x \rangle$ 表示：。 上取整 使用\lceil 和 \rceil 表示。 如，$\lceil x \rceil$：。 下取整 使用\lfloor 和 \rfloor 表示。如，$\lfloor x \rfloor$：。 求和与积分求和 \sum 用来表示求和符号，其下标表示求和下限，上标表示上限。如: $\sum_{r=1}^n$表示：。 $$\sum_{r=1}^n$$表示： 积分 \int 用来表示积分符号，同样地，其上下标表示积分的上下限。如，$\int_{r=1}^\infty$：。 多重积分同样使用 int ，通过 i 的数量表示积分导数： $\iint$ ： $\iiint$ ： $\iiiint$ ： 连乘 $\prod {a+b}$，输出：。 $\prod_{i=1}^{K}$，输出：。 $$\prod_{i=1}^{K}$$，输出：。 其他 与此类似的符号还有， $\prod$ ： $\bigcup$ ： $\bigcap$ ： $arg\,\max_{c_k}$： $arg\,\min_{c_k}$： $\mathop {argmin}_{c_k}$： $\mathop {argmax}_{c_k}$： $\max_{c_k}$： $\min_{c_k}$： 分式与根式分式 第一种，使用\frac ab，\frac作用于其后的两个组a ，b ，结果为。如果你的分子或分母不是单个字符，请使用{..}来分组，比如$\frac {a+c+1}{b+c+2}$表示。 第二种，使用\over来分隔一个组的前后两部分，如{a+1\over b+1}： 连分数 书写连分数表达式时，请使用\cfrac代替\frac或者\over两者效果对比如下： \frac 表示如下： 1$$x=a_0 + \frac &#123;1^2&#125;&#123;a_1 + \frac &#123;2^2&#125;&#123;a_2 + \frac &#123;3^2&#125;&#123;a_3 + \frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$ 显示如下： \cfrac 表示如下： 1$$x=a_0 + \cfrac &#123;1^2&#125;&#123;a_1 + \cfrac &#123;2^2&#125;&#123;a_2 + \cfrac &#123;3^2&#125;&#123;a_3 + \cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$ 显示如下： 根式 根式使用\sqrt 来表示。 如开4次方：$\sqrt[4]{\frac xy}$ ：。 开平方：$\sqrt {a+b}$：。 多行表达式分类表达式 定义函数的时候经常需要分情况给出表达式，使用\begin{cases}…\end{cases} 。其中： 使用\\ 来分类， 使用&amp; 指示需要对齐的位置， 使用\ +空格表示空格。 1234567$$f(n)\begin&#123;cases&#125;\cfrac n2, &amp;if\ n\ is\ even\\3n + 1, &amp;if\ n\ is\ odd\end&#123;cases&#125;$$ 表示: \begin{cases} \cfrac n2%2C %26if\ n\ is\ even\ 3n %2B 1%2C %26if\ n\ is\ odd \end{cases}) 1234567$$L(Y,f(X)) =\begin&#123;cases&#125;0, &amp; \text&#123;Y = f(X)&#125; \\1, &amp; \text&#123;Y $\neq$ f(X)&#125;\end&#123;cases&#125;$$ 表示:)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D) 如果想分类之间的垂直间隔变大，可以使用\\[2ex] 代替\\ 来分隔不同的情况。(3ex,4ex 也可以用，1ex 相当于原始距离）。如下所示： 1234567$$L(Y,f(X)) =\begin&#123;cases&#125;0, &amp; \text&#123;Y = f(X)&#125; \\[5ex]1, &amp; \text&#123;Y $\neq$ f(X)&#125;\end&#123;cases&#125;$$ 表示：)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D) 多行表达式 有时候需要将一行公式分多行进行显示。 12345678$$\begin&#123;equation&#125;\begin&#123;split&#125; a&amp;=b+c-d \\ &amp;\quad +e-f\\ &amp;=g+h\\ &amp; =i \end&#123;split&#125;\end&#123;equation&#125;$$ 表示： 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\\ 表示回车到下一行，&amp; 表示对齐的位置。 方程组 使用\begin{array}...\end{array} 与\left \{ 与\right. 配合表示方程组: 123456789$$\left \&#123; \begin&#123;array&#125;&#123;c&#125;a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3\end&#123;array&#125;\right.$$ 表示： 注意：通常MathJax通过内部策略自己管理公式内部的空间，因此a…b 与a…….b （.表示空格）都会显示为ab 。可以通过在ab 间加入\ ,增加些许间隙，\; 增加较宽的间隙，\quad 与\qquad 会增加更大的间隙。 特殊函数与符号三角函数 \snx$ : \arctanx : 比较运算符 小于(\lt )： 大于(\gt )： 小于等于(\le )： 大于等于(\ge )： 不等于(\ne ) : 可以在这些运算符前面加上\not ，如\not\lt : 集合关系与运算 并集(\cup ): 交集(\cap ): 差集(\setminus ): 子集(\subset ): 子集(\subseteq ): 非子集(\subsetneq ): 父集(\supset ): 属于(\in ): 不属于(\notin ): 空集(\emptyset ): 空(\varnothing ): 排列 \binom{n+1}{2k} : {n+1 \choose 2k} : 箭头 (\to ): (\rightarrow ): (\leftarrow ): (\Rightarrow ): (\Leftarrow ): (\mapsto ): 逻辑运算符 (\land ): (\lor ): (\lnot ): (\forall ): (\exists ): (\top ): (\bot ): (\vdash ): (\vDash ): 操作符 (\star ): (\ast ): (\oplus ): (\circ ): (\bullet ): 等于 (\approx ): (\sim ): (\equiv ): (\prec ): 范围 (\infty ): (\aleph_o ): (\nabla ): (\Im ): (\Re ): 模运算 (\pmod ): 如a \equiv b \pmod n : 点 (\ldots ): (\cdots ): (\cdot ): 其区别是点的位置不同，\ldots 位置稍低，\cdots 位置居中。 123456$$\begin&#123;equation&#125;a_1+a_2+\ldots+a_n \\ a_1+a_2+\cdots+a_n\end&#123;equation&#125;$$ 表示： 顶部符号 对于单字符，\hat x ： 多字符可以使用\widehat {xy} ： 类似的还有: (\overline x ): 矢量(\vec ): 向量(\overrightarrow {xy} ): (\dot x ): (\ddot x ): (\dot {\dot x} ): 表格 使用\begin{array}{列样式}…\end{array} 这样的形式来创建表格，列样式可以是clr 表示居中，左，右对齐，还可以使用| 表示一条竖线。表格中各行使用\\ 分隔，各列使用&amp; 分隔。使用\hline 在本行前加入一条直线。 例如: 123456789$$\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\2 &amp; -1 &amp; 189 &amp; -8 \\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\end&#123;array&#125;$$ 得到： 矩阵基本内容 使用\begin{matrix}…\end{matrix} 这样的形式来表示矩阵，在\begin 与\end 之间加入矩阵中的元素即可。矩阵的行之间使用\\ 分隔，列之间使用&amp; 分隔，例如: 1234567$$\begin&#123;matrix&#125;1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end&#123;matrix&#125;$$ 得到： 括号 如果要对矩阵加括号，可以像上文中提到的一样，使用\left 与\right 配合表示括号符号。也可以使用特殊的matrix 。即替换\begin{matrix}…\end{matrix} 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix 。 pmatrix$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$ : bmatrix$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$ : Bmatrix$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$ : vmatrix$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$ : Vmatrix$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$ : 元素省略 可以使用\cdots ：⋯，\ddots：⋱ ，\vdots：⋮ 来省略矩阵中的元素，如： 12345678$$\begin&#123;pmatrix&#125;1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\\end&#123;pmatrix&#125;$$ 表示： 增广矩阵 增广矩阵需要使用前面的表格中使用到的\begin{array} ... \end{array} 来实现。 1234567$$\left[ \begin&#123;array&#125; &#123;c c | c&#125; %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 &amp; 2 &amp; 3 \\\hline %插入横线，如果去掉\hline就是增广矩阵4 &amp; 5 &amp; 6\end&#123;array&#125; \right]$$ 显示为： 公式标记与引用 使用\tag{yourtag} 来标记公式，如果想在之后引用该公式，则还需要加上\label{yourlabel} 在\tag 之后，如$$a = x^2 - y^3 \tag{1}\label{1}$$ 显示为： 如果不需要被引用，只使用\tag{yourtag} ，$$x+y=z\tag{1.1}$$显示为： \tab{yourtab} 中的内容用于显示公式后面的标记。公式之间通过\label{} 设置的内容来引用。为了引用公式，可以使用\eqref{yourlabel} ，如$$a + y^3 \stackrel{\eqref{1}}= x^2$$ 显示为： 或者使用\ref{yourlabel} 不带括号引用，如$$a + y^3 \stackrel{\ref{111}}= x^2$$ 显示为: 字体黑板粗体字此字体经常用来表示代表实数、整数、有理数、复数的大写字母。$\mathbb ABCDEF$：$\Bbb ABCDEF$： 黑体字$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$ :$\mathbf abcdefghijklmnopqrstuvwxyz$ : 打印机字体$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$ : 参考文档 # 链接地址 文档名称 1 blog.csdn.net/dabokele/article/details/79577072 Mathjax公式教程 2 blog.csdn.net/ethmery/article/details/50670297 基本数学公式语法 3 blog.csdn.net/lilongsy/article/details/79378620 常用数学符号的LaTeX表示方法 4 www.mathjax.org Beautiful math in all browsers]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora 设置图床]]></title>
    <url>%2F2021%2F01%2F29%2FTools%2FTypora%20%E8%87%AA%E5%8A%A8%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。123456789101112&#123; "picBed": &#123; "uploader": "github", "github": &#123; "repo": "ximan/static_file", // 仓库名，格式时 username/reponame "token": "xxxxxxxx", // github token "path": "images/", // 自定义存储路径 如： image/ "branch": "master" // 分支名，默认是 master &#125; &#125;, "picgoPlugins": &#123;&#125;&#125; 首先您要有一个 Github 账号 新建一个仓库 生成一个 token 用于 Picgo 操作您的仓库， 访问 https://github.com/settings/tokens 然后点击 Generate new token 勾选 repo 并记录 token 配置 Picgo， 如上 JSON Typora 设置如下图 下载或更新：大约 18m 的 Picgo 插件，点击安装即可 点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入 点击验证图片上传选项，验证 github 是否连通 更多配置我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 Typora 文件配置 和 图片上传工具配置]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程知识点]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[什么是协程 轻量级的线程，并不完全是线程 可以顺序的写异步代码， 降低异步编程带来的负担 更高效，多个协程可以公用一个线程。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的 运行在协程中的可中断的方法不会阻塞当前线程 可中断的方法（suspending functions） 可中断的方法有能力中断协程的执行， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果 12val user = suspend &#123; userService.doLogin(username, password)&#125;val currentFriends = suspend &#123; userService.requestCurrentFriends(user) &#125; 可中断方法可以运行在相同或不同的线程，取决于使用方式* 可中断的方法只能运行在协程中或其它可中断的方法中 1234suspend fun suspendingFunction(): Int &#123; // do long things return 0&#125; 协程上下文（Coroutine Context）协程上下文是一系列规则和配置的集合，它决定了协程的运行方式， 其内部结构是一个列表容器 withContext在协程内部，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。 1234suspend fun suspendLogin(username: String, password: String):String = withContext(Dispatchers.Main) &#123; userService.doLogin(username, password)&#125; 调度器(dispatcher) Default： 未指定 dispathcer 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程 IO：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。 UnConfined： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议 Main: 这个是 UI 相关的 协程构造器（Coroutine Builders）根据实际情况，我们可以选择不同的协程构造器，也可以自己创建 runBlocking这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。 runBolcking 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 runBlocking 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。 1234fun testSuspendedFunction() = runBlocking &#123; val res = suspendingTask1() assertEquals(0, res)&#125; 除了这个场景意外，几乎永不到 launch这个构造器狠重要，因为它可以 很轻易的创建一个协程，经常使用。 launch 不会阻塞当前线程（前期是我们使用了合适的 dispatcher） 这个构造器需要一个作用域（scope） 123GlobalScope.launch(Dispatchers.Main)&#123; ....&#125; launch 方法返回一个 Job ，Job 继承了协程上下文(CoroutineContext) Job 提供了很多有用的方法，一个 Job 可以有一个父 Job，父 Job 可以控制子 Job job.join这个方法可以中断与当前 Job 关联的协程，直到所有子 Job 执行完成。协程内所有可中断的方法与当前 Job 关联。直到子 Job 全部执行完成，与当前 Job 关联的协程才能继续执行。 12345678val job = GlobalScope.launch(Dispatchers.Main) &#123; doCoroutineTask() val res1 = suspendingTask1() val res2 = suspendingTask2() process(res1, res2)&#125;job.join() job.join() 是一个可中断的方法，所以它应该在协程内部被调用。 job.cancel()取消所有与其关联的子 Job ，加入 suspendingTask1() 正在执行的时候 Job 调用了取消，这个时候 res1 不会再返回， 而且 suspendingTask2() 也不会再执行 12345678val job = GlobalScope.launch(Dispatchers.Main) &#123; doCoroutineTask() val res1 = suspendingTask1() val res2 = suspendingTask2() process(res1, res2)&#125;job.cancel() job.cancel 是一个普通方法，不必运行再协程内部 asyncasync 允许并行地运行多个子线程任务， 它不是一个可中断方法，当调用 async 启动子协程的同事，后面的代码也会立即执行。 async 通常需要运行再另外一个协程内部，它会返回一个特殊的 Job -&gt; Deferred DeferredDeferred 有一个 await() 函数，它是一个可终端的方法，当需要获取 async 的结果是，需要调用 await() 方法等待。调用后，会中断当前线程，直到其返回结果 1234567GlobalScope.launch(Dispatchers.Main) &#123; val user = withContext(Dispathcers.IO) &#123;userService.doLogin(username, password)&#125; val currendFriend = async(Dispatchers.IO) &#123;userService.requestCurrentFriends(user) &#125; val suggestedFriends = async(Dispatchers.IO) &#123; userService.requestSuggestedFriends(user)&#125; val finalUser = user.copy(friends = currenFriends.await() + suggestedFriends.await())&#125; 作用域(Scope)GlobalScope全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用 123GlobalScope.launch(Dispatchers.Main) &#123; &#125; 是否伴随 APP 整个生命周期 没有界面和组件绑定 自定义协程作用域任何类都可以继承 CoroutineScope 作为一个作用域，唯一需要做的事儿就是去重写 coroutineContext 属性 需要先明白两个概念 dispathcer 和 Job dispathcer： 用于指定协程默认使用的 dispatcher Job: 用在任何需要的时候取消协程 123456class MainActivity:AppCompatActivity(), CoroutineScope &#123; override val coroutineContext: CoroutineContext get() = Dispatchers.Main + job private lateinit var job: Job&#125;]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程调度器]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[调度器本质上就是协程上下文的实现 调度器的作用是用来实现线程的切换 过度使用线程，同样会造成线程安全问题 suspendMain 是有一个空的上下文，因此不会产生线程的调度 系统提供的调度器实现，Default, Main, Unconfined, IO 协程上下文（CoroutineContext）调度器本质上就是协程上下文的实现 12345678910111213public interface CoroutineContext &#123; public operator fun &lt;E: Element&gt; get(key: Key&lt;E&gt;):E? public fun &lt;R&gt; fold(initial: R, operation:(R, Element) -&gt; R):R public operator fun plus(context: CoroutineContext): CorountineContext = ... public fun minusKey(key: Key&lt;*&gt;): CoroutineContext public interface Key&lt;E: Element&gt; public interface Element : CoroutineContext &#123; public val key: Key&lt;*&gt; &#125; ...&#125; 本质上，上下文就是一个以 key 为索引的 List CoroutineContext 作为一个集合，它的元素就是源码中看到的 Element ， 每一个 Element 都有一个 Key ，因此它可以作为元素出现，同时它也是 CoroutineContext 的子接口，因此也可以作为集合出现。 12345internal class CombinedContext (private val left: CoroutineContext,private val element: Element) : CoroutineContext, Serializable &#123; &#125; CombinedContext 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的coroutineContext 大多是这个 CombinedContext 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 key 来查找 1234567suspend fun main() &#123; GlobalScope.launch&#123; println(coroutineContext[Job]) // “coroutine#1: StandaloneCoroutine&#123;Active&#125;@1ff5025 &#125; println(coroutineContext[Job]) // null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例&#125; 这里的Job 实际上是对它的 companion object 的引用 123456public interface Job: CoroutineContext.Element &#123; /** * Key for [job] instance in the coroutine context. */ public companion object Key: CoroutineContext.Key&lt;Job&gt; &#123;&#125;&#125; 仿照Thread.currentThread() 来获取当前 Job 的方法 123456789suspend inline fun Job.Key.currentJob() = coroutineContext[Job]suspend fun coroutineJob() &#123; GlobalScope.launch &#123; log(Job.currentJob()) &#125; log(Job.currentJob())&#125; 获取协程名字 1GlobalScope.launch(CoroutineName("Hello")) &#123;&#125; 如果有多个上下文，需要添加 + 就可以了 1GlobalScope.launch(Dispatcher.Main + CoroutineName("Hello")) &#123;&#125; 协程拦截器12345public interface ContinuationInterception: CoroutineContext.Element &#123; companion object Key: CoroutineContext.Key&lt;ContinuationInterceptor&gt; public fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;&#125; 拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面， 协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的Continuation，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。 我们可以自己定义一个拦截器放到我们协程的上下问中。 12345678910111213class MyContinuationInterceptor: ContinuationInterceptor &#123; override val key = ContinuationInterceptor override fun &lt;T&gt; interceptContinuation(continuation:Continuation&lt;T&gt;) = MyContinuation(continuation)&#125;class MyCOntinuation&lt;T&gt; (val continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123; override val context = continuation.context override fun resumeWith(result:Result&lt;T&gt;) &#123; log("&lt;MyContinuation&gt;$result") continuation.resumeWith(result) &#125;&#125; 123456789101112131415suspend fun main()&#123; GlobalScope.launch(MyContinuationInterceptor()) &#123; log(1) val job = async &#123; log(2) delay(1000) log(3) "Hello" &#125; log(4) val result = job.await() log("5.$result") &#125;.join() log(6)&#125; 通过 launch 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用async 启动了一个协程，async 和 launch从功能上是同等类型的函数，不同之处在于 async 启动的 Job 也就是实际上的 Deferred 可以有返回结果。可以通过 await 方法获取。 12345678910[main] &lt;MyContinuation&gt; Success(kotlin.Unit)[main] 1[main] &lt;MyContinuation&gt; Success(kotlin.Unit)[main] 2[main] 4[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit)[kotlinx.coroutines.DefaultExecutor] 3[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello)[kotlinx.coroutines.DefaultExecutor] 5.Hello[kotlinx.coroutines.DefaultExecutor] 6 首先，所有协程启动的时候，都会有一次Continuation.resumeWith 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。 其次 delay 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。 最后，正是我们需要的结果。 而协程真正切换线程的逻辑源自于 delay 在 JVM 上，delay 实际上是一个 ScheduledExcecutor 里面添加了一个延时任务，因此会发生线程切换 调度器123public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123; public abstract fun dispatch(context: CoroutineContext, block: Runnable)&#125; 调度器本身也是协程上下文的子类，同时实现了拦截器的接口， dispatch 方法会在拦截器的方法 interceptContinuation 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类AbstracoroutineContextElement 就可以 Default: 线程池 Main： UI 线程 Unconfined：直接执行 IO：线程池 UI 相关程序Kotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI 1234567getUserBtn.setOnClickListener &#123; getUser&#123;user-&gt; &#123; handler.post&#123; userNameView.text = user.name &#125; &#125;&#125;&#125; 12345typealias Callback = (User) -&gt; Unitfun getUser(callback: Callback) &#123; &#125; 因为 getUser 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 handler.post 切换到 UI 线程。 过度到协程的写法； 123456789101112suspend fun getUserCoroutine()= suspendCoroutine&lt;User&gt; &#123; continuation -&gt; getUser &#123; continuation.resume(it) &#125;&#125;getUserBtn.setOnClickListener &#123; GlobalScope.launch(Dispathcer.Main) &#123; userNameVite.text = getUserCoroutine().name &#125;&#125; suspendCoroutine 它运行在协程当中，并且帮助我们获取当前协程的 Continuation 实例，也就是拿到回调，方柏霓我们调用它的 resume 和 resumeWithException 来返回结果或者抛出异常 Dispatchers.Main 123456789101112131415internal object MainDispatcherLoader &#123; @JvmField val dispatcher:MainCoroutineDispatcher = loadMainDispatcher() private fun loadMainDispatcher() :MainCoroutineDispatcher &#123; return try &#123; val factories = MainDispatcherFactory::class.java.let &#123;cle -&gt; ServiceLoader.load(clz, clz.classLoader).toList() &#125; factories.maxBy&#123;it.loadPriority&#125;?.tryCreateDispatcher(factories) ?: MissingMainCoroutineDispatcher(null) &#125; catch (e: Throwable) &#123; MissingMainCoroutineDispatcher(e) &#125; &#125;&#125; 在 Android 当中，协程框架通过注册 AndroidDispatcherFactory 是的 Main 最终被赋值为 HandlerDispatcher 的实例。 线程安全问题]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[协程12345678fun main() &#123; GlobalScope.launch &#123;// 后台启动一个新的协程并继续， launch 协程的构建器 delay(1000L) // 非阻塞的等待1s， println("World!") // 延时后，输出 &#125; println("Hello") // 协程已再等待时，主线程还在继续 Thread.sleep(2000L) // 阻塞主线程 2s 保证， JVM 存活&#125; 协程是轻量级的线程。 CoroutineScope 通常与 launch 协程构建器一起启动。 GlobalScope： 意味着新协程的生命周期与应用程序的生命周期一致 delay 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。 桥接阻塞与非阻塞的世界使用runBlocking 协程构建器来阻塞，使用非阻塞函数delay 方便，不易与 Thread.sleep() 阻塞函数混淆 12345678910fun main() &#123; GlobalScope.launch &#123; // delay(1000L) println("world!") &#125; println("hello ") runBlocking&#123; // 这个表达式阻塞了主线程 delay(2000L) &#125;&#125; 上例，只使用了非阻塞函数 delay, 调用 runBlocking 的主线程会一直阻塞，直到 runBlocking 内部的协程执行完毕 还可以使用 runBlocking 包裹 main 函数来执行： 12345678fun main() = runBlocking&lt;Unit&gt; &#123; GlobalScope.launch &#123; delay(1000L) println("world") &#125; println("Hello ") delay(2000L)&#125; runBlicking&lt;Unit&gt; {} 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型 等待一个作业延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束 123456val job = GlobalScope.launch &#123; // 启动一个新协程并持有这个作业的引用 delay(1000L) println("world")&#125;println("hello ")job.join()// 等待直到子协程执行结束 这里主协程与后台作业的持续时间没有任何关系了。 结构化的并发当我们使用 GlobalScope.launch 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 join 很容易出错 结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 GlobalScope 中启动。 我们使用runBlocking 协程构建器将 main 函数转化为协程，包括 runBlocking 在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 join 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。 1234567fun main() = runBlocking &#123; // this: CoroutineScope launch &#123; // 在 runBlocking 作用域中启动一个新的协程 delay(1000L) println("world") &#125; println("Hello, ")&#125; 作用域构建除了由不同的构建器提供协程作用域之外，还可以使用 coroutineScope 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束 runBlocking 与 coroutineScope 可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 runBlocking 方法会阻塞当前线程来等待，而 coroutineScope 只会挂起，会释放底层线程用于其他用途。 12345678910111213141516fun main = runBlocking &#123; // coroutine scope launch &#123; delay(200L) println("Task from runBlocking") &#125; coroutineScope &#123;// 创建一个作用域协程 launch &#123; delay(500L) println("Task from nested launch") &#125; delay(100L) println("Task from coroutine scope") // 这一行会在内嵌 launch 之前输出 &#125; println("Coroutine scope is over") // 这一行在内嵌 launch 执行完毕后输出&#125; 提取函数重构当将 launch{} 内部代码块提取到独立的函数体中时，需要 suspend 修饰新函数。这是一个挂起函数。 123456789fun main() = runBlocking &#123; launch &#123;doWorld()&#125; println("hello ")&#125;suspend fun doWorld() &#123; delay(1000L) println("world!")&#125; 协程很轻量12345678fun main = runBlocking &#123; repeat(100_000) &#123; launch &#123; delay(5000L) println(".") &#125; &#125;&#125; 10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况 全局协程像守护线程1234567GlobalScope.launch &#123; repeat(1000) &#123; i -&gt; println("I`m sleeping $i ...") delay(500L) &#125;&#125;delay(1399L)]]></content>
  </entry>
  <entry>
    <title><![CDATA[协程异常处理]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[协程内部异常处理流程： launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM）上的CoroutineExceptionHandler 处理， async 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 await 时抛出 异常在作用域内传播 当协程出现异常时，会根据当前作用域触发异常传递 GlobalScope 会创建一个独立的作用域，自成一派 coroutineScope 当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，一损俱损 supervisorScope 子协程的异常不会向上传递， 自作自受 join 和 await join 只关心是否执行完， await 则关心运行的结果 因此 join 在协程出现异常时也不会抛出该异常，而 await 则会直接抛出异常； Note: 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 join 时，尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，就会抛出 取消异常 当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它 12345678910111213141516171819202122232425interface Callback&lt;T&gt; &#123; fun onSuccess(value: T) fun onError(t: Throwable)&#125;fun getUser(callback: Callback)&#123;&#125;suspend fun getUserCoroutine() = suspendCoroutine&lt;User&gt; &#123;continuation-&gt; getUser(object: Callback&lt;User&gt; &#123; override fun onSuccess(user: User) &#123; continuation.resume(resume) &#125; override fun onError(e: Throwable) &#123; continuation.resumeWithException(t) &#125; &#125;) &#125;GlobalScope.launch(Dispatchers.Main) &#123; try &#123; userNameView.text = getUserCoroutine().name &#125; catch(e:Exception) &#123; userNameView.text = "Get user error: $e" &#125;&#125; 全局异常处理线程也好，RxJava 也好，都会有全局处理异常的方式 1234567fun main()&#123; Thread.setDefaultUncaughtExceptionHandler&#123;t: Thread, e: Throwable -&gt; // handle exception here println("Thread '$&#123;t.name&#125;' throws an exception with mesage '$&#123;e.message&#125;'") &#125; throw ArithmeticException("Hey!")&#125; RxJava 设置全局异常捕获 123RxJavaPlugins.setErrorHandler(e-&gt; &#123; println("Throws an exception with message '$&#123;e.message&#125;'")&#125;) 协程也可以设置，类似于通过 Thread.setUnCaughtExceptionHandler 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 CoroutineExceptionHandler 这样协程内未捕获的异常既可以通过它来捕获 123456789private suspend fun main()&#123; val exceptionHandler = CoroutineExceptionHandler&#123; coroutineContext, throwable -&gt; println("Throws an exception with message: '$&#123;throwable.message&#125;'") &#125; GlobalScope.launch(exceptionHandler) &#123; throw ArithemticException("Hey!") &#125;.join()&#125; ConroutineExceptionHandler 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现 1234567class GlobalCoroutineExceptionHandler: CoroutineExceptionHandler &#123; override val key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptinHandler override fun handleException(context, CoroutineContext, exception: Throwable) &#123; println("coroutine exceptino: $exception") &#125;&#125; 然后在 classpath 中创建 META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler 的全类名，文件内容就写我们的实现类的全名 1com.***.***.exceptions.GlobalCoroutineExceptionHandler 异常传播协程作用域当我们启动协程的时候，一直都在用 GlobalScope ，意味着这是要给独立的顶级协程作用域，此外还有coroutineScope{} 及 supervisorScope{} 通过 GlobalScope 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 GlobalScope 启动的协程自成一派 coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出， 一损俱损 ，同时这也是协程内部再启动子协程的默认作用域 supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着子协程出现了异常并不会影响父协程以及其他兄弟协程，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，自作自受。supervisorScope 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，即supervosorScope 只作用其直接子协程 123456789101112131415161718192021222324252627282930313233suspend fun main ()&#123; log(1) try &#123; coroutineScope &#123; log(2) launch &#123; log(3) launch &#123; log(4) delay(100) throw ArithmeticException("Hello") &#125; log(5) &#125; log(6) val job = launch &#123; log(7) delay(1000) &#125; try &#123; log(8) job.join() log(9) &#125; catch (e: Exception) &#123; log("10 $e") &#125; &#125; log(11) &#125; catch (e: Exception) &#123; log("12 $e") &#125; log(13)&#125; 12345678910111263548710 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine&#123;Cancelling&#125;@695fd68b12 java.lang.ArithmeticException: Hello13 从上面的程序和结果我们可以看出，10 这里，我们调用 join 收到了一个取消异常，在协程当中支持取消的操作的 suspend 函数在取消是抛出一个 CancellationException。 协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 job.join() 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。 我们将 coroutineScope 换成 supervisorScope ，其他不变 12345678910111213141516171812635487Exception in thread "DefaultDispatcher-worker-3" java.lang.ArithmeticException: Hello at com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594) at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)91113 我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。 我们为内部协程增加啊一个 CoroutineExceptionHandler 就可以证明我们一个结论 12val exceptionHandler = CoroutineExceptioHandler &#123;coroutineContext, throwable -&gt; log("$&#123;coroutineContext[CoroutineName]&#125; $throwable") &#125; 123456789101112131415161718192021222324252627282930313233suspend fun main ()&#123; log(1) try &#123; superisorScope &#123; log(2) launch(exceptionHandler + CoroutineName("2")) &#123; log(3) launch (exceptionHandler + CoroutineName("3"))&#123; log(4) delay(100) throw ArithmeticException("Hello") &#125; log(5) &#125; log(6) val job = launch &#123; log(7) delay(1000) &#125; try &#123; log(8) job.join() log(9) &#125; catch (e: Exception) &#123; log("10 $e") &#125; &#125; log(11) &#125; catch (e: Exception) &#123; log("12 $e") &#125; log(13)&#125; 12345678910111212635487CoroutineName(2) java.lang.ArithmeticException: Hello91113 我们看到，触发CoroutineExceptionHandler 的是协程 2。 如何使用 scope 对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope 对于已经由协程作用域的情况，直接用协程启动器启动 对于明确要求子协程之间互相独立不干扰时，使用 supervisorScope 对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job 作用域等概念的支撑，例如 suspernd main ，有限考虑通过 coroutineScope 创建作用域 join 和 await前面的例子一直是用 launch 启动协程常用的还有 async, actor produce 其中 actor 和 launch 的行为类似，在未捕获异常出现以后，会抛出。而 async 和 produce 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。 什么是消费结果两组协程启动器，我们可以分别认为是 消费者 和 生产者 消费者异常立即抛出；生产者只有结果异常时抛出 async 和 await1234567891011suspend fun main() &#123; val deferred = GlobalScope.async&lt;Int&gt; &#123; throw ArithmeticException() &#125; try &#123; val value = deferred.await() log("1. $value") &#125; catch (e: Exception) &#123; log("2. $e") &#125;&#125; 当我们调用 await 时，期望 deferred 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们 12. java.lang.ArithmeticException joinjoin 则和 await 不同， join 只关心是否执行完，至于为什么完成，它不关心。将上面的 await 替换成 join 后 11. kotlin.Unit 异常信息被吞掉了，用 launch 替换 async ，join 处仍然不会有任何响应。 launch 中未捕获的异常与 aysync 的处理方式不同， launch 会直接抛出异常给父协程，如果没有父协程或者处于 supervisorScope 中父协程不响应，那么就会交给上下文中执行的 CoroutineExceptionHandler 处理，如果没有指定，那就传给全局的 CoroutineExcetionHandler 等等。而 async 则要等 await 来消费]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程挂起]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E6%8C%82%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[Delay 线程: Thread.sleep() sleep 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行 协程: delay delay 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 delay 也可以要让协程休眠的一种手段 123456public suspend fun delay(timeMillis: Long) &#123; if(timeMillis &lt;= 0) return return suspendCancellableCoroutine sc@ &#123;cont: CancellableContinuation&lt;Unit&gt; -&gt; cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont) &#125;&#125; cont.context.delay.scheduleResumeAfterDelay 这个操作,可以类比 Android 的 handler.postDealy ,本质上就是设置了一个延时回调,时间一到就调用 resume 方法让协程继续执行 SuspendCancellableCoroutine123456789101112public final override suspend fun join() &#123; if (!joinInternal()) &#123; // fast-path no wait coroutineContext.checkCompletion() return // do not suspend &#125; return joinSuspend() // slow-path wait&#125;private suspend fun joinSuspend() = suspendCancellableCoroutine&lt;Unit&gt; &#123; cont -&gt; // We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))&#125; Job.join() 这个方法会先检查调用者 Job 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 joinSuspend 。这里只注册了一个完成时的回调 12345public suspend inline fun &lt;T&gt; suspendCancellableCoroutine(crossinline block: (CancellableContinuation&lt;T&gt;)-&gt; Unit):T = suspendCoroutineUninterceptedOrReturn&#123; uCont-&gt; val cancelable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE) block(cancellable) cancellable.getResult()&#125; suspendCoroutineUninterceptedOrReturn 这个方法帮助我们拿到 Continuation 实例，suspendCoroutineUninterceptedOrReturn 的返回值类型是 T, 而传入的 lambda 的返回值类型是 Any?,也就是 cancellable.getResult() 的类型。 1234567internal fun getResult() :Any? &#123; if(trySuspend()) return COROUTINE_SUSPEND // 触发挂起逻辑 if(state is CompletedExceptionally) // 异常立即抛出 throw recoverStackTrce(state.cause, this) return getSuccessfulResult(state) // 正常结果立即返回&#125; trySuspend() 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。 然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。 123public vla COROUTINE_SUSPEND: Any get() = CoroutineSingletons.COROUTINE_SUSPENDinternal enum class CoroutineSingletons &#123;CONTINE_SUSPEND, UNDECIDED, RESUMED&#125; 而 trySuspend() 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。 深入挂起操作真正的挂起是什么？ 1234567891011suspend fun hello() = suspendCoroutineUninterceptedOrReturn&lt;Int&gt; &#123; continuation -&gt; log(1) thread &#123; Thread.sleep(1000) log(2) continuation.resume(1024) &#125; log(3) CONTROUTINE_SUSPEND&#125; 上面这一个 suspend 函数，在 suspendCoroutineUninterceptedOrReturn 当中直接返回这个 COROUTINE_SUSPEND 协程的状态转移123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ContinuationImpl implements Continuation&lt;Object&gt; &#123; private int label = 0; private final Continuation&lt;Unit&gt; completion; public ContinuationImpl(Continuation&lt;Unit&gt; completion) &#123; this.completion = completion; &#125; @Override public CoroutineContext getContext() &#123; return EmptyCoroutineContext.INSTANCE; &#125; @Override public void resumeWith(@NotNull Object o) &#123; try &#123; Object resume = o; switch(label) &#123; case 0: LogKt.log(1) result = SuspendFunctionsKt.returnSuspended(this); label++; if(isSuspended(result)) return; case 1: LogKt.log(result); LogKt.log(2) result = DelayKt.delay(1000, this); label++; if(isSuspended(result)) return; case 2: LogKt.log(3) result = SuspendedFunctionsKt.returnImmediately(this); label++; if(isSuspended(result)) return; case 3: LogKt.log(result); LogKt.log(4) &#125; &#125; completion.resumeWith(Unit.INSTACNE); &#125; catch (Exception e)&#123; completion.resumeWith(e) &#125;&#125;private boolean isSuspended(Object result) &#123; return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();&#125; 实际上，在 Kotlin 的标准库中，有一个 ContinuationImpl 的累，只不过，它的 resumeWith 最终调用到了 invokeSuspend 而这个 invokeSuspend 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 launch 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 SuspendLambda 的子类，而它又是 ContinuationImpl 的子类。 仿照 runSuspend 类，我们实现一个 completion 12345678910111213141516171819202122232425262728public class RunSuspend implements Continuation&lt;Unit&gt; &#123; private Object result; @Override public CoroutineContext getContext()&#123; return EmptyCoroutineContext.INSTANCE; &#125; @Override public void resumeWith(@NotNull Object result) &#123; synchronized(this) &#123; this.result = result; notifyAll();// 协程已结束，通知下面的 wait() 方法停止阻塞 &#125; &#125; public void await() throws Throwable &#123; synchronized(this) &#123; while(true) &#123; Object result = this.result; if(result == null) wait();// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回 else if(result instanceof Throwable) &#123; throw (Throwable) result; &#125; else return; &#125; &#125; &#125;&#125; 123456public static void main(String...args) throws Throwable &#123; RunSuspend runSuspend = new RunSuspend(); ContinationImpl table = new ContinuationImpl(runSuspend); table.resumeWith(Unit.INSTANCE); runSuspend.await();&#125; 这种写法，简直就是 suspend main 的真是面目。 completion 传入的 runSuspend 实例的 resumeWith 实际上是在 ContinuationImpl 的 resumeWith 的最后才被调用，因为它的 await() 一旦进入阻塞状态，直到 ContinuationImpl 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程启动]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[协程-启动启动模式 DEFAULT： 立即执行 LAZY： 需要时执行 ATOMIC： 立即执行，但开始前不会被取消 UNDISPATCHED： 立即执行，直到第一个 suspend 挂起 Thread1234567val thread = object : Thread() &#123; override fun run()&#123; super.run() //do something &#125;&#125;thread.start() 上面是线程的启动方法，通常还会忘记去写 start() ，那再 kotlin 中 123val myThread = thread(start = true) &#123; //do you wang&#125; start() 方法是默认被开启自动会执行的，为我们省去了很多麻煩 协程启动123GlobalScope.launch &#123; // do you want&#125; 启动模式12345678public enum class CoroutineStart &#123; DEFAULT, LAZY, @ExperimentalCoroutinesApi ATOMIC， @ExperimentalCoroutinesApi UNDISPATCHED；&#125; 模式 功能 DEFAULT 立即执行协程体 ATOMIC 立即执行协程体，但在开始运行之前无法取消 UNDISPATCHED 立即在当前线程执行协程体，直到第一个 suspend 调用 LAZY 只有在需要的情况下运行 DEFAULT四种启动模式中，常用的其实是DEFAULT 和 LAZY DEFAULT 是饿汉式启动，launch 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。 123456789suspend fun main() &#123; log(1) val job = GlobalScope.launch&#123; log(2) &#125; log(3) job.join() log(4)&#125; 采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是 1234[main] 1[main] 3[DefaultDispatcher-worker-1] 2[main] 4 它取决于 CPU 对于当前线程和后台线程的调度顺序 LAZYLAZY 是懒汉式启动，launch 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。launch 后会返回一个 job 实例，因此我们可以通过 job 来实现 调用 Job.start() 主动触发协程的调度 调用 Job.join() 隐式的触发协程的调度 1234567log(1)val job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123; log(2)&#125;log(3)job.start()log(4) 其输出结果可能为 1234[main] 1[main] 3[main] 4[DefaultDispatcher-worker-1] 2 运气好话，2 也可能在 4 的前面，而对于 join() 1234567log(1)val job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123; log(2)&#125;log(3)job.join()log(4) 因为要等待协程执行完毕，因此数据结果一定是 1234[main] 1[main] 3[DefaultDispatcher-worker-1] 2[main] 4 ATOMICATOMIC 只有涉及到 cancel 的时候才有意义， cancel 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 cancel 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等 123456log(1)val job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123; log(2)&#125;job.cancel()log(3) 我们创建写成后立即 cancel 但由于 ATOMIC 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说 对应的，如果是 DEFAULT 模式，在第一次调度该协程时，如果 cancel 就已经调用，那么协程就会被直接 cancel 而不会有任何调度。 需要注意， cancel 调用一定会将 job 的状态设置为 cancelling, 只不过 ATOMIC 模式的协程在启动时无视了这一状态。 123456789log(1)val job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123; log(2) delay(1000) log(3)&#125;job.cancel()log(4)job.join() 2 和 3 之间加了一个 delay ，delay 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 ATOMIC 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 delay 是一个 suspend 函数，此时程序迎来了第一个挂起点，恰好 delay 是支持 cancel 的，因此后面的 3 将不会打印。 UNDISPATCHED协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 ATOMIC 很像，不同在于 DISPATCHED 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器 123456789log(1)val job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123; log(2) delay(1000) log(3)&#125;log(4)job.join()log(5)]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程取消]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E5%8F%96%E6%B6%88%2F</url>
    <content type="text"><![CDATA[协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样 线程的中断当我们执行一个任务时,很快就后悔了,怎么办? 12345678val thread = thread &#123; try &#123; Thread.sleep(1000) &#125; catch(e :Exception) &#123; log("interrupted, do cleaning stuff") &#125;&#125;thread.interrupt() 当线程被标记为中断状态,就会抛出 InterruptedException ,我们可以进行捕获做资源清理. 所以,所谓的协作式任务种植,协程的取消也是cancel机制的设计思路. 协程的取消123456789101112fun main()= runBlocking &#123; val job1 = launch&#123; log(1) delay(1000) log(2) &#125; delay(100) log(3) job1.cancel() log(4)&#125; delay 与线程中的 sleep 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms 后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 delay 还没有回调的时候,协程就被取消了,因为 delay 可以影响取消,因此 delay 后面的代码就不会再次调度,直接抛出一个 CancellationException 完善前面的一个例子 1234567891011suspend fun getUserCoroutine() = suspendCoroutine&lt;User&gt; &#123;continuation -&gt; getUser(object: Callback&lt;User&gt;&#123; override fun onSuccess(value: String) &#123; continuation.resume(value) &#125; override fun onFailed(e:Throwable) &#123; continuation.resumeWithException(e) &#125; &#125;)&#125; 加上取消逻辑 123456789101112131415161718192021222324suspend fun getUserCoroutine() = suspendCancellableCoroutine&lt;User&gt; &#123; continuation-&gt; val call = OkHttpClient().newCall(...) continuation.invokeOnCancellation&#123; log() call.cancel() &#125; call.enqueue(object : okhttp3.Callback&#123; override fun onFailure(call: Call, e: Exception) &#123; log("onFailure: $e") continuation.resumeWithException(e) &#125; override fun onResponse(call: Call, response: Response) &#123; log("onResponse: $&#123;response.code()&#125;") response.body()?.let &#123; try &#123; continuation.resume(User.from(it.string())) &#125; catch(e: Exception) &#123; continuation.resumeWithException(e) &#125; &#125; ?: continuation.resumeWithException(NullPointerException("ResponseBody is null")) &#125; &#125;)&#125; suspendCancellableCoroutine 是为了让我们的挂起函数支持协程的取消.该方法将获取到的Continuation 包装成了一个CacncellableContinuation 通过调用 invokeOnCancellation 方法可以设置一个取消时间的回调,一旦被调用,意味着 getUserCoroutine 调用所在的协程将被取消,我们也应该相应的做出取消操作. 1234567891011val job1 = launch &#123; log(1) val user = getUserCoroutine() log(user) log(2)&#125;delayt(10)log(3)job1.cancel()log(4) 1234513invokeOnCancellation: cancel the request.4onFilure: java.io.IOException: Canceled 取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用continuation.resume continuation.resumeWithException continuation.resumtWith 都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 continuation.resumeWithException(e) 不会有任何副作用.]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程入门]]></title>
    <url>%2F2021%2F01%2F29%2FKotlin%2F%E5%8D%8F%E7%A8%8B%2F%E5%8D%8F%E7%A8%8B-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。 线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着 协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。 协程的三要素：上下文、启动模式、协程体 多个协程可以共用一个线程 协程的本质 协程的挂起函数本质上就是一个回调，回调类型就是Continuation 协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移 通过 Retrofit 请求通过 Retrofit 发送一个网络请求 123456interface GitHubServiceApi &#123; @GET("users/&#123;login&#125;") fun getUser(@Path("login") login:String):Call&lt;User&gt;&#125;data class User(val id:String, val name:String, val url:String) Retrofit 初始化如下 1234567val githubServiceApi by lazy &#123; val retorfit = retrofit2.Retrofit.Builder() .baseUrl("https//api.github.com") .addConverterFacetory(GsonConverterFactory.create()) .build() retrofit.create(GitHUbServiceApi::class.java)&#125; 发起网络请求 123456789101112githubServiceApi.getUser("small").enqueue(object: Callback&lt;User&gt; &#123; override fun onFailure(call: Call&lt;User&gt;, t: Throwable) &#123; handler.post&#123;showError(t)&#125; &#125; override fun onSuccess(call: Call&lt;User&gt;, response: Response&lt;User&gt;) &#123; handler.post&#123; response.body()?.let(::showUser) ?: showError(NullPointerException()) &#125; &#125;&#125;) 改造为携程对于 Retrofit 改造为协程的方式有两种，分别通过 CallAdapter 和 suspend 函数 CallAdapter该方法的本质是让接口的方法返回一个协程的 Job 1234interface GitHubServiceApi &#123; @GET("users/&#123;login&#125;") fun getUser(@Path("login")login:String):Deferred&lt;User&gt;&#125; Deferred 是 Job 的子接口 同时需要为 Retrofit 添加对 Deferred 的支持 1implementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2' 对构造 Retorfit 的实例添加 12345678val githubServiceApi by lazy &#123; val retorfit = retrofit2.Retrofit.Builder() .baseUrl("https//api.github.com") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(CoroutineCallAdapterFactroy()) .build() retrofit.create(GitHubServiceApi::class.java)&#125; 通过上面的修改，那么我们的请求就可以这样写 1234567GlobalScope.launch(Dispatchers.Main) &#123; try&#123; showUser(githubServiceApi.getUser("small").await()) &#125; catch (e: Exception) &#123; shwoError(e) &#125;&#125; Note: 我们首先通过 launch 启动了一个协程，这类似于我们启动一个线程，launch 的参数有三个: 协程上下文、协程启动模式、协程体 12345public fun CorountineScope.launch( context:CorountineContext = EmptyCouroutineContext,// 上下文 start: CoroutineStart = CoroutineStart.DEFGAULT, // 启动模式 block: suspend CorountineScope.() -&gt; UNit // 协程体) :Job 启动模式 不是一个复杂的概念，默认直接俄允许调度执行 上下文可以有很多作用，包括携带参数、拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，Dispatchers.Main 就是一个官方提供的上下文，它可以确保launch 启动的协程体运行在 UI 线程当中（除非你自己再 launch 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程） 换句话说，在例子当中的整个 launch 内部，你看到的代码都是运行在UI线程中的，尽管 getUser 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 getUser 返回了要给 Deferred 类型，他的 await 方法会返回一个 User 对象，意味着 await 需要等待请求结果返回才可以继续执行，那么await 不会阻塞 UI 线程嘛？ 当然不会。不然 Deferred 于 Future 又有上面区别的，这里await 很可疑。因为实际上是要给 suspend 函数。整个函数只能在协程体或者其他 suspend 函数内部被调用，就像是回调的语法糖一样，通过一个叫 Continuation 的接口来实现返回结果 123456789101112@SinceKotlin("1.3")public interface Continuation&lt;in T&gt; &#123; public val context:CoroutineContext public fun resumeWith(result:Result&lt;T&gt;)&#125;@SinceKotlin("1.1")public interface Continuation&lt;in T&gt; &#123; public val context:CorouineContext public fun resume(value: T) public fun resumeWithException(exception: Throwable)&#125; 其实就是要给回调，有结果正常返回， Continuation 调用 resume 返回结果，否则调用 resumeWithException 来抛出异常。 因此，请求的代码执行流程本质上是一个异步回调 而之所以可以看起来是同步的，那就是编译器的黑魔法了 在虚拟机上 await 函数的真实样子是这样的 1kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object 即接收一个 Continuation 实例，返回 Object 这么一个函数，所以前面的代码可以理解为 123456789101112// 不是正确代码，仅用来理解协程使用GlobalScope.launch(Dispathcers.Main) &#123; githubServiceApi.getUser("small").await(object: Continuation&lt;User&gt;&#123; override fun resume(value: User) &#123; showUser(value) &#125; override fun resumeWithException(exception: Throwable) &#123; showError(exception) &#125; &#125;)&#125; 在 await 当中大致就是： 123456789101112// 不是正确代码，仅用来理解协程使用fun awiat(continuation:Continuation&lt;user&gt;):Any&#123; ...// 切到非 UI 线程中执行，等待结果返回 try &#123; val user = ....// 这里执行任务 handler.post &#123; continuation.resume(user) &#125; &#125; catch(e: Exception) &#123; handler.post&#123;continuation.resumeWithException(e)&#125; &#125;&#125; 从运行机制上来讲，协程和回调没有本质的区别 suspend 方式suspend 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用 Retrofit 在 release 2.5.0 之后才会支持 suspend 函数 首先修改一下接口方法 12@GET("users/&#123;login&#125;")suspend fun getUser(@Path("login")login:String): User 这种情况下， Retrofit 会根据接口方法的生命来构造Continuation ，并且在内部封装了一个 Call 的异步请求(使用 enqueue) ，进而得到 User 实例。 1234567GlobalScope.launch &#123; try &#123; showUser(githubServiceApi.getUser("small")) &#125; catch (e: Exception) &#123; showError(e) &#125;&#125; 协程到底是什么以前我们使用 Java 进行开发的时候，经常会遇到 回调地域 ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。 而 协程 可以帮我们优雅的处理掉这些 协程本身是一个脱离语言实现的概念。简单来说就是： 协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。 Job1234567891011public interface Job: CoroutineContext.Element &#123; ... public val isActive: Boolean public val isCompleted: Boolean public val isCancelled: Boolean public fun start():Boolean public fun cancel(cause: CancellationException? = null) public suspend fun join() ...&#125; 我们看一下 Thread 的定义 123456789public class Thread implements Runnable &#123; ... public final native boolean isAlive(); public synchronized void start()&#123;&#125; @Deprecated public final void stop()&#123;&#125; public final void join() throws InterruptedException&#123;&#125;&#125; Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Lifecycle]]></title>
    <url>%2F2021%2F01%2F29%2FJetpack%2FLifecycle%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[开始是废话（翻译自源码）定义了一个 Android 生命周期的对象。 Fragment和FragmentActivity类实现LifecycleOwner接口， 并可以通过 getLifecycle() 方法来访问生命周期。 我们也可以实现LifecycleOwner在自己的类。1234// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY 如果您使用Java 8 语言 ，然后使用DefaultLifecycleObserver 观察事件。 需要将&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot; 增加到你的 build.gradle 文件中。 123456class TestObserver implements DefaultLifecycleObserver &#123; @Override public void onCreate(LifecycleOwner owner) &#123; // your code &#125;&#125; 如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以DefaultLifecycleObserver和注释之间，则须偏向 DefaultLifecycleObserver。 1234class TestObserver implements LifecycleObserver &#123; @OnLifecycleEvent(ON_STOP) void onStopped() &#123;&#125;&#125; 观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为LifecycleOwner 。 带注释的方法Lifecycle.Event.ON_ANY 可以接收第二个参数，它必须是类型的Lifecycle.Event。 123456class TestObserver implements LifecycleObserver &#123; @OnLifecycleEvent(ON_CREATE) void onCreated(LifecycleOwner source) &#123;&#125; @OnLifecycleEvent(ON_ANY) void onAny(LifecycleOwner source, Event event) &#123;&#125;&#125; 提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。 那我能做什么呢说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 友盟统计 在友盟统计中，我们经常会在 BaseActivity 中插入友盟对页面流转的统计, onStart() onResume() onPause() onStop() 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。 干货~~~来了 那么解决上述问题的方案就来了，我们通过实现 LifecycleObserver ，通过标识声明周期方法之后，仅需一句 addObserver(this) ，就可以将 Activity 或 Fragment 的声明周期方法与我们定义的 Observer 方法关联起来。通过感知 Activity 或 Fragment 的声明周期方法，实现友盟统计，此时就将业务整体与 BaseActivity 抽离开，是的公共组件变得更简洁一些。 当然，这只是 Lifecycle 的一种简单应用，其他的使用方法还是需要我们不断的去探索。 源码分析Lifecycle UML 想理解一个东西，最好的方式就是去阅读它， 这是开发多年总结出的一句话。 那么通过上面的 UML 类图关系，我们能够看出， Lifecycle 的内容并不是很多。但它怎么就会这么强大呢。 ComponentActivity &amp; ReportFragment就算没看过源码，知道Lifecycle 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 Activity 有关，通过AppCompatActivity 类，我们向上查找，我们可以看到 ComponentActivity 这个类，实现了 LifecycleOwner 接口，并返回了一个 mLifecycleRegistry 12345678// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);// LifecycleOwner 接口，提供了一个 getLifecycle() 方法@Overridepublic Lifecycle getLifecycle()&#123; return mLifecycleRegistry;&#125; 在 ComponentActivity 的构造方法里，适配了不同的平台版本。 12345678910111213141516171819202122232425262728293031323334353637383940public ComponentActivity() &#123; Lifecycle lifecycle = getLifecycle(); //noinspection ConstantConditions if (lifecycle == null) &#123; throw new IllegalStateException("getLifecycle() returned null in ComponentActivity's " + "constructor. Please make sure you are lazily constructing your Lifecycle " + "in the first call to getLifecycle() rather than relying on field " + "initialization."); &#125; if (Build.VERSION.SDK_INT &gt;= 19) &#123; getLifecycle().addObserver(new LifecycleEventObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_STOP) &#123; Window window = getWindow(); final View decor = window != null ? window.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; &#125; &#125; &#125;); &#125; getLifecycle().addObserver(new LifecycleEventObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; if (!isChangingConfigurations()) &#123; getViewModelStore().clear(); &#125; &#125; &#125; &#125;); if (19 &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= 23) &#123; getLifecycle().addObserver(new ImmLeaksCleaner(this)); &#125;&#125; 通过构造方法，有没有发现一个很重要的信息， addObserver()， 由此，我们不难看出 ，LifecycleRegister 的一个重要的方法就是 addObserver() 。翻阅类结构了解到 LifecycleRegister 是 Lifecycle 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。 我们先不着急看 LifecycleRegister，继续看 CompontentActivity 类，既然是个 Activity 那么一定会有创建过程，回看 onCreate() 方法，我们可以观察到一个有趣的东西： 123456789101112131415/** * &#123;@inheritDoc&#125; * * If your ComponentActivity is annotated with &#123;@link ContentView&#125;, this will * call &#123;@link #setContentView(int)&#125; for you. */@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); ReportFragment.injectIfNeededIn(this); if (mContentLayoutId != 0) &#123; setContentView(mContentLayoutId); &#125;&#125; ReportFragment.injectIfNeededIn(this) 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。 别慌，进去看。 ReportFragment12345678910public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125;&#125; 咦？？？？为什么要在我的 Activity 上添加一个 Fragment， 翻遍代码，我们也未见到任何布局，你是一个空的 ，😱😱😱， 太可怕了！ 按照 Fragment 的生命周期，我们继续看 dispatch()1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE);&#125;@Overridepublic void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START);&#125;@Overridepublic void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME);&#125;@Overridepublic void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE);&#125;@Overridepublic void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null;&#125; 有没有发现， 又有一个方法被重复的利用，没错，就是dispatch(Lifecycle.Event event) 而且传入的参数，又和 Activity 的生命周期一致。那么我们来看看它. handleLifecycleEvent()1234567891011121314private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 handleLifecycleEvent(event) 方法，又蒙蔽了不，这里啥也没干，就跑了。 你跑，那我就追！ LifecycleRegister123456789101112131415161718192021222324252627/** * Sets the current state and notifies the observers. * &lt;p&gt; * Note that if the &#123;@code currentState&#125; is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 两个方法，我们翻译下注释 设置当前状态，并通知观察者 注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效 getStateAfter()现在我们来分析源码，getStateAfter(event) 这个方法，我们先进去看下做了什么： 1234567891011121314151617static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException("Unexpected event value " + event);&#125; 原来是一个静态方法，通过传入的 Event 事件，找到当前事件对应的下一个生命周期状态 State 我们还有一个方法没有分析 moveToState(State next), 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 123if (mState == next) &#123; return;&#125; 如果当前状态和下一个（操作后的）状态一致，则直接 return 这也映照了注释中的那句话。 sync()继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 sync() 方法，咦，这又是什么呢？===&gt; 状态同步 12345678910111213141516171819202122232425262728293031/** * Custom list that keeps observers and can handle removals / additions during traversal. * * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), */private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;();// happens only on the top of stack (never in reentrance),// so it doesn't have to take in account parentsprivate void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already" + "garbage collected. It is too late to change lifecycle state."); &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125; 这里出现了一个新东西 mObserverMap 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。 继续分析源码 mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个backwardPass(lifecycleOwner) 方法，让观察者的状态回退到当前状态上 mState.compareTo(newest.getValue().mState) &gt; 0 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 forwardPass(lifecycleOwner) Lifecycle State Sequence通过分析 forwardPass 和 backwardPass 方法，我们看到其内部又调用了两个方法, downEvent 和 upEvent，我们称呼为升级事件和降级事件 123456789101112131415161718192021222324252627282930private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; 通过上面两个方法，我们总结出 Lifecycle 中 State 和 Event 的时序关系，如下图 同时我们也回顾一下，getStateAfter() 方法，对事件和状态的判断，也就明白了状态和事件的关系。 dispatchEvent123456789101112131415161718192021222324252627282930private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125;&#125;private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125;&#125; 迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发observer.dispatchEvent(lifecycleOwner, event) 123456void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; 哈哈， 又是一个方法进入了我们的视线 onStateChanged(owner, event)，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？ 但我们只需要关注 ReflectiveGenericLifecycleObserver , 想知道为什么吗？ 我也是看了源码才总结出来的。 ReflectiveGenericLifecycleObserver1234567891011121314151617/** * An internal implementation of &#123;@link LifecycleObserver&#125; that relies on reflection. */class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(LifecycleOwner source, Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; 哎，mInfo.invokeCallbacks(source,event,mWrapped); 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨 既然是类嘛，那肯定是要创建的，那就看下构造器呗。 wrapped 这东西，经过了缓存，Emmm ，我也是点进去 ClassesInfoCache 之后，都了它的注释才明白的。 那 wrapped 又是什么呢？通过 ClassesInfoCache 和我们追踪 ReflectiveGenericLifecycleObserver 可以看出， ClassesInfoCache 缓存了 LifecycleObserver 的类对象，ReflectiveGenericLifecycleObserver 也是向下传递一个 LifecycleObserver。由此我们可以判断出，其实这个 LifecycleObserver 就是我们自己定义的观察者。 而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 mInfo.invokeCallback(source event, mWrapped); reflect invoke method1234567891011121314151617181920void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; //noinspection TryWithIdenticalCatches try &#123; switch (mCallType) &#123; case CALL_TYPE_NO_ARG: mMethod.invoke(target); break; case CALL_TYPE_PROVIDER: mMethod.invoke(target, source); break; case CALL_TYPE_PROVIDER_WITH_EVENT: mMethod.invoke(target, source, event); break; &#125; &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException("Failed to call observer method", e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125;&#125; 还记得文章开头对 Lifecycle 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法 至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。 但是！！！！！！！！！！！！！！！！ 我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！ addObserver()前面我们说了一大堆，都是对 Lifecycle 如何处理，并监听我们的生命周期的方法，也就是 Lifecycle是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？ 好，我们继续观察 LifecycleRegister 中的 addObserver(LifecycleObserver) 这个也是我们自定义观察者后，需要调用的方法 123456789101112131415161718192021222324252627282930313233@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125; 哈哈，看起来代码并不是很多丫！！！！ 哼，天真的你！但它就是这么多 我们这里要逐行清点 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; 嗯，一上来就初始化了一个 INITIALIZED 状态的状态，哈哈哈，好拗口。 随后创建了一个 ObserverWithState ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。 紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 Map 中，也就是 mObserverMap 然后返回了个东西， 阅读后发现，又和 Lifecycle 的注释对上了。 之后，计算出当前 Activity 或 Fragment 的状态，并判断，如果当前观察者的状态落后于 Activity 或 Fragment 的状态，则立即执行dispatchEvent() 方法，执行回调。 总结认真阅读源码后，我们能够看出，其实 Lifecycle 的技术很简单，只有反射，观察者，装饰器，它将这三个东西应用的很神。 总结一下，分析源码我们从两方面入手 addObserver() 这个方法是对用户最直接的内容，当我们创建一个 Observer 后，都会通过 add 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到 给要添加的Observer 一个初始的状态（装饰器模式，包装数据） 将数据存储再本地缓存中 （mObserverMap） 立即进行状态判断，决定是否处理生命周期变化 ReportFragment 作用是，附着再 Activity 上，用来感知 Activity 的生命周期变化，也起到将业务从 Activity 中分离出来。通过生命感知生命周期的变化，执行 dispatch() 方法，将生命周期事件分发给它所有的观察者去处理消息 handleLifecycleEvent 反射 这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。 sync() 这个方法是用来快速同步观察者状态与 Activity 和 Fragment ，目的也是能够让观察者执行到它所有观察的数据。两个方法 forwardPass() 和 backwardPass() 是其实现的原理。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 架构组件]]></title>
    <url>%2F2021%2F01%2F29%2FJetpack%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[应用架构指南 当您在自己喜欢的社交网络应用中分享照片时会发生什么： 该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的 相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用 最后，用户返回社交网络应用并分享照片 此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。 移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间 因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖 常见架构原则分离关注点常见错误是再 activity 和 fragment 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题 通过模型驱动界面通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。 持久性是思想之选，原因如下: 1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据 2. 当网络连接不稳定或不可用时，应用会继续工作 应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。 推荐应用架构 每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。 这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。 构建界面界面由Fragment UserProfileFragment 及其对应的布局文件 user_profile_layout.xml 组成 如需驱动该界面，数据模型需要存储以下数据元素 用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。 用户对象：用于存储用户详细信息的数据类 ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响 user_profile.xml : 屏幕的界面布局 UserProfileFragment：显示数据的界面控制器 UserProfileViewModel : 准备数据以便再 UserProfileFragment 中查看并对用户互动做出响应的类 UserProfileViewModel 1234class UserProfileViewModel: ViewModel()&#123; val userId:String = TODO() val user: User = TODO()&#125; UserProfileFragment 1234567891011class UserProfileFragment: Fragment()&#123; // 使用 ViewModels() 拓展函数，以及 "androidx.fragment:fragment-ktx:lastest-version" 在 模块下的 build.gradle private val viewModel: UserProfileViewModel by viewModels() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View &#123; return inflater.infalte(R.layout.main_fragment, container, false) &#125;&#125; 现在，由了这些代码块，需要将他们串联起来，毕竟在 UserProfileViewModel 类中设置 user 字段时，我们需要一种方法来通知界面 要获取 user 我们的 ViewModel 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 SaveState 模块，我们可以让 View Model 直接读取参数 SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数 12345678910// UserProfileViewModelclass UserProfileViewModel (savedStatedHandle: SavedStateHandle) :ViewModel()&#123; val userId:String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user: User = TODO()&#125;// UserProfileFragmentprivate val viewModel: UserProfileViewModel by viewModels( factoryProducer = &#123;SavedStateVMFactory(this)&#125;)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Data Binding]]></title>
    <url>%2F2021%2F01%2F29%2FJetpack%2FData%20Binding%2F</url>
    <content type="text"><![CDATA[Data Binding概念布局和绑定表达式借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 data 元素（界面布局根元素的同级）内定义。这两个元素都封装在 layout 标记中。 12345678910111213&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://scheams.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.myapp.data.ViewModel"&gt; &lt;/variable&gt; &lt;/data&gt; &lt;ConstraintLayout&gt; &lt;!-- UI layout`s root element--&gt; &lt;/ConstraintLayout&gt;&lt;/layout&gt; 使用可观察的数据对象数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。 生成的绑定类数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。 绑定适配器每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 setText() 方法来设置文本属性，或者调用 setOnClickListener() 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 android:text 属性）可供您在 android.databinding.adapters 软件包中使用。也可以自定义适配器 1234@BindingAdapter("app:goneUnless") fun goneUnless(view: View, visiable: Boolean) &#123; view.visibility = if (visiable) View.VISIABLE else View.GONE&#125; 双向数据绑定数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新 使用入门编译环境要开始使用数据绑定，从 Android SDK 管理器中的 支持代码库 下载。要将应用配置为使用配置绑定，需要在应用模块的 build.gradle 文件中添加 databinding 元素 123456android&#123; ... dataBinding&#123; enabled = true &#125;&#125; 即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定 布局和绑定表达式借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。 数据绑定布局文件略有不同，以根标记layout 开头，后跟 data 和 view 根元素。此视图元素是非绑定布局文件的根 123456789101112131415161718192021&lt;?xml version="1.0" encodeing="utf-8"?&gt;&lt;layout xmlns:android="http://scheams.android.comapk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.fiestName&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="warp_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; data 中的 user 变量描述了可在此布局中使用的属性 1&lt;variable name="user" type="com.example.User"/&gt; 布局中的表达式使用了 @{} 语法写入特性属性中，在这里， TextView 文本被设置为 user.fistName 和 user.lastName 1234567&lt;TextView android:layout_width="wrap_content" android:layout_height="warp_content" android:text="@&#123;user.firstName&#125;"/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="warp_content" android:text="@&#123;user.lastName&#125;"/&gt; 数据对象1data class User(val firstName:String, val lastName: String) 绑定数据系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 activity_main.xml ,因此生成的对应类为 ActivityMainBinding。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。 1234567override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.user= User('Test', "User")&#125; 再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 LayoutInflater 获取视图， 1val binding: ActivityMainBinding= ActivityMainBinding.inflate(getLayoutInflater()) 如果需要再 Fragment ListView 或 RecyclerView 适配器中使用数据绑定项，您可能更愿意使用绑定类或 DataBindingUtil 类的 inflate() 方法 123val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)// orval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false) 表达式语言 名称 符号 算数运算符 +, -, /, *, % 字符串连接运算符 + 逻辑运算符 &amp;&amp;, \ \ 二元运算符 &amp;, \ , ^ 一元运算符 +, -, !, ~ 移位运算符 &gt;&gt; , &lt;&lt;, &gt;&gt;&gt; 比较运算符 ==, &gt;, &lt;(需要转义为’&amp;lt ;’), &gt;=, &lt;= instanceof 分组运算符 () 字面运算符 字符，字符串，数字， null 类型转换 方法调用 字段访问 数组访问 [] 三元运算符 ?: 1234&lt;TextView android:text="@&#123;String.valueOf(index+1)&#125;" android:visibility="@&#123;age &gt; 13 ? View.GONE : View.VISIBLE&#125;" android:transitionName="@&#123;"image_"+id&#125;" Null 合并运算符 如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边 1android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot; 等效于 1android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot; 视图引用表达式可以通过以下语法按 ID 引用布局中的其他视图，并会将 ID 自动转换为驼峰法 123456789&lt;EditText android:id="@+id/example_text" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;TextView android:id="@+id/example_output" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@&#123;exampleText.text&#125;"/&gt; 集合可以使用 [] 运算符访问常见集合，例如数组、列表、Hash 列表、和映射 123456789101112&lt;data&gt; &lt;import type="android.util.SparseArray"/&gt; &lt;import type="java.util.Map"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="list" type="List$lt;String&gt;"/&gt; &lt;variable name="sparse" type="Sparse$lt;String&gt;"/&gt; &lt;variable name="map" type="Map$lt;&lt;String, String&gt;"/&gt; &lt;variable name="index" type="int"/&gt; &lt;variable name="key" type="String"/&gt;&lt;/data&gt;​ android:text=”@{list[index]}”​12android:text=&quot;@&#123;sparse[index]&#125;&quot;​ android:text=”@{map[key]}”1234### 资源表达式可以使用一下语法引用资源 android:padding=”@{large?@dimen/largePadding : @dimen/smallPadding}”123456789101112131415161718192021222324252627某些资源需要显示类型求值| 类型 | 常规引用 | 表达式引用 || ----------------- | --------- | ------------------ || String[] | @array | @stringArray || int[] | @array | @intArray || TypedArray | @array | @typedArray || Animator | @animator | @animator || StateListAnimator | @animator | @stateListAnimator || color int | @color | @color || ColorStateList | @color | @colorStateList |### 事件处理可以编写从视图分派的表达式处理事件如：`onClick` #### 方法引用事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。```kotlinclass MyHandler&#123; fun onClickFriend(view:View)&#123;...&#125;&#125; 绑定白哦大师可见视图的点击监听器分配给 onClickFriend() 方法 123456789101112131415161718&lt;layout xmlns:android="http://scheams.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handlers" type="com.example.MyHandler"/&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:onClick="@&#123;handlers::onClickFriend&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 监听器绑定监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。 在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。 123class Presenter &#123; fun onSaveClick(task: Task)&#125; 将事件绑定到 onSaveClick() 方法 123456789101112&lt;layout xmlns:android="http://scheams.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="" type="com.example.Task"/&gt; &lt;variable name="presenter" type="com.example.Presenter"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:onClick="@&#123;() -&gt; presenter.onSaveClick(task)&#125;" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/layout&gt; 在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。 避免使用复杂的监听器 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。 导入、变量和 包含导入：可以轻松的在布局文件中引用类 变量：可以描述可在绑定表达式中使用的属性 包含：可以在整个应用中重复使用复杂的布局 导入在 data 元素中使用多个 import 元素，也可以不用。 123&lt;data&gt; &lt;import type="android.view.View"/&gt;&lt;/data&gt; 导入 View 类可以通过绑定表达式引用该类 123456&lt;TextView android:text="@&#123;user.name&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"&gt;&lt;/TextView&gt; 类型别名 当类名有冲突时，其中一个类可使用别名重命名。 123&lt;import type="android.view.View"/&gt;&lt;import type="com.example.real.estate.View" alias="Visia"/&gt; 变量variable 每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。 123456&lt;data&gt; &lt;import type="android.graphics.drawable.Drawable"/&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;variable name="image" type="Drawable"/&gt; &lt;variable name="note" type="String"/&gt;&lt;/data&gt; 变量类型在编译时进行检查，因此如果实现了 Observable 或者时 可观察集合，则因反应在类型中。 在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。 包含通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。 123456789101112131415&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/name" bind:user="@&#123;user&#125;"/&gt; &lt;include layout="@layout/contact" bind:user="@&#123;user&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞队列]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是阻塞队列BlockingQueue 是一个支持两个附加操作的队列。 在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。 阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素 ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列 DelayQueue: 一个使用优先级排序的无界阻塞队列 SynchronousQueue：一个不存储元素的阻塞队列 LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列 LinkedBlockingDeque：一个由链表组成的双向阻塞队列 阻塞队列的实现原理使用通知模式实现 所谓 通知模式 就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。 ArrayBlockingQueue： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private final Condition notFull;private final Condition notEmpty;public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0)&#123; throw new IllegalArgumentException(); &#125; this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125;public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while(count == items.length) &#123; notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) &#123; notEmpty = await(); &#125; return extract(); &#125; finally &#123; lock.unlock(); &#125;&#125;private void insert(E x) &#123; items[putIndex] = x; putIndex = inc(putIndex); ++count; // 唤醒一个等待线程 notEmpty.signal();&#125; 当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 LockSupport.park(this) 来实现 123456789101112131415161718192021222324252627public final void await() throws InterruptedException &#123; if(Thread.interrupted()) &#123; throw new InterruptedException(); &#125; Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while(!isOnSyncQueue(node)) &#123; LockSupport.park(this); if((interruptMode = checkInterruptWhileWaitting(node)) != 0) &#123; break; &#125; &#125; if(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; if(node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; if(interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Room]]></title>
    <url>%2F2021%2F01%2F29%2FJetpack%2FAndroid%20Room%2F</url>
    <content type="text"><![CDATA[翻译自官网文档 Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库 Database: 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder Entity: 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities 数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中 Dao: 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。 1234567891011121314151617181920212223242526272829303132333435363738// File: User.java@Entitypublic class User &#123; @PrimaryKey private int uid; private String name; @ColumnInfo(name = "last_name") private String lastName; // Room 请求 set 和 get 方法去访问数据&#125;// File: UserDao.java@Daopublic interface UserDao &#123; @Query("select * from user") List&lt;User&gt; loadAll(); @Query("select * from user where uid in (:userIds)") List&lt;User&gt; loadAllByUserId(int... userIds); @Query("select * from user where name like :first and last_name like :last limit 1") User loadOneByNameAndLastName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125;// File: AppDatabse.java@Database(entities = &#123;User.java&#125;)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125;// 创建 AppDatabase 实例AppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, "database_name").build(); 一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/ 可以通过使用 InvalidtaionTracker 类来观察一个数据表的变化。 Room 允许通过 Query 方法返回一个 LiveData 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 LiveData 的观察者 123// LiveData 会自动分发数据表的改变@Query("Select * from user order by name limit 5") public LiveData&lt;List&lt;User&gt;&gt; loadFirstFiveUsers();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FObject%20%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object 类 Object 类是所有 Java 类的父类。每个类都使用 Object 作为 super 类，所有对象都实现这个类的方法 可以使用 Object 类型的变量指向任意类型的 super 类 Object 类有一个默认构造方法 public Object() ，在构造子类实例时，都会先调用这个默认构造方法 Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换 API Object () ： 默认构造方法 clone() : 创建并返回此对象得一个副本 equals(Object obj) : 指示某个其他对象是否与此对象相等（Object 判断的是内存地址） finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法 getClass(): 返回一个对象得运行时类 hashCode(): 返回该对象得 哈希值 notify(): 唤醒在此对象监视器上等待得单个线程 notifyAll() : 唤醒在此对象监视器上等待得所有线程 toString(): 返回该对象得字符串标识 wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法 wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量 wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量]]></content>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E2%80%98%2F</url>
    <content type="text"><![CDATA[代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。 静态代理目的： 通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向 通过代理对象对原有业务的增强。 代理模式一般会有三个角色： 抽象角色： 指代理角色和真是角色对外提供的公共方法，一般为一个接口 真实角色： 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者 代理角色： 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。 静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。 静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。 动态代理动态代理是指在使用时再创建代理类和实例 有点： 只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活 缺点： 效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。 应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。 动态代理的实现原理InvocationHandler 和 Proxy 一个接口，一个类，再动态代理中时一定会用到的 InvocationHandler 接口是给动态代理类实现的，负责处理被代理对象的操作 Proxy 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法 123456Proxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]&#123;A.class, B.class&#125;, new InvocationHandler()&#123; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; return method.invoke(a, objects); &#125;&#125;)]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 泛型]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FJava-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型，即 参数化类型。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。 参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。 泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。 三种泛型方式123456789101112131415161718// 泛型类public class TypeClass&lt;T&gt; &#123; private T data; public TypeClass(T data) &#123; this.data = data; &#125;&#125;// 泛型接口public interface TypeInterface&lt;T&gt; &#123; T next();&#125;// 泛型方法// public &lt;T&gt; T typeMethod(T t)&#123; &#125; 泛型的作用 使得代码更健壮 代码更简洁 更灵活、可复用 限定类型变量有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。 123456public static &lt;T&gt; T min(T a, T b) &#123; if(a.compareTo(b) &gt; 0) return a; else return b;&#125; 那么如上代码，如果我们传入的两个变量没有实现 Comparable 会如何呢？那一定是调用不到 compareTo() 的，那么我们对其加上约束 123456public static &lt;T extends Comparable&gt; T min (T a, T b)&#123; if(a.compareTo(b) &gt; 0) return a; else return b;&#125; T extends Comparable 中，T 表示应该绑定的子类型， Comparable 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。 如果我们传入一个没有实现 Comparable 接口的实例，则会发生编译错误。 同时 extends 左右都允许有多个，比如 T, V extends Comparable &amp; serializable ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个 约束和局限性 不能使用基本类习数据类型做参数，只能使用包装器类型 运行时类型查询只时用于原始类型 反射对泛型擦除增加了风险 泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突） 静态块/静态方法中不能使用泛型 不能创建参数化类型的数组 不能实例化类型变量 不能捕获泛型类的实例 泛型的继承规则1234class Employee &#123;&#125;class Worker exrends Employee&#123;&#125;class Pair&lt;T&gt; &#123;&#125; 泛型类可以继承或者扩展其他泛型类，比如 List 和 ArrayList 通配符12345678910111213141516class Fruit &#123;&#125;class Orange extends Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class HongFuShi extends Fruit&#123;&#125;public static void println(GenericType&lt;Fruit&gt; p) &#123; System.out.println(p.getData().getColor());&#125;public void use () &#123; GenericType&lt;Fruit&gt; a = new GenericType(); // 可以 GenericType&lt;Apple&gt; b = new GenericType();// 不允许d &#125; 因为上面的方案不被 SDK 允许，于是提出了一个通配符类型 ? extends X 表示类型的上界，类型参数是 X 的子类 ? super X 表示类型的下界，类型参数是 X 的父类 ? extends X，可读不可写表示传递给方法的参数，必须是 X 的子类（包括 X 本身） 123public static void println(GenericType&lt;? extends Fruit&gt; p)&#123; System.out.println(p.getData().getColor());&#125; 但对于泛型类 GenericType 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改） 因为 ? extends X 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。 ? super X ，可写不可读表示传递给方法的参数，必须是 X 的父类（包括 X 本身） 123public static void println(GenericType&lt;? super Apple&gt; p) &#123; System.out.println(po.getData());&#125; 但对于泛型类 GenericType 来说，如果其中提供了 get 和 set 类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。 get 方法只返回一个 Object 类型的值。因为 ? super X 表示类型的下界，参数类型是 X 的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但 Object 一定是它的父类，所以 get 方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。 无限通配符 ?，只是为了说明用法表示类型没有限制，可以把 ? 看成所有类型的父类，如： Pair&lt;?&gt; ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;() 指定集合元素只能是 T 类型 ArrayList&lt;?&gt; al = new ArrayList&lt;?&gt;() 集合元素可以是任意类型。 虚拟机是如何实现的Java 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，ArrayList&lt;int&gt; 与 ArrayList&lt;String&gt; 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为伪泛型 泛型擦除因为虚拟机实现原理，就是泛型擦除，因此 泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object 步骤 检查泛型类型，获取目标泛型 擦除类型变量，并替换为限定类型 如果泛型类型的类型变量没有限定&lt;T&gt; 则用 Object 原始类型表示 如果有限定类型&lt;T extends XClass&gt;则用，XClass 作为原始类型 如果有多个限定&lt;T extends XClass &amp; XClass2&gt; 则使用第一个作为原始类型 在必要时插入类型转换以保证类型安全 生成桥方法 以再扩展时保持多态]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FJava-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。 声明注解Java 中所有的注解，默认实现接口 Annotation 接口 123456789public interface Annotation &#123; boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();&#125; 与生命一个 Class 不同，注解的使用使用 @interface 管检测 1public @interface Login &#123;&#125; 元注解在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。 Target注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值 ElementType.ANNOTATION_TYPE 可以用于注解类型 ElementType.CONSTRUCTOR 可以用于构造函数 ElementType.FIELD 可以用于字段或属性 ElementType.LOCAL_VARIABLE 可以用于局部变量 ElementType.METHOD 可以应用于方法级注解 ElementType.PACKAGE 可以应用于包生命 ELementType.PARAMETER 方法参数 ElementType.TYPE 用于类的任何元素 Retention注解指定标记注解的存储方式（作用域）： RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略 RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略 RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用 应用场景按照作用域来讲，注解可以被三种场景使用 SOURCERetentionPolicy.SOURCE 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用 语法检查： 在 Adnroid开发中，support-annotations 与 androidx.annotation 中均提供了 @IntDef 注解， 1234567@Retention(SOURCE)@Target(&#123;ANNOTATION_TYPE&#125;) public @interface IntDef &#123; int[] value() default &#123;&#125;; boolean flag() default false; boolean open() default false;&#125; 此注解的意义在于能够取代枚举，实现如方法入参限制 如：我们定义 test 方法，只接收 Teacher 参数， 12345public enum Teacher &#123; LILY, MARY&#125;public void test(Teacher teacher) &#123;&#125; 而现在为了内存优化，我们现在不再使用枚举，则方法定义为 1234public static final int LILY = 1;public static final int MARY = 2;public void test(int teacher)&#123;&#125; 然而 test 方法由于采用基本数据类型 int ，讲无法进行类型限定。此时我们使用 @IntDef 增加自定义注解 123456789public static final int LILY = 1;public static final int MARY = 2;@IntDef(value = &#123;LILY, MARY&#125;) // 限定为 LILY, MARY@Target(ElementType.PARAMETER) // 作用于参数的注解@Retention(RetentionPolicy.SOURCE) public @interface Teacher&#123;&#125;public void test(@Teacher int teacher) &#123;&#125; 此时，我们再去调用 test 方法，如果传递的参数不时 LILY, 和 MARY 则会显示 Inspection 警告 APT 注解处理器 apt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。 Class定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等 所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。 我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：需要登录 和 不需要登录 即两个切面，对于切面的区分可采用注解 123456789101112@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface LoginAspect&#123;&#125;@LoginAspectpublic void jumpA()&#123; startActivity(new Intent(this, AActivity.class));&#125;public void jumpB()&#123; startActivity(new Intent(this, BActivity.class));&#125; Runtime注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 枚举]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FJava%20%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。 使用enum 来标识枚举类 特点 必须使用 enum 关键字声明 除了初始化，不能通过任何方式手动创建枚举实例 不可以被继承 JVM 保证线程安全 无法继承其他类 原理分析常量枚举 123456789101112public enum Color &#123; RED, GREEN, BLUE;&#125;public class Test &#123; public static void main(String[] args) &#123; System.out.println(Color.RED); &#125;&#125;// 结果// RED 上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。 通过字节码分析 Color.class 1234567891011121314151617181920212223242526272829303132333435363738// final 修饰，不能被继承public final class Color extends Enum &#123; // 声明的变量，都对应一个枚举实例对象 public static final Color RED; public static final Color GREEN; public static final Color BLUE; private static final Color $VALUES[]; // 返回原数组的副本，防止数组的修改，引起内部 values 值的改变 public static Color[] values()&#123; return (Color[])$VALUE.clone(); &#125; // 按照名字获取枚举实例 public static Color valueOf(String name) &#123; return (Color)Enum.valueOf(com/example/Color, name); &#125; // 私有构造 private Color(String name, int ordinal) &#123; super(name, ordinal); &#125; // 静态初始化 // 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全 static &#123; RED = new Color("RED", 0); GREEN = new Color("GREEN", 1); BLUE = new Color("BLUE", 2); $VALUES = (new Color[] &#123; RED, GREEN, BLUE &#125;); &#125;&#125; 从反编译的类中可以看出，enum 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 jvm 中运行的代码 Enum 类接受一个继承自 Enum 的泛型（反编译阶段，Java中没有具体体现泛型，是应为泛型在编译阶段就会被 JVM 进行泛型擦除，替换为具体实现） 从枚举类以及反编译出来的字节码可以看出，枚举类第一个 ; 前的变量，都会在字节码中体现为一个 Color 实例，且在 clinit 静态代码块中进行初始化。而静态块在类加载阶段，JVM 会保证枚举对象的线程安全。 生成的 $VALUES[] 可通过 values() 方法被外部获取实例。 枚举 Enum 类分析123456789101112131415161718public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; private final String name; private final int ordinal; public final int compareTo(E var1) &#123; if (this.getClass() != var1.getClass() &amp;&amp; this.getDeclaringClass() != var1.getDeclaringClass()) &#123; throw new ClassCastException(); &#125; else &#123; return this.ordinal - var1.ordinal; &#125; &#125; public final boolean equals(Object var1) &#123; return this == var1; &#125;&#125; Enum 类实现了 Comparable 接口，表明它是支持排序的，实现 compareTo ，方法定义为 final 且实现以来 ordinal 字段也是 final 类型，说明只能依据 ordinal 排序，排序规则不可变. ordinal: 表示枚举的顺序，从 Color 类中可以看出他是从 0 开始自然顺序增长，且其值是 final 类型，外部无法改变。 name: 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改） equals(): 使用 == 判断两个枚举是否相等 每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 JVM 中有且只有一个对应的实例 为达到这种效果，枚举通过下面的方式来完成 类加载时创建，保证线程安全 枚举对象在静态块中创建，由类加载时进行初始化，JVM 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例 对序列化进行特殊处理，防止反序列化时创建对象 一旦实现 Serializable 接口之后，反序列化时每次调用 readObject() 方法返回的都是一个新创建出来的对象 而枚举在序列化时，Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过枚举的 valueOf() 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制 1234567891011121314151617public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; var0, String var1) &#123; Enum var2 = (Enum)var0.enumConstantDirectory().get(var1); if (var2 != null) &#123; return var2; &#125; else if (var1 == null) &#123; throw new NullPointerException("Name is null"); &#125; else &#123; throw new IllegalArgumentException("No enum constant " + var0.getCanonicalName() + "." + var1); &#125; &#125;private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125;private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; 私有构造函数，无法正常 new 出对象 无法通过 clone() 方法， 克隆对象 123protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException();&#125; 无法通过反射的方式创建枚举对象 枚举类型在 JVM 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 Cannot reflectively create enum objects 12345678910111213void reflectTest() throws Exception&#123; // 获取类对象 Class&lt;?&gt; cls = Class.forName("com.example.Color"); // 获取构造函数 Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(String.class, int.class); // 设置访问权限 constructor.setAccessible(true); // 实例化对象 Object refObj = constructor.newInstance("name", 0);&#125;// ExceptionException in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects 枚举的使用枚举与单例模式传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一 123456public enum Singleton &#123; INSTANCE; public void func1()&#123; // todo... &#125;&#125; 枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。 在 Android 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 双重检查锁，静态内部类 的方式实现单例]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射？ 反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。 一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作 反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 new 关键字来创建对象。 反射的作用 实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现 通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger Java Class 的文件结构 1234567891011121314151617181920typedef struct &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count - 1 ]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; // 重要 u2 fields_count; field_info fields[field_count]; // 重要 u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125;ClassBlock field 字段结构 1234567891011121314151617typedef struct fieldblock &#123; char *name; char *type; char *signature; u2 access_flag; u2 constant; union &#123; union &#123; char data[8]; uintptr_t u; long long l; void *p; int i; &#125; static_value; u4 offset; &#125;u;&#125;FieldBlock; method 提供了 descriptor, access_flags, Code 等索引，并指向常量池； 12345678method_info &#123; u2 access_flags; u2 name_index; // the paramters that the method takes and the value that it return u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 类的加载顺序ClassLoader： 用于加载、连接、缓存 Class，可以通过纯 Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 HashTable&lt;String, Class&gt; 用于实现堆 Class 字节流节码后的缓存，如果 HashTable 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。 初始化过程 当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 clinit()&gt; 中的静态块与静态属性（取决于编码顺序） 1234567891011121314public class Smaple &#123; // step 1 static int b dddddddddddddddddddddddddddddddddddddddddddd= 2; // step 2 static &#123; b = 3; &#125; public static void main (String[] args) &#123; Sample s = new Sample(); System.out.println(s.b); // b = 3 &#125;&#125; Class.forName Class.forName() 可以通过报名寻找到 Class 对象，比如： Class.forName(&quot;java.lang.String&quot;) getDeclaredFields class.getDeclaredFields() 方法实际调用的是 native 方法 getDeclaredFields0() 它在 JVM 主要实现步骤如下 根据 Class 结构体信息，获取 field_count 和 fields[] 字段，这个字段在 load 过程就被放入了 根据 field_count 的大小分配内存和创建数组 将数组进行 forEach 循环，通过 fields[] 中的信息一次创建 Object 对象。 返回数组指针 这个过程比较耗时： 创建、计算、分配数组对象 对字段进行循环赋值 Method.invoke 创建 Frame 如果对象 flag 为 native，交给 native_handler 进行处理 在 frame 中执行 Java 代码 弹出 Frame 返回执行结果的指针 主要慢在 需要完全执行 ByteCode 而缺少 JIT 等优化 检查参数非常多，本来可以在编译器或者加载时完成 class.newInstance 检测权限，预分配空间大小等参数 创建 Object 对象，并分配空间 通过Method.invoke() 调用构造函数 返回 Object 指针 主要慢在： 参数检查不能优化或者一口 构造函数 Method.invoke 本身耗时]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Crash 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。发生 Crash 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 Crash 的放生，在 Android 系统中，系统碎片化比较严重，各 Rom 之间的差异，设置系统的 BUG ，都可能导致 Crash 的发生。 在 Android 应用 中发生 Crash 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 Crash 的监控和获取堆栈信息有所不同。 Java CrashJava 的 Crash 监控非常简单，Java 中的 Thread 定义了一个接口： UncaughtExceptionHandler , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到），当应用发生了 Crash 的时候，就会走 UNcaughtExceptionHandler.uncaughtException ，该方法中可以获取到异常的信息，我们通过 Thread.setDefaultUncaughtExceptionHandler ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CrashHandler implements Thread.UncaughtExceptionHandler &#123; private static final String FILE_NAME_STUFFIX = ".trace"; private static Thread.UncaughtExceptionHandler mDefaultCrashHandler; private static Context mContext; private CrashHandler()&#123;&#125; public static void init(Context context) &#123; mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); mContext = context.getApplicationContext(); &#125; /** * 当程序中有未捕获异常，系统将会调用这个方法 */ @Override public void uncaughtException(Thread t, Throwable e) &#123; try &#123; // 自行处理，可以保存到本地，也可以上传到后台 File file = dealException(e); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; finally &#123; // 交给系统默认程序处理，否则会重复自启动 if(mDefaultCrashHandler != null) &#123; mDefaultCrashHandler.uncaughtException(t, e); &#125; &#125; &#125; /** * 导出异常到 SD 卡 */ private File dealException(Thread t, Throwable e) throw Exception &#123; String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()); File f = new File(mContext.getExternalCacheDir().getAbsoluteFile(), "crash_info"); if(!f.exists()) &#123; f.mkdirs(); &#125; File crashFile = new File(f, time+ FILE_NAME_SUFFIX); // 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题 PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(f))); pw.println(time); pw.println("Thread:" + t.getName()); e.printStackTrace(pw);// 写入 crash 堆栈 pw.flush(); pw.close(); return f; &#125;&#125; NDK CrashLinux 信号机制信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式： 忽略该信号 捕捉该信号并执行对应的信号处理函数（信号处理程序） 执行该信号的缺省操作（如终止进程） 当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。 常见的崩溃信号列表： SIGSEGV: 内存引用无效 SIGBUS: 访问内存对象的未定义部分 SIGFPE: 算数运算错误 SIGILL: 非法指令，如执行垃圾或特权指令 SIGSYS: 糟糕的系统调用 SIGXCPU: 超过 CPU 时间限制 SIGXFSZ: 文件大小限制 一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。 BreakPadGoogle breakpad 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为 C++, 在 Android 中必须要借助 NDK 工具。 Crash监控.pdf]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F29%2FJava%2FJava%20%E4%B8%AD%E6%96%87%E4%BB%B6%20Copy%20%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java 中文件 Copy 的几种方式Java.io利用 java.io 类库。直接为源文件创建一个 FileInputStream 负责读取，然后再为目标文件创建一个 FileOutputStream 负责写入:12345678910111213public static void copyFileByStream(File source, File target) throws IOException &#123; InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream(source); os = new FileOutputStream(target); byte[] buffer = new byte[1024]; int length; while((length = is.read(buffer)) &gt; 0) &#123; os.write(buffer, 0, length); &#125; &#125; &#125; Java.nio利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现 12345678910public static void copyFileByChannel(File source, File target) throw IOException &#123; try(FileChannel sc = new FileInputStream(source).getChannel(); FileChannel tc = new FileOutputStream(target).getChannel();) &#123; long count = sc.size(); while(count &gt; 0) &#123; long transferred = sc.transferTo(sc.position(), count, tc); count -= transferred; &#125; &#125;&#125; Java.nio.file.File.copy关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F29%2FJava%2FJava%20%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java 中堆和栈的区别区别Java 中堆和栈的区别具体由一下几点 各司其职栈： 用来存储局部变量和方法调用 堆： 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。 内存：栈： 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存 堆： 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。 异常错误如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 java.lang.StackOverFlowError 如果堆内存没有可用空间存储 生成的对象， JVM 会抛出 Java.lang.OutOfMemoryError 空间大小栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 StackOverFlowError 问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 内存管理]]></title>
    <url>%2F2021%2F01%2F29%2FJava%2FJava%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 delete/free 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。 运行时数据区域 程序计数器程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。 此区域是唯一一个 Java 虚拟机规范中没有任何 OutOfMemoryError 情况的区域 Java 虚拟机栈Java 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。 每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。 局部变量表 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。 StackOverflowError： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 StackOverflowError 异常 本地方法栈本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。 Java 堆是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。此区域唯一的目的就是存放对象实例，几乎所有的对象实例都再这里分配内存。 Java 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 分代收集算法 ，所以 Java 堆中还可以细分为： 新生代和老生代 如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区 方法区方法区与 Java 堆一样，是哥哥线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。 运行时常量池运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。 垃圾回收GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。 Java 内存区域 虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，这块区域不需要进行 GC 本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。不需要进行 GC 程序计数器：线程独有，可以看作时当前线程执行的字节码行号。不需要进行 GC 本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC 堆：对象实例和水族都是在堆上分配的， GC 也主要堆这两类数据进行回收 回收算法引用计数法最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：循环引用 12345678910111213141516public class Test &#123; Test instance; public Test(String name)&#123;&#125; public static void main(String[] args) &#123; // first A a = new Test("a"); B b = new Test("b"); //second a.instance = b; b.instance = a; //third a = null; b = null; &#125;&#125; 按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。 可达性算法以一系列叫做 GC Root 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。 但是，一个对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 finalize 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。 注意： finalize 方法只会执行一次，如果第一次执行 finalize 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 finalize 方法，对象会被回收。 GC Root 那么，什么样的对象可以作为 GC Root 呢 虚拟机栈（栈帧中的本地变量）中的引用对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI 引用的对象 虚拟机栈中的对象 123456public class Test &#123; public static void main(String[] args) &#123; Test a = new Test(); a = null; &#125;&#125; a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用， a 与原来指向的实例 new Test() 断开连接，所以对象会被回收。 方法区中类静态属性引用的对象 12345678public class Test &#123; public static Test instance; public static void main(String[] args) &#123; Test a = new Test(); a.instance = new Test(); a = null; &#125;&#125; 当栈帧中的本地变量 a = null 时，由于 a 原来指向的对下个与 GC Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 instance 赋值了变量的引用， instance 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。 方法区中常量引用的对象 1234567public class Test &#123; public static final Test instance = new Test(); public static void main(String[] args) &#123; Test a = new Test(); a = null; &#125;&#125; 常量 instance 指向的对象并不会因为 a 指向的对象被回收而回收 本地方法栈中的 JNI 引用的对象 所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。 当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。 标记清除算法步骤： 先根据可达性算法 标记 出相应的可回收对象 对可回收对象进行回收 操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –&gt; 内存碎片 假如我们想在内存中分配一块需要连续内存占用的 4M 或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。 复制算法把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。 问题： 比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。 标记整理法步骤： 先根据可达性算法 标记 出相应的可回收对象 对可回收对象进行回收 将所有存活对象都往一端移动，紧邻排列。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2F%E9%80%82%E9%85%8D%2FAndroid%20%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[为什么要适配由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。 尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。 基本概念屏幕尺寸屏幕尺寸指 屏幕对角线的长度，单位是 英寸，一英寸 = 2.54 厘米 常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多 屏幕分辨率屏幕分辨率是指在 横纵方向上的像素点数，单位是 px ，1px = 1个像素点。 一般以 纵向像素 横向像素，如 1920 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。 单位: px(pixel) ，1 px = 1像素点 Android 手机常见的分辨率： 320 480 480 800 720 1280 1080 1920 UI 设计图一般会以 px 作为统一的计量单位 屏幕像素密度屏幕像素密度是指 每英寸上的像素点， 单位是 dpi, 即 “dot per inch” 的缩写。 屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch 假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi Android 手机对每类手机屏幕大小都有一个相应的屏幕像素密度 密度类型 代表的分辨率 px 屏幕像素密度 dpi 低密度（ldpi） 240 * 320 120 中密度（mdpi） 320 * 480 160 高密度（hdpi） 480 * 800 240 超高密度（xhdpi） 720 * 1280 320 超超高密度（xxhdpi） 1080 * 1920 480 屏幕尺寸、分辨率、像素密度三者关系一部手机的分辨率是 宽 x 高， 屏幕大小是以寸为单位，三者关系为: 密度 dp = 像素 px / 屏幕大小 inch 密度（dpi） = $\frac {\sqrt{宽^2 + 高^2}}{屏幕大小} $ 密度即每英寸的像素点 勾股定理求出手机的对角线物理尺寸 再储以屏幕大小即可 密度无关像素density-independent pixel 叫做 dp 或 dip ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。 Android 开发时用 dp 而不是 px 单位设置图片大小，是 Android 特有的单位 场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 800 分辨率的设备上应为 240 px. 在 320 480 的设备上设置为 160 px。 如果使用 dp 为单位，在两种分辨率下， 160dp 都显示为屏幕一半的长度。 dp 与 px 的转换px = dp * (dpi / 160) 密度类型 代表的分辨率 px 屏幕密度 dpi 换算（px/dp) 比例 低密度 ldpi 240 x 320 120 1dp = 0.75px 3 中密度 mdpi 320 x 480 160 1dp = 1px 4 高密度 hdpi 480 x 800 240 1dp = 1.5px 6 超高密度 xhdpi 720 x 1280 320 1dp = 2px 8 超超高密度 xxhdpi 1080 x 1920 480 1dp = 3px 12 在 Android 中，规定 以 160dpi 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px 独立比例像素sp, scale-independent pixels, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。 解决方案使用备用布局-使用限定符 尺寸限定符 使用最小宽度限定符 布局别名 屏幕方向限定符 最小宽度限定符： 通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。 创建可拉抻的九宫格位图九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。 布局选择 线性布局（LinearLayout) 相对布局（RelativeLayout） 帧布局（FrameLayout） 绝对布局（AbsoluteLayout） 约束布局（ConstraintLayout） 使用自适应尺寸 wrap_content match_parent weight dp 不要使用 px 百分比适配 以某一分辨率为基准，生成所有分辨率对应像素数列表 将生成像素数列表存放在 res 目录下对应的 value 文件下 根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以 使用约束布局ConstraintLayout 今日头条适配方案px 值 = dp 值 * metrics.density 这里的 density 是手机的屏幕密度，由系统提供。不同的手机的 density 不同，所以我们不能直接使用系统的。]]></content>
      <tags>
        <tag>Android 适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 版本适配]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2F%E9%80%82%E9%85%8D%2FAndroid%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[基本知识targetSdkVersiontargetSdkVersion： 目标 SDK 版本，也就是我们最高适配的 SDK 版本 不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。 旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 ctx.getApplicatioinInfo().targetSdkVersion() 的判断，因此只要 APK 的 targetSdkVersion 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。 compileSdkVersioncompileSdkVersion 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 在编译的时候检查代码的错误和警告，提示开发者修改和优化 minSdkVersionminSdkVersion: 最小 SDK 版本，也就是我们最低支持的 SDK 版本 告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK 默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。 如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种 运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用 123if(android.os.Build.VERSION_SDK_INIT &gt;= Build.VERSION_CODES.M) &#123; // 处理逻辑&#125; 保证功能的完整性，通过低版本的 API 实现功能 Android 6.0 适配运行时权限请求从 Android 6.0(api &gt;= 23) 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种 正常权限。在 AndroidManifest 列出了正常权限，系统将自动授予该权限 危险权限。在 AndroidManifest 中列出了危险权限，用户必须明确批准您的应用使用这些权限。 Android 7.0 适配应用间共享文件限制在 Android 7.0 系统上， Android 框架强制执行了 ScrictMode API 政策，禁止向应用外公开 file://URI 如果一项包含文件 file://URI 类型的 Intent 离开了你的应用，即调用 Uri.from(file) 传递文件路径给第三方应用，会出现 FileUriExposedException 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。 如果要在 应用见共享文件 ，可以发送 content://URI类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 FileProvider 类 步骤如下： 在 AndroidManifest.xml 清单文件中注册 provider 123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.demo.***.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_provider_paths"/&gt;&lt;/provider&gt; export 为 false grantUriPermissions 表示授予 URI 临时访问权限 指定共享目录 上面的 android:resource=&quot;@xml/file_provider_paths&quot; 指定了共享的目录，配置如下： 1234567891011121314151617181920212223242526&lt;path xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- 代表设备的根目录 new File("/") --&gt; &lt;root-path name="root" path="."/&gt; &lt;!-- 代表 content.getFilesDir()--&gt; &lt;files-path name="captured_media" path="captrued_media"/&gt; &lt;!-- 代表 content.getCacheDir() --&gt; &lt;cache-path name="cache" path="appCache"/&gt; &lt;!-- 代表 Environment.getExtrnalStorageDirectory() --&gt; &lt;external-path name="data" path="Android"/&gt; &lt;!-- 代表 content.getExternalFilesDirs()--&gt; &lt;external-files-path name="external" path=""/&gt; &lt;!-- 代表 getExternalCacheDirs() --&gt; &lt;external-cache-path name="external" path=""/&gt;&lt;/path&gt; 通过 `FileProvider` 打开下载完的 APK 实例 123456789101112131415161718192021public static Intent getOpenFileIntent(Context context, DownloadResponse downloadReponse) &#123; File file = new File(downloadResponse.getParentPath(), downloadResponse.getFileName()); if(!file.exists()) &#123; return null; &#125; Intent intent = new Intent(); intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(Intent.ACTION_VIEW); if(Build.VERSION.SDK_INI &gt;= Build.VERSION_CODES.N) &#123; intent.setFlag(Intern.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context, "com.demo.***.provider"， file); intent.setDataAndType(contentUri, downloadResponse.getMimeType()); &#125; else &#123; intent.setDataAndType(Uri.fromFile(file), downloadResponse.getMimeType()); &#125; if(!context instanceof Activity) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; return intent; &#125; 系统广播删除Android N 管理了三项系统广播:网络状态变更广播、拍照广播 和 录像广播 只有通过 动态注册 的方式才能收到网络变化的广播， 在 AndroidManifest.xml 中静态注册的无法收到 Android 8.0 适配通知渠道在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示 123456789DownloadNotifier(Context context) &#123; mContext = context; mManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODE.O) &#123; @SuppressWarings("all") final NotificationChanncl channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotifationManager.IMPORTANCE_HIGH); mManager.createNotificationChannel(channel) &#125;&#125; 悬浮窗（工具类 APP 使用）8.0 新增了一种悬浮窗的窗口类型， TYPE_APPLICATION_OVERLAY, 如果应用使用 SYSTEM_ALERT_WINDOW 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 TYPE_APPLICATION_OVERLAY 窗口类型的下方 TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR TYPE_TOAST 如果该应用的 targetSdkVersion &gt;= 26 ,则应用只能使用 TYPE_APPLICATION_OVERLAY 窗口类型来创建悬浮窗。 12345if (Build.VERSION.SDK_INT &gt;= 26) &#123;//8.0新特性 mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;&#125; else &#123; mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;&#125; 透明窗口不允许锁定屏幕旋转之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏 12345&lt;activity android:name=".HomeActivity" android:configChanges="orientation|keyboardHidden|screenSize" android:screenOrientation="portrait" android:theme="@styple/Base.Theme.CirclePage"/&gt; 透明窗口+固定屏幕方向 会抛出异常 1Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation 解决方案有两种： 适配横屏，去掉固定屏幕方向的限制 仅在滑动开始的时候设置窗口透明 Apk 安装需要权限在安装 APK 是需要申请安装权限 REQUEST_INSTALL_PACKAGES Android 9.0 适配明文 HTTP 请求限制9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止 在 res/xml 文件夹啊下常见 network_security_config.xml 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true"/&gt;&lt;/network-security-config&gt; 在 AndroidManifest.xml 的 &lt;application 标签下配置 123&lt;application android:networkSecurityConfig="@xml/network_security_config"&gt;&lt;/application&gt; 或者是改用 HTTPS 方式请求 Android 10.0 适配分区存储如果还没有准备好适配的功能，可以在 AndroidManifest.xml 中添加 requestLegacyExternalStorage 来暂时处理 12&lt;application android:requestLegacyExternalStorage="true"/&gt; Android Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。 沙盒就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) 中 适配： 访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 权限，丙炔无需特定权限，就可以访问沙盒中的文件。 访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO，时期内那个方法同原来的存储权限 访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件 访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件， 设备唯一标识符访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 READ_PRIVILEGED_PHONE_STATE 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 READ_PHONE_STATE 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID 1((TelephonyManager)getActivity().getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId(); 但是，上面的代码会返回空值（targetASdkVersion &lt;= P）或者报错(targetSdkVersion == Q) ，且官网所说的 READ_PRIVILEGED_PHONE_STATE 权限只提供给系统 app，所以这个方法行不通 Google 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。 12345678910111213141516171819202122232425public static String getUUID() &#123; String serial = null; String m_szDevIdShort = "35" + Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10 + Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 + Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 + Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 + Build.TAGS.length() % 10 + Build.TYPE.length() % 10 + Build.USER.length() % 10; //13 位 try &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; serial = android.os.Build.getSerial(); &#125; else &#123; serial = Build.SERIAL; &#125; //API&gt;=9 使用serial号 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString(); &#125; catch (Exception exception) &#123; //serial需要一个初始化 serial = "serial"; // 随便一个初始化 &#125; //使用硬件信息拼凑出来的15位号码 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();&#125; 非 SDK 接口限制为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。 非 SDK 接口 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 target &gt;= P 或者 target &gt;= Q 的设备上被限制使用。]]></content>
      <tags>
        <tag>Android 适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 ViewGroup]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2FView%2F%E8%87%AA%E5%AE%9A%E4%B9%89%20ViewGroup%2F</url>
    <content type="text"><![CDATA[View Group 的测量布局流程View Group绘制和布局流程中的重点 View 在 onMeasure 方法中进行自我测量和保存。 ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置 关注 onMeasure 和 onLayout 父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View 自定义 View/ViewGroup，只需要关注下面三种需求： 对于已有的 Android 自带 View，我们只需要重写他的 onMeasure 方法即可,修改一下这个尺寸就完成需求 对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 onMeasure 需要重写 onMeasure 和 onLayout 2个方法，来完成一个复杂的 ViewGroup 的测量和布局。 onMeasure 的说明 widthMeasureSpec, heightMeasureSpec 两个参数主要是 父 view 对子view 的尺寸限制 理解父 view 对子 view 的限制 实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。这些以 layout 开头的属性，都是设置给父 view 看的 父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制 自定义 BannerView123456789101112131415161718192021222324252627public class BannerImageView extends ImageView&#123; // 宽高比 float ratio; public BannerImageView(Context context) &#123; super(context); &#125; public BannerImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.BannerImageView); ratio = array.getFloat(R.styleable.BannerImageView_ratio, 1.0f); array.recycle(); &#125; @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 自己的测量走一遍，因为这个方法内部会调用 setMEasureDimension() 来保存测量结果 // 只有保存了以后，才能取得这个测量结果，否则获取不到 super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 获取测量结果 int tempWidth = getMeasureWidth(); int tempHeight = (int) (tempWidth * ratio); // 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的 setMeasureDimension(tempWidth, tempHeight); &#125;&#125; 自定义 View ，完全自己写 onMeasure 方法对于完全自定义 View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 resolveSize 方法即可。 123456789101112131415161718192021public static int resolveSizeAndState(int size, int measureSpec, int childMeasureState) &#123; final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch(specMode) &#123; case MeasureSpce.AT_MOST: if(specSize &lt; size) &#123; result = specSize | MEASURED_STATE_TOO_SMALL; &#125; else &#123; result = size; &#125; break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; &#125; return result | (childMeasureState * MEASURED_STATE_MASK);&#125; 完全自定义 view onMeasure 方法： 先算自己想要的宽高 直接拿 resolveSize 方法处理一下 最后 setMeasuredDimension 保存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LoadingView extends View &#123; // 圆的半径 int radius; // 外部矩形的起点 int left = 10, top = 30; Paint mPaint = new Paint(); public LoadingView(Context context) &#123; super(context); &#125; public LoadingView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LoadingView); radius = typedArray.getInt(R.styleable.LoadingView_radius, 0); &#125; @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = left + radius * 2; int height = top + radius * 2; // 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug // 不用这个，就完全没有父 View 的感受 width = resolveSize(width, widthMeasureSpec); height = resolveSize(height, heightMeasureSpec); setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画矩形 RectF oval = new Rectf(left, top ,left + radius * 2, top + radius * 2); mPaint.setColor(Color.BLUE); canvas.drawRect(oval, mPaint); // 画圆弧 mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(2); canvas.drawArc(oval, -90, 360, false, mPaint); &#125;&#125; 自定义 ViewGroup注意以下几点： 一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局 ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用 measureChild() 这个方法 计算出 View Group 自己的尺寸并保存，onMeasuredDinmension 逼不得已需要重写measureChild 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 measureChild 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 从左到右布局，如果不够放，就直接另起一行layout */public class SimpleFlowLayout extends ViewGroup &#123; public SimpleFlowLayout(Context context) &#123; super(context); &#125; public SimpleFlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * layout 算法，就是不够放，就另外放一行 * * 无非就是前面 onMeasure 结束以后，你可以拿到所有子 View和自己的测量宽高， */ @Override public void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childTop = 0; int childLeft = 0; int childRight = 0; int childBottom = 0; // 已使用的 width int usedWidth = 0; // customlayout 自己可使用的宽度 int layoutWidth = getMeasuredWidth(); for(int i = 0; i &lt; getChildCount(); i++) &#123; View childView = getChildAt(i); // 取得这个子 View 要求的宽度和高度 int childWidth = childView.getMeasuredWidth(); int childHeight = childView.getMeasuredHeight(); // 如果宽度不够，就另外启动一行 if(layoutWidth - usedWidth &lt; childWidth) &#123; childLeft = 0; usedWidth = 0; childTop += childHeight; childBottom = childTop + childHeight; childView.layout(0, childTop, childRight, childBottom); usedWidth = usedWidth + childWidth; childLeft = childWidth; continue; &#125; childRight = childLeft + childWidth; childBottom = childTop + childHeight; childView.layout(childLeft, childTop, childRight, childBottom); childLeft += childWidth; usedWidth += childWidth; &#125; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 先取出 SimpleFlowLayout 的父 View 对他的测量限制 // 只有知道了自己的宽高，才能限制子 View 的宽高 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int usedWidth = 0; // 已使用宽度 int remaining = 0; // 剩余可用宽度 int totalHeight = 0; // 总高度 int lineHeight = 0; // 当前行高 for(int i = 0; i&lt; getChildCount(); i++) &#123; View childView = getChildAt(i); LayoutParams lp = childView.getLayoutParams(); // 先测量子View measureChild(childView, widthMeasureSpec, heightMeasureSpec); // 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度 remaining = widthSize - usedWidth; // 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行 if(childView.getMeasuredWidth &gt; remaining) &#123; // 另外启动一行 usedWidth = 0; totalHeight += lineHeight; &#125; // 已使用 width 进行累加 usedWidth += childView.getMeasuredWidth(); // 当前 view 的高度 lineHeight = childView.getMeasuredHeight(); &#125; // 如果 SimpleFlowLayout 的高度为 wrap_content 的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度 if(heightMode == MeasureSpec.AT_MOST) &#123; heightSize = totalHeight; &#125; setMeasuredDimension(widthSize, heightSize); &#125;&#125;]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 消息机制]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2F%E5%8E%9F%E7%90%86%2FHandler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Handler 消息机制，在整个 Android 系统中，有着很重要的地位。 他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App. 本文旨在对源码进行预览分析。 UML 类图先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 Handler 机制的核心秘密。 类图分析从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类 Message： 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。 Handler: 这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用 Looper: 这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的大心脏 ActivityThread看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 main() 方法中。 在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了 application 和 activity 的工作,接下来我们看一下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format "seq=114" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 通过上面的代码，我主要分析 Looper.prepareMainLooper() 和 Looper.loop() LooperLooper.prepare()这里的标题虽然不是 prepareMainLooper() 的一个主要原因是他们的核心内容是一样的，只不过，prepareMainLooper() 是系统帮我们创建了要给不可退出的Looper，而 prepare() 方法创建的 Looper 是可以退出的。 12345678910111213141516171819202122232425262728293031/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125;/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; ThreadLocal说到 Looper 的创建工作，这里就需要讲一下 ThreadLocal ， 它的意思是帮助我们在自己线程中保存一份它自己的本地变量 12@UnsupportedAppUsagestatic final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。 面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。 loop()继续看源码，Looper.loop(); 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行 这部分的源码比较长，捡主要的看和说： 1234567891011121314151617181920212223242526272829/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; //.............. final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; //.............. try &#123; msg.target.dispatchMessage(msg); &#125; catch (Exception exception) &#123; throw exception; &#125; finally &#123; &#125; // ............... msg.recycleUnchecked(); &#125;&#125; ActivityThread 中的 main() 方法，在最后一行，执行了我们的 Looper.loop() 方法， 进入后，我们可以看到 loop() 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 prepareMainLooper() ，这也是系统帮我们创建的一个主线程main 。 接下来就慢慢分析一下 loop 都做了什么事情 从流程图上，我们简述了一下 loop() 方法，都做了些什么事情，下面就展开讲都做了什么 首先获取当前线程的 looper 对象，如果不存在，则抛出异常 接着获取当前 Looper 绑定的消息队列MessageQueue 进入循环，开始获取消息 queue.next() 调用 msg.target.dispathMessage(msg) 分发消息 msg.recycleUnchecked() Handler作用： Handler 暴露给开发这的功能一共就两块 发送消息 处理消息 发送消息 sendMessage(Message msg) sendMessageEmpty() sendMessageAtTime(Message msg, long uptimeMillis) sendMessageDelay(Message msg, long delay) post(Runnable r) … 所有的发送消息的方法，最终都会去执行sendMessageAtTime(Message msg, long uptimeMillis), 当我们创建一个Handler 对象时, 会从当前线程的 Looper 中获取当前的消息队列mQueue 1234567891011121314151617181920public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 当我们开始发送一条消息时，调用 sendMessageAtTime ，会将消息压入到消息队列中， 1234567891011121314151617181920212223final MessageQueue mQueue;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 通过源码我们看到，在压入队列前，我们会将当前的 Handler 对象赋值给 Message 中的 target ，这也就是为什么 message 中会持有 Handler 的引用的原因。 处理消息在说处理消息之前，我们先看一下 Handler 对消息的分发 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 当我们给 Message 设置了 callback 时，会直接触发 Message 的 callback 逻辑 如果我们在创建 Handler 时，有设置过 Callback ，则会调用由我们传入进来的 Callback 方法 如果以上两种情况都没有设置，那么会触发 Handler 自己 handleMessage() 方法 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(@NonNull Message msg) &#123; &#125; 通过源码的注解我们可以看出，当我们继承/创建一个 Handler 时，需要我们必须去实现的一个方法（前提是你需要它） dispatchMessage 最终时由 loop() 方法在拿取消息队列中的信息时，获取到 Message 对象， 通过 Message 持有的 target 调用。 移除消息这里我们需要注意，当我们使用 Handler 处理消息时，通常都是一些异步任务，这时创建 Handler 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 Activity 无法被回收的情况。处理这种情况的方案就是，在 Activity 销毁时，我们需要将 Handler 中的消息进行释放 123public final void removeCallbacksAndMessages(@Nullable Object token) &#123; mQueue.removeCallbacksAndMessages(this, token);&#125; Message一种消息的载体，其中包含 handler 对象和一个任意类型的对象以及两个 int 型的参数 12345678910111213141516171819202122232425public final class Message implements Parcelable &#123; /** * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 */ public int what; /** * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销 */ public int arg1; /** * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销 */ public int arg2; /** * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) */ public Object obj; /** * 消息的执行时间 */ public long when;&#125; Message 本身是一个链表 的数据结构，这种数据结构，在MessageQueue 中获取消息时，可以有效的针对 Handler 发送进来的消息进行排序。 123456789@UnsupportedAppUsage/*package*/ Handler target;@UnsupportedAppUsage/*package*/ Runnable callback;// sometimes we store linked lists of these things@UnsupportedAppUsage/*package*/ Message next; Message 持有了一个 Handler 对象，因此即使我们在同一个线程里面创建了多个 Handler 的对象， 也不会出现消息错乱的现象。 Callback 同时 Message 也支持设置 Callback 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。 构造器1234567891011121314151617181920212223 private static Message sPool; private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50; /** Constructor (but the preferred way to get a Message is to call &#123;@link #obtain() Message.obtain()&#125;). */ public Message() &#123; &#125;public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; Message 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 obtain() 函数去获取。通过 obtain() 函数我们可以看出， Message 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 Message 对象时，反而是增加了系统的内存开销，而 Message 为我们提供的利器得不到发挥。 回收12345678910public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return; &#125; recycleUnchecked();&#125; 当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 Message 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。 MessageQueue存放所有消息的容器，既然是 Queue 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 Looper 关联的 Handler 添加 入队由 Handler 触发，将数据压入到队列中 12345678910111213141516171819202122232425262728293031323334353637383940boolean enqueueMessage(Message msg, long when) &#123; synchronized (this) &#123; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 通过源码看出，在消息压入队列中时，发生了排序操作， 当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 Message 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。 出队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Message next() &#123; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 为到执行时间，设置下一次系统唤醒消息需要的时间 // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; // prevMsg ，即是同步消息， prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; &#125; &#125;&#125; 同步屏障一般是由系统发出，多数情况是用来处理View 的刷新，由ViewRootImpl 调用 postSyncBarrier，将消息插入到链表的头部，我们可以注意到 msg 的 target 对象为空，因为 每一个 Message 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。 1234567891011121314151617181920212223242526272829303132private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; // 创建一个同步消息 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; // 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间 while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next // 断开链表，将同步消息，插入到要立即执行的消息后面 msg.next = p; prev.next = msg; &#125; else &#123; // 没有要立即执行的消息，将同步消息插入到链表第一个节点 msg.next = p; mMessages = msg; &#125; return token; &#125; &#125; 当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，ViewRootImpl 会，并给 msg 的 target 重新赋值，优先执行。直到找到一个异步消息为止 当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。 退出由 loop 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收 123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125; &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 总结]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2FView%2FRecyclerView%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[List View 的局限性 只有纵向列表一种布局 没有支持动画的 API 接口设计和系统不一致 setOnItemClickListener() setOnItemLongClickListener() setSelection() 没有强制实现 ViewHolder 性能不如 RecyclerView RecyclerView 优势 默认支持 Linear、Grid、Staggered Grid 三种布局 友好的 ItemAnimator 动画 API 强制实现 ViewHolder 解耦的架构设计 相对 ListView 性能更好 Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示 ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给 RecyclerView LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成 Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误 ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡 RecyclerView 的绘制RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 onMeasure() onLayout() onDraw() onMeasureLayoutManager 负责 RecyclerView 的绘制，其有一个 mAutoMeasure 属性，用来控制是否开启自动测量，开启情况下，布局交由 RecyclerView 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 onMeasure 来处理自身的测量工作。 自动测量原理：当 RecyclerView 的宽高都为 EXACTLY 时， 可以直接设置对应的宽高，然后返回，结束测量 如果宽高都不时 EXACTLY 则会在 onMeasure 中开始布局的处理。 RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 mLayoutStep 记录了 RecyclerView 当前的布局状态 STEP_START STEP_LAYOUT STEP_ANIMATIONS 对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 dispatchLayoutStep1() 来执行第一步布局，结束后， mLayoutStep 变为 STEP_LAYOUT ，表示接下来需要调用 dispatchLayoutStep2() 进行布局，结束后 mLayoutStep 变为 STEP_ANIMATIONS, 继续执行第三步 dispatchLayoutStep3() dispatchLayoutStep1: 负责记录状态 dispatchLayoutStep2：负责布局 dispatchLayoutStep3：与 step1 比较，根据变化来触发动画 onLayout1234567891011121314151617181920212223242526protected void onLayout(boolean changed, int l int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; mState.mIsMeasuring = false; if(mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if(mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // first 2 steps are done in onMeasure but looks like we have to run again due to changed size mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 通过 dispatchLayout 可以验证RecyclerView 的 layout三步走原则，如果在 onMeasure 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 onLayout 中依次触发三步走。 dispatchLayoutStep11234567891011private void dispatchLayoutStep1()&#123; if(mState.mRunSimpleAnimations) &#123; int count = mChildHelper.getChildCount(); for(int i = 0; i &lt; count; i++) &#123; final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); mViewInfoStore.addToPreLayout(holder, animationInfo); &#125; &#125; mState.mLayoutStep = State.STEP_LAYOUT&#125; step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变 dispatchLayoutStep212345private void dispatchLayoutStep2()&#123; mLayout.onLayoutChildren(mRecycler, mState); mState.mLayoutStep = State.STATE_ANIMATIONS;&#125; layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。 1234567891011121314151617181920212223242526272829303132public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if(!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) &#123; updateAnchorInfoForLayout(recycler, state, mAnchorInfo); &#125; if(mAnchorInfo.mLayoutFromEnd) &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTIONTAIL : LayoutState.ITEM_DIRECTION_HEAD; &#125; else &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; &#125; onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); if(mAnchorInfo.mLayoutFromEnd) &#123; &#125; else &#123; // fill towards end updateLayouStateToFillEnd(mAnchorInfo); fill(recycler, mLayoutState, state, false); // fill towards start updateLayoutStateToFillStart(mAnchorInfo); fill(recycler, mLayoutState, state, false); &#125;&#125; 流程很负责，大致流程如下 找到 anchor点 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域 anchor 点的寻找是由 updateAnchorInfoForLayout 函数负责。向下追踪会看到 updateAnchorFromChildren 方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 anchorInfo 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。 继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成 1234567891011121314int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) &#123; final int start = layoutState.mAvailable; if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; recycleByLayoutState(recycler, layoutState); &#125; int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; while((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult); &#125; return start-layoutState.mAvailable;&#125; recycleByLayoutState 这个函数，会根据当前信息对不需要的 View 进行回收: 1234567private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123; if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; &#125; else &#123; recycleViewsFromStart(recycler, layoutState.mScrollingOffset); &#125;&#125; 继续看 recycleViewsFromStart 12345678910111213141516private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt)&#123; final int limit = dt; final int childCount = getChildCount(); if(mShouldReverseLayout) &#123; &#125; else &#123; for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); if(mOrientationHelper.getDecoratedEnd(child) &gt; limit || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123; recycleChildren(recycler, 0, i); return; &#125; &#125; &#125;&#125; 该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 recycleChildren 里，而这函数又调用了 removeAndRecycleViewAt 12345public void removeAndRecycleViewAt(int index, Recycler recycler) &#123; final View view = getChildAt(index); removeViewAt(index); recycler.recycleView(view);&#125; 该函数先调用 removeViewAt ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。 1234while((layoutState.mInfinite || remainningSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult);&#125; 只要又剩余空间，就会执行 layoutChunk 方法 12345678910111213141516void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)&#123; View view = layoutState.next(recycler); LayoutParams params = (LayoutParams) view.getLayoutParams(); if(layoutState.mScrapList == null) &#123; if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; &#125; layoutDecoratedWithMargins(view, left, top, right, bottom);&#125; 在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇 1234View next(RecyclerView.Recycler recycler ) &#123; final View view = recycler.getViewForPosition(mCurrentPosition); return view;&#125; 可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。 我们在看 layoutChunk 对刚刚生成的 View 的处理 12345if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123; addView(view);&#125; else &#123; addView(view, 0);&#125; 明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。 dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局 dispatchLayoutStep3最后一步 1234567891011private void dispatchLayoutStep3()&#123; mState.mLayoutStep = State.STEP_START; if(mState.mRunSimpleAnimations) &#123; for(int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder); mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; mViewInfoStore.process(mViewInfoProcessCallback); &#125;&#125; 这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法， 12345678void addToPostLayout(ViewHolder holder, ItemHolderInfo info) &#123; InfoRecord record = mLayoutHolderMap.get(holder); if(record == null ) &#123; record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); &#125; record.postInfo = info;record.flags |= FLAT_POST;&#125; 最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。 缓存逻辑缓存共分为四层 Scrap 内存缓存 Cache 内存缓存 ViewCacheExtension 用户自定义缓存 Recycled View Pool 缓存池 RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解， 12345678910111213141516171819202122232425262728293031323334353637383940414243View getViewForPosition(int position, boolean dryRun) &#123; boolean fromScrap = false; ViewHolder holder = null; if(mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrap = holder != null &#125; if(hoder == null) &#123; hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun); &#125; if(holder == null )&#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); final int type = mAdapter.getItemViewType(offsetPosition); if(mAdapter.hasStableIds())&#123; holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); &#125; if(holder == null &amp;&amp; mViewCacheExtension != null) &#123; final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); &#125; if(holder == null) &#123; // fallback to recycler holder = getRecyclerViewPool().getRecyclerView(type); if(holder != null)&#123; holder.resetInternal(); if(FORCE_INVALIDATE_DISPLAY_LIST)&#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if(holder == null )&#123; holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; // 生成 LayoutParams 的代码 return holder.itemView;&#125; 获取 View 的逻辑可以整理为 搜索 mChangedScrap， 如果找到则返回相应的 holder 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder 搜索 mRecyclerPool, 如果找到则返回 Holder 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例 对于 View 的回收 12345678910111213141516171819202122void recycleViewHolderInternal(ViewHolder holder ) &#123; if(holder.isRecyclable()) &#123; if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123; int cachedViewSize = mCachedViews.size(); if(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; if(cachedViewSize &lt; mViewCacheMax) &#123; mCachedViews.add(holder); cached = true; &#125; &#125; if(!cached) &#123; addViewHolderToRecycledViewPool(holder); recycled = true; &#125; &#125;&#125; 回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView 则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool 时可以多个 RecyclerView 共享的。 与 AdapterView 比较 index AdapterView RecyclerView 1 Simple click listener OnItemTouchListener 2 Simple Divider ItemDecoration 3 ListView and GridView LinearLayoutManagerGridLayoutManager 4 RecyclerBin Recycler 5 Header and Footer Partial refresh 点击事件ListView 原生提供了Item 点击、长安的事件，而 RecyclerView 则需要使用 onTouchListener 相对比较复杂 分割线ListView 可以很轻松设施 Divider 属性来显示 item 之间的分割线， RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强 布局类型AdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager ListView 只提供了一种 LinearLayoutManager 方式 性能优化 RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作 ListView 不支持单个 Item 的刷新，只能整个列表进行 notifyDataSetChanged ， RecyclerView 提供了 itemChange, ItemInsert, ItemRemoved 等方法，减少了 性能的开销]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2FView%2FAndroid%20%E8%87%AA%E5%AE%9A%E4%B9%89%20View%2F</url>
    <content type="text"><![CDATA[[TOC] 概述Android开发进阶的必经之路为什么要自定义View自定义View的基本方法自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。 测量：onMeasure()决定View的大小； 布局：onLayout()决定View在ViewGroup中的位置； 绘制：onDraw()决定绘制这个View。 自定义控件分类 自定义View: 只需要重写onMeasure()和onDraw() 自定义ViewGroup: 则只需要重写onMeasure()和onLayout() 自定义View基础View的分类视图View主要分为两类 类别 解释 特点 单一视图 即一个View，如TextView 不包含子View 视图组 即多个View组成的ViewGroup，如LinearLayout 包含子View View类简介 View类是Android中各种组件的基类，如View是ViewGroup基类 View表现为显示在屏幕上的各种视图 Android中的UI组件都由View、ViewGroup组成。 View的构造函数：共有4个 12345678910111213141516171819202122232425// 如果View是在Java代码里面new的，则调用第一个构造函数 public CarsonView(Context context) &#123; super(context); &#125;// 如果View是在.xml里声明的，则调用第二个构造函数// 自定义属性是从AttributeSet参数传进来的 public CarsonView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;// 不会自动调用// 一般是在第二个构造函数里主动调用// 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //API21之后才使用 // 不会自动调用 // 一般是在第二个构造函数里主动调用 // 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); &#125; AttributeSet与自定义属性 系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤： 通过123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657582. 在xml中为相应的属性声明属性值3. 在运行时（一般为构造函数）获取属性值4. 将获取到的属性值应用到View### View视图结构1. PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个2. DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout3. ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等![activity](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png)对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：![view_arch](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png)一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。### Android坐标系Android的坐标系定义为：- 屏幕的左上角为坐标原点- 向右为x轴增大方向- 向下为y轴增大方向 ![zuobiaoxi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png)&gt; 区别于一般的数学坐标系&gt; ![zuobiaoxi_qubie](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png)### View位置（坐标）描述View的位置由4个顶点决定的4个顶点的位置描述分别由4个值决定：&gt; 请记住：View的位置是相对于父控件而言的）- Top：子View上边界到父view上边界的距离- Left：子View左边界到父view左边界的距离- Bottom：子View下边距到父View上边界的距离- Right：子View右边界到父view左边界的距离### 位置获取方式View的位置是通过view.getxxx()函数进行获取：（以Top为例）```java// 获取Top位置public final int getTop() &#123; return mTop; &#125; // 其余如下： getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离 与MotionEvent中 get()和getRaw()的区别 1234567//get() ：触摸点相对于其所在组件坐标系的坐标 event.getX(); event.getY();//getRaw() ：触摸点相对于屏幕默认坐标系的坐标 event.getRawX(); event.getRawY(); Android中颜色相关内容Android支持的颜色模式： 以ARGB8888为例介绍颜色定义: View树的绘制流程View树的绘制流程是谁负责的？view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。 123456789private void performTraversals() &#123; ..... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ..... performLayout(lp, mWidth, mHeight); ..... performDraw(); ..... &#125; view的添加 view的绘制流程 measure 系统为什么要有measure过程？ 1234&lt;TextView android:layout_width="wrap_content" android:layout_height="match_parent" android:text="Hello World!" /&gt; 谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。 measure过程都干了点什么事？ 对于自适应的尺寸机制，如何合理的测量一颗View树？ 那么ViewGroup是如何向子View传递限制信息的？ ScrollView嵌套ListView问题？ layout 系统为什么要有layout过程？ layout过程都干了点什么事？ draw 系统为什么要有draw过程？ draw过程都干了点什么事？ LayoutParamsayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。 事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类 MarginLayoutParamsMarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的 属性优先级问题MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级 margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin 属性覆盖问题优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释 Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value LayoutParams与View如何建立联系 在XML中定义View 在Java代码中直接生成View对应的实例对象 addView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 重载方法1：添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams */public void addView(View child) &#123; addView(child, -1);&#125;/** * 重载方法2：在指定位置添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾） */public void addView(View child, int index) &#123; if (child == null) &#123; throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup"); &#125; LayoutParams params = child.getLayoutParams(); if (params == null) &#123; params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams if (params == null) &#123; throw new IllegalArgumentException("generateDefaultLayoutParams() cannot return null"); &#125; &#125; addView(child, index, params);&#125;/** * 重载方法3：添加一个子View * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height */public void addView(View child, int width, int height) &#123; final LayoutParams params = generateDefaultLayoutParams(); // 生成当前ViewGroup默认的LayoutParams params.width = width; params.height = height; addView(child, -1, params);&#125;/** * 重载方法4：添加一个子View，并使用传入的LayoutParams */@Overridepublic void addView(View child, LayoutParams params) &#123; addView(child, -1, params);&#125;/** * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams */public void addView(View child, int index, LayoutParams params) &#123; if (child == null) &#123; throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);&#125;private void addViewInner(View child, int index, LayoutParams params, boolean preventRequestLayout) &#123; ..... if (mTransition != null) &#123; mTransition.addChild(this, child); &#125; if (!checkLayoutParams(params)) &#123; // ① 检查传入的LayoutParams是否合法 params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作 &#125; if (preventRequestLayout) &#123; // ② 是否需要阻止重新执行布局流程 child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） &#125; else &#123; child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） &#125; if (index &lt; 0) &#123; index = mChildrenCount; &#125; addInArray(child, index); // tell our children if (preventRequestLayout) &#123; child.assignParent(this); &#125; else &#123; child.mParent = this; &#125; .....&#125; 自定义LayoutParams 创建自定义属性 12345678&lt;resources&gt; &lt;declare-styleable name="xxxViewGroup_Layout"&gt; &lt;!-- 自定义的属性 --&gt; &lt;attr name="layout_simple_attr" format="integer"/&gt; &lt;!-- 使用系统预置的属性 --&gt; &lt;attr name="android:layout_gravity"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 继承MarginLayout 1234567891011121314151617181920212223242526public static class LayoutParams extends ViewGroup.MarginLayoutParams &#123; public int simpleAttr; public int gravity; public LayoutParams(Context c, AttributeSet attrs) &#123; super(c, attrs); // 解析布局属性 TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout); simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0); gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1); typedArray.recycle();//释放资源 &#125; public LayoutParams(int width, int height) &#123; super(width, height); &#125; public LayoutParams(MarginLayoutParams source) &#123; super(source); &#125; public LayoutParams(ViewGroup.LayoutParams source) &#123; super(source); &#125;&#125; 重写ViewGroup中几个与LayoutParams相关的方法 1234567891011121314151617181920212223// 检查LayoutParams是否合法@Overrideprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123; return p instanceof SimpleViewGroup.LayoutParams;&#125;// 生成默认的LayoutParams@Overrideprotected ViewGroup.LayoutParams generateDefaultLayoutParams() &#123; return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);&#125;// 对传入的LayoutParams进行转化@Overrideprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123; return new SimpleViewGroup.LayoutParams(p);&#125;// 对传入的LayoutParams进行转化@Overridepublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new SimpleViewGroup.LayoutParams(getContext(), attrs);&#125; LayoutParams常见的子类在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类： ViewGroup.MarginLayoutParams FrameLayout.LayoutParams LinearLayout.LayoutParams RelativeLayout.LayoutParams RecyclerView.LayoutParams GridLayoutManager.LayoutParams StaggeredGridLayoutManager.LayoutParams ViewPager.LayoutParams WindowManager.LayoutParams MeasureSpec定义测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种： UNSPECIFIED不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到） EXACTLY精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。 AT_MOST当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位） 123456//获取尚未显示的view的宽和高int tempWidth =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);int tempHeight =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);view.measure(tempWidth,tempHeight);int realHeight=view.getMeasuredHeight(); int realWidth=view.getMeasuredWidth(); MeasureSpecs 的意义通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法 MeasureSpec值的确定MeasureSpec值到底是如何计算得来的呢? 对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里 12345private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; ... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...&#125; 具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下 1234567891011protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; //测量指定的View measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; 测量指定的View 1234567891011 protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams();//根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个 * 最可能符合条件的child view的测量规格。 * @param spec 父控件的测量规格 * @param padding 父控件里已经占用的大小 * @param childDimension child view布局LayoutParams里的尺寸 * @return child view 的测量规格 */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //父控件的测量模式 int specSize = MeasureSpec.getSize(spec); //父控件的测量大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了 case MeasureSpec.EXACTLY: //如果child的布局参数有固定值，比如"layout_width" = "100dp" //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; //如果child的布局参数是"match_parent"，也就是想要占满父控件 //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了 else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; //如果child的布局参数是"wrap_content"，也就是想要根据自己的逻辑决定自己大小， //比如TextView根据设置的字符串大小来决定自己的大小 //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛 //所以测量模式就是AT_MOST，测量大小就是父控件的size else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size case MeasureSpec.AT_MOST: //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求 if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小 //但同样的，child的尺寸上限也是父控件的尺寸上限size else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; //child想要根据自己逻辑决定大小，那就自己决定呗 else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 针对上表，这里再做一下具体的说明 对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定 对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。 1. 当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小； 2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间； 3. 当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。 4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。 View （ViewGroup）的measure方法 最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ...&#125; 12345@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //设置size setMeasuredDimension(1,1);&#125; 1234567onMeasure()//1. 测量自身//2. 为每个子View计算测量的限制信息 Mode / Size//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure//4. 获取子View测量完成后的尺寸//5. ViewGroup根据自身的情况，计算自己的尺寸//6. 保存自身的尺寸 123456onLayout()//1. 遍历子View for//2. 确定自己的规则//3. 获取子View的测量尺寸//4. 确定子View的left,top,right,bottom//6. 调用child.layout 简介：点、线、矩形、多边形、 弧、圆等。 Paint 2.1 常用属性 ​ mPaint.setARGB();//设置画笔的A、R、G、B值 ​ mPaint.setStyle();//设置画笔的风格(空心或实心) ​ mPaint.setColor();//设置画笔的颜色 ​ mPaint.setAlpha();//设置画笔的Alpha ​ mPaint.setAntiAlias();// 设置画笔的锯齿效果 ​ mPaint.setTextSize(); ​ mPaint.setStrokeWidth();//设置空心边框的宽度 2.2 常用style ​ Paint.Style.FILL //填充 ​ Paint.Style.STROKE//空心 2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 常用的画图方法 3.1 drawPoint(x,y,paint)//点 3.2 drawLine(startX,startY,endX,endY,paint)//线 3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线 3.4 drawRect(l,t,r,b,paint)//矩形 3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度 3.6 drawtCircle(circleX,circleY,radius，paint)//圆 3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线 3.8 drawOval(l,t,r,b,paint)//椭圆 3.9 drawText(text,startX，startY,paint)//文本 3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时 3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量 3.12 drawPath(path,paint)//画路径 4.Path的用法//http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html Canvas常用方法 5.1 save()//将已经绘制好的图像保存起来 5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用 5.3 restoreToCount// 5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y） 5.5 rotate()//将坐标系旋转一定的角度 5.6 drawColor()//设置画布的颜色]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WebView]]></title>
    <url>%2F2021%2F01%2F29%2FAndroid%20%E5%9F%BA%E7%A1%80%2FView%2FAndroid%20WebView%2F</url>
    <content type="text"><![CDATA[问题：为什么 WebView 的加载速度那么慢? js 解析效率 如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢 页面资源的下载 一般加载一个 H5 页面，都会产生比较多的网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢 那如何解决呢？对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑； 所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度 首先将一些资源文件放在本地的 assets 目录，然后重写 WebViewClient 的 shouldInterceptRequest(WebView view, String url) 和 shouleInterceptRequest(WebView view, WebResourceRequest request) 这两个方法，对访问地址进行拦截，当 url 地址命中本地配置的 url 时，使用本地资源替代，否则就使用网络上的资源。 12345678910111213141516171819202122232425262728293031323334mWebView.setWebViewClient(new WebViewClient() &#123; // 设置不使用系统浏览器打开，直接显示在当前 WebView @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125; @Override public WebResourceResponse shouldIntercepteReqeuest(WebView view, String url) &#123; // 如果命中本地资源，使用本地资源替代 if(mDataHelper.hasLocalResource(url))&#123; WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url); if(response != null) &#123; return response; &#125; &#125; return super.shouldInterceptRequest(view, url); &#125; // 兼容 5.0 以上的设备 @TargetApi(VERSION_CODE.LOLLIPOP) @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123; String url = request.getUrl().toString(); if(mDataHelper.hasLocalResource(url)) &#123; WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url); if(response != null) &#123; return response; &#125; &#125; return super.shouleInterceptRequest(view, request); &#125;&#125;); DataHelper 是一个工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DataHelper &#123; private Map&lt;String, String&gt; mMap; public DataHelper()&#123; mMap = new HashMap&lt;&gt;(); initData(); &#125; private void initData()&#123; String imageDir = "images/"; String pngSuffix = ".png"; mMap.put("http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8", "css/style.css"); mMap.put("http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png",imageDir + "cropped-ryg.png"); // ... &#125; public boolean hasLocalResource(String url) &#123; return mMap.containsKey(url); &#125; public WebResourceResponce getReplacedWebResourceResponse(Context context, String url) &#123; String localResourcePath = mMap.get(url); if(TextUtils.isEmpty(localResourcePath)) &#123; return null; &#125; InputStream is = null; try &#123; is = context.getApplicationContext().getAssets().open(localResourcePath); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; String mimeType; if(url.contans("css")) &#123; mimeType = "text/css"; &#125; else if (url.contains(".jpg")) &#123; mimeType = "image/jpeg"; &#125; else &#123; mimeType = "image/png"; &#125; WebResourceResponse response = new WebResourceResponse(mimeType, "utf-8", is); return response; &#125;&#125; WebView 的缓存在不配置本地资源的时候，我们第一次打开页面，产生了 n 多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。 我们观察到，这个请求的 response 的 headers 中的参数，Last-Modified,ETag, Expires, Cache-Control Cache-Control： 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 Http/1.1 标准中的字段。 Expires： 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 HTTP/1.0 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。 Last-Modified: 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。 ETag： ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。 常见用法是， Cache-Control 与 Last-Modified 一起使用， Expires 和 ETag 一起使用。但实际情况可能并不是这样 设置 WebView 使用这些内容 想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置） 12WebSettings settings = mWebView.getSettings();settings.setCacheMode(WebSettings.LOAD_DEFAULT); WebView 的 5 种缓存模式 LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据 LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式 LOAD_NO_CACHE： 不使用缓存，只从网络获取 LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取 在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。 WebView 的速度方案WebView 的初始化本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。 预加载数据就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘ 简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 shouleInterceptRequest 方法。 离线包离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。 资源： H5： 每个代码包都有一个唯一且递增的版本号 Native：提供包下载且解压资源文件到对应目录 服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址 流程： 前端更新代码打包后按版本号上传至指定的服务器上 每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包 客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Room]]></title>
    <url>%2F2021%2F01%2F04%2FAndroid-Room%2F</url>
    <content type="text"><![CDATA[Android Room翻译自官网文档 Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库 Database: 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder Entity: 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities 数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中 Dao: 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。 1234567891011121314151617181920212223242526272829303132333435363738// File: User.java@Entitypublic class User &#123; @PrimaryKey private int uid; private String name; @ColumnInfo(name = "last_name") private String lastName; // Room 请求 set 和 get 方法去访问数据&#125;// File: UserDao.java@Daopublic interface UserDao &#123; @Query("select * from user") List&lt;User&gt; loadAll(); @Query("select * from user where uid in (:userIds)") List&lt;User&gt; loadAllByUserId(int... userIds); @Query("select * from user where name like :first and last_name like :last limit 1") User loadOneByNameAndLastName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125;// File: AppDatabse.java@Database(entities = &#123;User.java&#125;)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125;// 创建 AppDatabase 实例AppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, "database_name").build(); 一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/ 可以通过使用 InvalidtaionTracker 类来观察一个数据表的变化。 Room 允许通过 Query 方法返回一个 LiveData 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 LiveData 的观察者 123// LiveData 会自动分发数据表的改变@Query("Select * from user order by name limit 5") public LiveData&lt;List&lt;User&gt;&gt; loadFirstFiveUsers();]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2F2020%2F07%2F09%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[RechclerView 总结 Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示 ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给 RecyclerView LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成 Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误 ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡 RecyclerView 的绘制RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 onMeasure() onLayout() onDraw() onMeasureLayoutManager 负责 RecyclerView 的绘制，其有一个 mAutoMeasure 属性，用来控制是否开启自动测量，开启情况下，布局交由 RecyclerView 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 onMeasure 来处理自身的测量工作。 自动测量原理： 当 RecyclerView 的宽高都为 EXACTLY 时， 可以直接设置对应的宽高，然后返回，结束测量 如果宽高都不时 EXACTLY 则会在 onMeasure 中开始布局的处理。 RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 mLayoutStep 记录了 RecyclerView 当前的布局状态 STEP_START STEP_LAYOUT STEP_ANIMATIONS 对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 dispatchLayoutStep1() 来执行第一步布局，结束后， mLayoutStep 变为 STEP_LAYOUT ，表示接下来需要调用 dispatchLayoutStep2() 进行布局，结束后 mLayoutStep 变为 STEP_ANIMATIONS, 继续执行第三步 dispatchLayoutStep3() dispatchLayoutStep1: 负责记录状态 dispatchLayoutStep2：负责布局 dispatchLayoutStep3：与 step1 比较，根据变化来触发动画 onLayout 1234567891011121314151617181920212223242526protected void onLayout(boolean changed, int l int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; mState.mIsMeasuring = false; if(mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if(mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // first 2 steps are done in onMeasure but looks like we have to run again due to changed size mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 通过 dispatchLayout 可以验证RecyclerView 的 layout三步走原则，如果在 onMeasure 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 onLayout 中依次触发三步走。 dispatchLayoutStep1 1234567891011private void dispatchLayoutStep1()&#123; if(mState.mRunSimpleAnimations) &#123; int count = mChildHelper.getChildCount(); for(int i = 0; i &lt; count; i++) &#123; final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); mViewInfoStore.addToPreLayout(holder, animationInfo); &#125; &#125; mState.mLayoutStep = State.STEP_LAYOUT&#125; step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变 dispatchLayoutStep2 12345private void dispatchLayoutStep2()&#123; mLayout.onLayoutChildren(mRecycler, mState); mState.mLayoutStep = State.STATE_ANIMATIONS;&#125; layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。 1234567891011121314151617181920212223242526272829303132public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if(!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) &#123; updateAnchorInfoForLayout(recycler, state, mAnchorInfo); &#125; if(mAnchorInfo.mLayoutFromEnd) &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTIONTAIL : LayoutState.ITEM_DIRECTION_HEAD; &#125; else &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; &#125; onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); if(mAnchorInfo.mLayoutFromEnd) &#123; &#125; else &#123; // fill towards end updateLayouStateToFillEnd(mAnchorInfo); fill(recycler, mLayoutState, state, false); // fill towards start updateLayoutStateToFillStart(mAnchorInfo); fill(recycler, mLayoutState, state, false); &#125;&#125; 流程很负责，大致流程如下 找到 anchor点 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域 anchor 点的寻找是由 updateAnchorInfoForLayout 函数负责。向下追踪会看到 updateAnchorFromChildren 方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 anchorInfo 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。 继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成 1234567891011121314int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) &#123; final int start = layoutState.mAvailable; if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; recycleByLayoutState(recycler, layoutState); &#125; int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; while((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult); &#125; return start-layoutState.mAvailable;&#125; recycleByLayoutState 这个函数，会根据当前信息对不需要的 View 进行回收: 1234567private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123; if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; &#125; else &#123; recycleViewsFromStart(recycler, layoutState.mScrollingOffset); &#125;&#125; 继续看 recycleViewsFromStart 12345678910111213141516private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt)&#123; final int limit = dt; final int childCount = getChildCount(); if(mShouldReverseLayout) &#123; &#125; else &#123; for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); if(mOrientationHelper.getDecoratedEnd(child) &gt; limit || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123; recycleChildren(recycler, 0, i); return; &#125; &#125; &#125;&#125; 该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 recycleChildren 里，而这函数又调用了 removeAndRecycleViewAt 12345public void removeAndRecycleViewAt(int index, Recycler recycler) &#123; final View view = getChildAt(index); removeViewAt(index); recycler.recycleView(view);&#125; 该函数先调用 removeViewAt ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。 1234while((layoutState.mInfinite || remainningSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult);&#125; 只要又剩余空间，就会执行 layoutChunk 方法 12345678910111213141516void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)&#123; View view = layoutState.next(recycler); LayoutParams params = (LayoutParams) view.getLayoutParams(); if(layoutState.mScrapList == null) &#123; if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; &#125; layoutDecoratedWithMargins(view, left, top, right, bottom);&#125; 在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇 1234View next(RecyclerView.Recycler recycler ) &#123; final View view = recycler.getViewForPosition(mCurrentPosition); return view;&#125; 可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。 我们在看 layoutChunk 对刚刚生成的 View 的处理 12345if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123; addView(view);&#125; else &#123; addView(view, 0);&#125; 明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。 dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局 dispatchLayoutStep3最后一步 1234567891011private void dispatchLayoutStep3()&#123; mState.mLayoutStep = State.STEP_START; if(mState.mRunSimpleAnimations) &#123; for(int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder); mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; mViewInfoStore.process(mViewInfoProcessCallback); &#125;&#125; 这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法， 12345678void addToPostLayout(ViewHolder holder, ItemHolderInfo info) &#123; InfoRecord record = mLayoutHolderMap.get(holder); if(record == null ) &#123; record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); &#125; record.postInfo = info;record.flags |= FLAT_POST;&#125; 最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。 缓存逻辑 RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解， 12345678910111213141516171819202122232425262728293031323334353637383940414243View getViewForPosition(int position, boolean dryRun) &#123; boolean fromScrap = false; ViewHolder holder = null; if(mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrap = holder != null &#125; if(hoder == null) &#123; hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun); &#125; if(holder == null )&#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); final int type = mAdapter.getItemViewType(offsetPosition); if(mAdapter.hasStableIds())&#123; holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); &#125; if(holder == null &amp;&amp; mViewCacheExtension != null) &#123; final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); &#125; if(holder == null) &#123; // fallback to recycler holder = getRecyclerViewPool().getRecyclerView(type); if(holder != null)&#123; holder.resetInternal(); if(FORCE_INVALIDATE_DISPLAY_LIST)&#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if(holder == null )&#123; holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; // 生成 LayoutParams 的代码 return holder.itemView;&#125; 获取 View 的逻辑可以整理为 搜索 mChangedScrap， 如果找到则返回相应的 holder 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder 搜索 mRecyclerPool, 如果找到则返回 Holder 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例 对于 View 的回收 12345678910111213141516171819202122void recycleViewHolderInternal(ViewHolder holder ) &#123; if(holder.isRecyclable()) &#123; if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123; int cachedViewSize = mCachedViews.size(); if(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; if(cachedViewSize &lt; mViewCacheMax) &#123; mCachedViews.add(holder); cached = true; &#125; &#125; if(!cached) &#123; addViewHolderToRecycledViewPool(holder); recycled = true; &#125; &#125;&#125; 回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView 则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool 时可以多个 RecyclerView 共享的。 与 AdapterView 比较 index AdapterView RecyclerView 1 Simple click listener OnItemTouchListener 2 Simple Divider ItemDecoration 3 ListView and GridView LinearLayoutManagerGridLayoutManager.. 4 RecyclerBin Recycler 5 Header and Footer Partial refresh 点击事件 ListView 原生提供了Item 点击、长安的事件，而 RecyclerView 则需要使用 onTouchListener 相对比较复杂 分割线 ListView 可以很轻松设施 Divider 属性来显示 item 之间的分割线， RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强 布局类型 AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。 缓存方式 ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致 不同点 局部刷新 ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 notifyItemChanged(position) 来完成，甚至可以通过 notifyItemChanged(position, payload) 传入一个 payload 信息来刷新单个 item 中的特定内容。 动画 RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难 嵌套布局 RecyclerView 实现了 NestedScrollingChild 接口，可以和一切嵌套组件很好的工作 ListView 原生特点 头部与尾部支持 ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、 多选 支持多选和单选的 ListView 更方便 多数据源支持 ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。 总结 RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Q 文件权限适配]]></title>
    <url>%2F2020%2F03%2F11%2FAndroid%20%E5%9F%BA%E7%A1%80%2F%E9%80%82%E9%85%8D%2FAndroid-Q-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。 “沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为Context.getExternalFilesDir() 下的文件夹。需要传入以下参数 1234567Environment.DIRECTORY_MUSICEnvironment.DIRECTORY_PODCASTSEnvironment.DIRECTORY_RINGTONESEnvironment.DIRECTORY_ALARMSEnvironment.DIRECTORY_NOTIFICATIONSEnvironment.DIRECTORY_PICUTRESEnvironment.DIRECTORY_MOVIES 可根据具体需要，传入不通的参数。 1234567891011121314151617181920212223/** * 获取一个文件通过文件夹类型 * * @param fileName * @param boxType * @param defaultPath * @return * @throws FileNotFoundException */default File getFile(String fileName, String boxType, String defaultPath) throws FileNotFoundException &#123; File file; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123; file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName); &#125; else &#123; file = new File(defaultPath + fileName); &#125; if (file == null || !file.exists()) &#123; throw new FileNotFoundException(); &#125; return file;&#125; 以上代码未经测试，忘见谅 接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例： 访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，Manifest.permission.READ_EXTERNAL_STORAGE 和 Manifest.permission.WRITE_EXTERNAL_STORAGE 我们来看一下获取相册资源的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859final Uri contentUri = MediaStore.Files.getContentUri("external"); final String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + " DESC"; final String selection = "(" + MediaStore.Files.FileColumns.MEDIA_TYPE + "=?" + " OR " + MediaStore.Files.FileColumns.MEDIA_TYPE + "=?)" + " AND " + MediaStore.MediaColumns.SIZE + "&gt;0"; final String[] selectionAllArgs = &#123;String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)&#125;; ContentResolver contentResolver = mContext.getContentResolver(); String[] projections; projections = new String[]&#123;MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED, MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE&#125;; Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA); int mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE); int sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE); int widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH); int heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT); do &#123; long size = cursor.getLong(sizeIndex); if (size &lt; 1) &#123; continue; &#125; String type = cursor.getString(mimeTypeIndex); String path = cursor.getString(pathIndex); if (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) &#123; continue; &#125; int width = cursor.getInt(widthIndex); int height = cursor.getInt(heightIndex); if (width &lt; 1 || height &lt; 1) &#123; continue; &#125; File file = new File(path); if (!file.exists() || !file.isFile()) &#123; continue; &#125; File parentFile = file.getParentFile(); if (parentFile != null) &#123; images.add(path); &#125; &#125; while (cursor.moveToNext()); cursor.close(); &#125; 通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在AndroidManifest.xml 中的 &lt;application&gt; 标签中加入 android:requestLegacyExternalStorage=&quot;true&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ASpectJ 初识]]></title>
    <url>%2F2020%2F03%2F06%2FASpectJ-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先我们先来了解一下 AOP AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能 面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。 AOP 术语 key 别名 描述 Advice 通知 切面的具体行为，要执行的代码 PointCut 切点 通知被应用的具体位置 Join Point 连接点 程序运行时，能够应用通知的所有点 Aspect 切面 什么时候在什么地方做什么事情，是切点和通知的结合 Target 目标对象 被切入功能的目标对象 Introduction 引入 将新的方法或属性引入到现有的类中 Weaving 织入 将切面应用到目标对象并创建新的代理对象的过程 AOP 底层通过使用动态代理实现，包含两种方式： 使用 JDK 动态代理实现 使用 cglib 实现 通知类型 前置通知(Befor)：在方法之前执行 后置通知(After)：在方法之后执行 异常通知(AfterThrowing)：方法出现异常执行 最终通知(AfterReturning)：在后置之后执行 环绕通知(Around)：在方法之前和之后执行 AspectJAspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。 先写到这里！]]></content>
  </entry>
  <entry>
    <title><![CDATA[OKHttp 重定向拦截器]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%2FOKHttp-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用 OKHttp 进行重定向拦截处理okhttp重定向存在两个缺陷： okhttp处理301,302重定向时，会把请求方式设置为GET这样会丢失原来Post请求中的参数。 okhttp默认不支持跨协议的重定向，比如http重定向到https 为了解决这两个问题写了这个拦截器 1234567891011121314151617181920class RedirectInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); HttpUrl beforeUrl = request.url(); Response response = chain.proceed(request); HttpUrl afterUrl = response.request().url(); //1.根据url判断是否是重定向 if(!beforeUrl.equals(afterUrl)) &#123; //处理两种情况 1、跨协议 2、原先不是GET请求。 if (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals("GET")) &#123; //重新请求 Request newRequest = request.newBuilder().url(response.request().url()).build(); response = chain.proceed(newRequest); &#125; &#125; return response; &#125;&#125;]]></content>
      <tags>
        <tag>三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 常用工具和插件]]></title>
    <url>%2F2020%2F02%2F20%2FTools%2FAndroid-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android 开发必备插件和工具Android Studio 插件 插件名 注释 Alibaba Java Coding Guidelines 阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等； Android Parcelable code generator 序列化 Po 类时，可以快速生成序列化代码 CodeGlance 代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码 DataBase Navigator 支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题 FindBugs-IDEA 可以分析现存代码中容易引起异常的部分，并提供修改建议 GsonFormater 将 xml 和 json 转换位 pojo 类，可以快速生成数据源 Markdown 语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档 Markdown Navigator Markdown 预览工具，可以观察实时渲染的 HTML 文档 Android Resource Tools 1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像） 3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度 Codota 模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有 以及在编译时，会给予相关的代码块提示 GoodFormatter 保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改； ButterknifePlugin 快速生成 butternkife 的注入代码，前提需要引入 butterknife JsonViewer 可以替换 postman 的插件，用来调试接口 Git Commit Template Git 提交记录模版工具 Sql Android 数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便 — — codata 123456789101112public void zipFile(File srcFile, File zipFile) throws IOException &#123; try (FileInputStream fis = new FileInputStream(srcFile); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) &#123; zos.putNextEntry(new ZipEntry(srcFile.getName())); int len; byte[] buffer = new byte[1024]; while ((len = fis.read(buffer)) &gt; 0) &#123; zos.write(buffer, 0, len); &#125; zos.closeEntry(); &#125;&#125; AndroidResourceTools JsonViewer 开发工具除必要 AS 之外，需要以下工具, Mac 用户可以通过 XClient 下载破解版软件 工具 注释 Sublime Text 3 文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；PrettyJson 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；支持列编辑，快速修改 Markdown 可以用来写 Markdown 文件，但不支持渲染Sublime Text 3 下载地址 Postman 接口调试工具，也可以用上面推荐的 JsonViewerPostman 下载地址 Fiddler、Charles 抓包调试工具，可抓包，修改参数调试接口，任选Fiddler 下载地址Charles 下载地址 Markdown Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）Typora 下载地址MWeb Pro 下载地址 Vysor Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问Vysor 下载地址 XMind 脑图工具，用来写结构XMind 下载地址 Beyond Compare 文件比较器，比较两组文件的差异BeyondCompare 下载地址 Dash 源码查看器， 也可以使用在线的 Android 社区 PxCook 云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。PxCook 下载地址 — —]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（四）]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[丢了···································· T_T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 下配置 Android Studio 中文输入]]></title>
    <url>%2F2019%2F08%2F23%2FLinux-%E4%B8%8B%E9%85%8D%E7%BD%AE-Android-Studio-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。 虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。 最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。 首先，打开 Android Studio 的文件目录 /android-stdio/bin/ ，使用 Vi 命令打开文件 studio.sh， 在文件的开头，输入下面这一串 123export XMODIFIERS=@im=fcitxexport QT_IM_MODULE=fcitxexport GTK_IM_MODULE=&quot;fcitx&quot; 然后 :wq 保存退出。 接着重启 Android Studio 就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java Reference]]></title>
    <url>%2F2019%2F08%2F09%2FJava%2FJava%20%E5%90%84%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Reference 引用继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。 名称 特点 StrongReferenceSoftReference 只要引用链不断开，不会被回收 SoftReference 直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 WeakReference 没有任何强引用指向弱引用指向的对象 PhantomReference 任何时候都可以被垃圾回收 三个子类的构造方法中涉及到 ReferenceQueue 和 Referent： Referent： 被引用对象 ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。 123456789101112131415161718192021public class ReferenceTest&#123; public static void main(String[] args) &#123; &#125; static class Person &#123; private String name; private String getName()&#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("in Person finalize"); &#125; &#125;&#125; StrongReference 强引用Java 中使用的最多，普通的引用 Object obj = new Object(); Person p = new Person(); 都属于强引用 强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。 一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。 1Person p = new Person(); person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。 SoftReference 软引用软引用普通使用形式： 12Person p = new Person();SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); 强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子： 12345678910111213141516171819202122private static void testSofeReference()&#123; // 创建强引用对象 Person person = new Person(); System.out.println("person 对象为" + person); // 创建软引用对象 SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前) if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.gc(); if(sr.get() == null)&#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125;&#125; 执行上面的例子： 123person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c 当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。 我们继续执行 System.gc() 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。 软引用所指向的对象要进行回收，需要满足两个条件： 没有任何强引用指向软引用指向的对象（内存中的 Person 对象） JVM 需要内存时，即在抛出 OOM 之前 总结： SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 软引用还可以和一个 ReferenceQueue 一起使用， 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。 1234567891011121314151617181920212223242526private static void testSoftReferenceWithQueue()&#123; Person person = new Person(); System.out.println("person 对象为：" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); SoftReference&lt;Person&gt; sr = new SoftReference&lt;&gt;(person, queue); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前） if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为：" + queue.poll()); System.gc(); if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为： " + queue.poll());&#125; 执行上述例子，结果如下： 12345person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 nullperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 null 注意： 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 WeakReference 弱引用弱引用的一般使用形式： 1234567891011121314151617181920private static void testWeakReference()&#123; Person person = new Person(); System.out.println("person 对象为： " + person); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person); person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。 if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.gc(); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125;&#125; 执行结果为： 1234person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象进入 GC 流程in Person finalize 当执行 person = null 后，堆内存的 Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。 此时调用 wr.get() 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 wr.get() 方法返回不为空。 继续执行 System.gc() 强制执行垃圾回收，打印结果可以看到，wr.get() 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。 弱引用所指向的对象要进行回收，只需要满足条件： ​ 没有任何强引用指向弱引用指向的对象（内存中的 Person 对象） 总结： ​ WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。 其主要使用场景见于： ​ 当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 WeakReference 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。 与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。 1234567891011121314151617181920212223242526272829303132333435private static void testWeakReferenceWithQueue () &#123; Person person = new Person(); System.out.println("person 对象为 " + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person, queue); System.out.println("wr 对象为 " + wr); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.out.println("Whether or not this reference has been enqueued:" + wr.isEnqueued()); System.out.println("Queue item: " + queue.pull()); System.gc(); if (wr.get() == null) &#123;// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; try &#123; // 确保垃圾回收线程能够执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Whether or not this reference has been enqueued: " + wr.isEnqueued()); System.out.println("queue item: " + queue.poll());&#125; 执行结果： 123456789person 对象为 com.example.ReferenceTEst$Person@522d9d8cwr 对象为 java.lang.ref.WeakReference@603828d2person 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8cWhether or not this reference has been enqueued: falsequeue item: nullperson 对象进入回收流程in Person finalizeWhether or not this reference has been enqueued: truequeue item: java.lang.ref.WeakReference@603828d2 从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。 注意： ​ 当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 ​ 而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。 PhantomReference 虚引用虚引用源码： 1234567891011121314package java.lang.ref;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get()&#123; return null; &#125; public PhantomReference(T var1, ReferenceQueue&lt;? super T&gt; var2) &#123; super.(var1, var2); &#125;&#125; PhantomReference 只有一个构造函数 PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q) 因此，PhantomReference 使用必须结合 ReferenceQueue； 不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null 举例： 1234567891011121314151617181920212223private static void testPhantomReference() &#123; Person person = new Person(); System.out.println("person 对象为" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;Person&gt; pr = new PhantomReference&lt;&gt;(person, queue); System.out.println("pr 对象为" + pr); System.out.println("pr.get() = " + pr.get()); person = null; System.gc(); try&#123; // 确保垃圾回收线程执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("queue item: " + queue.poll());&#125; 执行结果： 12345person 对象为 com.example.ReferenceTEst$Person@522d9d8cpr 对象为 java.lang.ref.PhantomReference@60e35b53pr.get() = nullin Person finalizequeue ite: java.lang.ref.PhantomReference@60e35b53 总结： ​ 与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并采取必要的行动） 用途： ​ 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ​ 程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。 ​ 程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 线程通信基础流程]]></title>
    <url>%2F2019%2F08%2F01%2FAndroid%20%E5%9F%BA%E7%A1%80%2F%E5%8E%9F%E7%90%86%2FHandler%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。 Looper在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出 mThread = Thread.currentThread();&#125; Looper 在构造函数里做了两件事儿： 将线程对象指向了创建的 Looper 的线程 创建了一个新的 MessageQueue 分析完构造函数后，看下面两个方法 looper.loop() looper.prepare() looper.loop()在当前线程中启动一个 Message loop 机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop()&#123; final Looper me = myLooper();// 获取当前线程绑定的 Looper if(me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn`t called on this thread"); &#125; final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue // make sure the identity of this thread is that of the local process, // And keep track of what that identity token actuall is. Binder.clearCallingIdentity(); fianl long ident = Binder.clearCallingIdentity(); // 进入死循环，不断获取对象，分发对象到 Handler 中去消费 for(;;) &#123; Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。 if(msg == null) &#123; // No message idicates that the message queue is quittig. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if(logging != null) &#123; logging.println("&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback _ ": " + msg.what); &#125; // 在这里开始分发 Message msg.target.dispatchMessage(msg); if(logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted. final long newIdent = Binder.clearCallingIdentity(); if(ident != null) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用” msg.recycleUnchecked(); &#125;&#125; 从上面的代码可以看出，最重要的方法是： queue.next() msg.target.dispatchMessage(msg) msg.recycleUnchecked() 其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下: MessageQueue： 装食物的容器 Message ：被装的食物 Handler （msg.target 实际上就是 Handler）：食物的消费者 Looper：负责分发食物的人 looper.prepare() 在当前线程关联一个 Lopper 对象12345678private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Lopper may be created per thread"); &#125; // 在当前线程绑定一个 looper mThreadLocal.set(new Looper(quiteAllowed));&#125; 在上面的代码中，做了两件事儿： 判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。 如果有的话，那么就设置一个新的 Looper 到当前线程。 Handler 的使用1234567Handler handler = new Handler ()&#123; // @Override public void handleMessage(Message msg) &#123; // handle your message &#125;&#125; 我们先来看下 Handler 的构造： 12345678910111213141516// 空参构造与之对应public Handler(Callback callbacck, boolean async) &#123; // 大姨泄漏提醒log ... // 获取与创建 Handler 线程的 Looper mLooper = Looper.myLooper(); if(mLooper == null) &#123; throw new RunntimeException("Can`t create handler inside thread that has not called Looper.prepare()"); &#125; // 获取 Looper 绑定的 MessageQueue // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？ handler.handleMessage(msg) 在什么时候被回调的？ A1: Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg) 还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法： 1234567891011121314public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; // 引用 Handler 中的 MessageQueue // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue MessageQueue queue = mQueue; if(queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called withe no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; // 将新来的 Message 加入到 MessageQueue 中 return enqueueMessage(queue, msg, uptimeMillis);&#125; 接下来看一下 enququeMessage(queue, msg, uptimeMillis): 1234567private boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) &#123; msg.target = this; if(mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; A2: handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法 123456789101112public void diapatchMessage(Message msg) &#123; if(msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if(mCallback != null) &#123; if(mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); // 开始回调 &#125;&#125; 通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。 总结当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。 一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。]]></content>
      <tags>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（三）]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一次更新已经过去一个半月了，请不要担心，他还在！作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。 绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。 这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。 现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧： 掉叶 掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。 黄叶 黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。 土壤 起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。 总结 总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。 习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（二）]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋. 记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去. 植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以. 植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇. 昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根. 新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（一）]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[激动的心，颤抖的手，京东上面动动手。哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株清香木，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。 其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。 那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。 自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。 OK，说正事儿，先来介绍一下清香木： 清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。 这里有一个养花的 APP，养花大全，我就是在这上学习养花的技术及注意事项的。 虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。 虽然 APP 上介绍了清香木一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下 术语 含义 见干见湿 见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。 浇水要浇透 浇水时，见到水从底部孔流出 这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。 那么这里我在详细的说一下我的理解： 见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。 浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm 我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。 小白在这献丑了，后续会持续更新]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp Intercept]]></title>
    <url>%2F2019%2F04%2F30%2F%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%2FOkHttp-Intercept%2F</url>
    <content type="text"><![CDATA[OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子 要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法. 这里介绍两种 Interceptor 的实例 Log 日志 (LogInterceptor)Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等. 这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等. 话不多说, 上代码. 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义 log 拦截器,输入请求地址,请求参,请求结果*/public class LogInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 拦截请求信息,获取请求地址及请求参数 Request request = chain.request(); long t1 = System.nanoTime(); // 获取请求方式 String method = request.method(); if ("POST".equals(method)) &#123; StringBuilder sb = new StringBuilder(); if (request.body() instanceof FormBody) &#123; FormBody body = (FormBody) request.body(); for (int i = 0; i &lt; body.size(); i++) &#123; sb.append(body.encodedName(i) + "=" + body.encodedValue(i) + ","); &#125; sb.delete(sb.length() - 1, sb.length()); LogUtils.d(TAG, String.format("Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;", request.url(), chain.connection(), request.headers(), sb.toString())); &#125; &#125; else &#123; LogUtils.d(TAG, String.format("Sending request %s on %s %n%s", request.url(), chain.connection(), request.headers())); &#125; // 获取响应信息 Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); MediaType contentType = response.body().contentType(); String content = response.body().string(); LogUtils.d(TAG, content); ResponseBody wrappedBody = ResponseBody.create(contentType, content); return response.newBuilder().body(wrappedBody).build(); &#125; &#125; 加参加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为公参, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便. 因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数. 公参拦截器在请求中,增加一些公共的参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class CommonParamsInterceptor implements Interceptor &#123; private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;(); private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;(); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); // process header params inject Headers.Builder headerBuilder = request.headers().newBuilder(); if (headerParamsMap.size() &gt; 0) &#123; Iterator iterator = headerParamsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); headerBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; if (headerLinesList.size() &gt; 0) &#123; for (String line : headerLinesList) &#123; headerBuilder.add(line); &#125; requestBuilder.headers(headerBuilder.build()); &#125; // process header params end // process queryParams inject whatever it's GET or POST if (queryParamsMap.size() &gt; 0 &amp;&amp; "GET".equals(request.method())) &#123;// if (queryParamsMap.size() &gt; 0) &#123; request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap); &#125; // process post body inject if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; "POST".equals(request.method())) &#123; if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBodyBuilder = new FormBody.Builder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; FormBody oldFormBody = (FormBody) request.body(); int paramSize = oldFormBody.size(); if (paramSize &gt; 0) &#123; for (int i = 0; i &lt; paramSize; i++) &#123; newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i)); &#125; &#125; requestBuilder.post(newFormBodyBuilder.build()); request = requestBuilder.build(); &#125; else if (request.body() instanceof MultipartBody) &#123; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue()); &#125; List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; requestBuilder.post(multipartBuilder.build()); request = requestBuilder.build(); &#125; &#125; return chain.proceed(request); &#125; private boolean canInjectIntoBody(Request request) &#123; if (request == null) &#123; return false; &#125; if (!TextUtils.equals(request.method(), "POST")) &#123; return false; &#125; RequestBody body = request.body(); if (body == null) &#123; return false; &#125; MediaType mediaType = body.contentType(); if (mediaType == null) &#123; return false; &#125; if (!TextUtils.equals(mediaType.subtype(), "x-www-form-urlencoded")) &#123; return false; &#125; return true; &#125; // func to inject params into url private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) &#123; HttpUrl.Builder httpUrlBuilder = request.url().newBuilder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue()); &#125; requestBuilder.url(httpUrlBuilder.build()); return requestBuilder.build(); &#125; return request; &#125; private static String bodyToString(final RequestBody request) &#123; try &#123; final RequestBody copy = request; final Buffer buffer = new Buffer(); if (copy != null) copy.writeTo(buffer); else return ""; return buffer.readUtf8(); &#125; catch (final IOException e) &#123; return "did not work"; &#125; &#125; public static class Builder &#123; CommonParamsInterceptor interceptor; public Builder() &#123; interceptor = new CommonParamsInterceptor(); &#125; public Builder addParam(String key, String value) &#123; interceptor.paramsMap.put(key, value); return this; &#125; public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) &#123; interceptor.paramsMap.putAll(paramsMap); return this; &#125; public Builder addHeaderParam(String key, String value) &#123; interceptor.headerParamsMap.put(key, value); return this; &#125; public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) &#123; interceptor.headerParamsMap.putAll(headerParamsMap); return this; &#125; public Builder addHeaderLine(String headerLine) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); return this; &#125; public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) &#123; for (String headerLine : headerLinesList) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); &#125; return this; &#125; public Builder addQueryParam(String key, String value) &#123; interceptor.queryParamsMap.put(key, value); return this; &#125; public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) &#123; interceptor.queryParamsMap.putAll(queryParamsMap); return this; &#125; public CommonParamsInterceptor build() &#123; return interceptor; &#125; &#125;&#125; 加签拦截器互联网是一个开放的环境,危险无处不在,加密通信是安全的基础. 加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签; 加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥. 这里介绍一种加签方式, 加密规则 根据请求参数 key 进行排序 按排好的顺序组装成 key=value&amp;key=value 形式的字符串 将上述字符串拼接 ,最终形成 key=value&amp;key=value的字符串 将字符串 md5, 生成 auth. 一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243public class AuthorizeInterceptor implements Interceptor &#123; private static final String TAG = "AuthorizeInterceptor"; /** * 生成 auth 的私钥 */ private String authKey; /** * 当前设备 mid,用来生成 auth * 数据由 Builder 类传入 */ private String mid = ""; private AuthorizeInterceptor() &#123; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); String url = request.url().toString(); LogUtils.d(TAG, url); if ("POST".equals(request.method())) &#123; request = injectionParamIntoBody(request, requestBuilder); &#125; else if ("GET".equals(request.method())) &#123; request = injectionAuthIntoUrl(request, requestBuilder); &#125; return chain.proceed(request); &#125; /** * GET 请求方式, 生成授权和添加时间戳 * * @param request * @param requestBuilder * @return */ private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) &#123; //获取到请求地址api HttpUrl newHttpUrl = request.url(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); //通过请求地址(最初始的请求地址)获取到参数列表 Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames(); for (String key : parameterNames) &#123; //循环参数列表,获取参数value, String paramValue = newHttpUrl.queryParameter(key); if (!TextUtils.isEmpty(paramValue)) &#123; authMap.put(key, paramValue); &#125; &#125; HttpUrl.Builder newBuilder = request.url().newBuilder() .addEncodedQueryParameter("auth", assembleAuth(authMap, false)); requestBuilder.url(newBuilder.build()); return requestBuilder.build(); &#125; /** * 将参数注入到 POST 请求的 body 中 * * @param request * @param requestBuilder * @return */ private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) &#123; if (request.body() instanceof FormBody) &#123; // 处理正常表单请求方式 FormBody oldFormBody = (FormBody) request.body(); return assembleFormBody(request, oldFormBody, requestBuilder); &#125; else if (request.body() instanceof MultipartBody) &#123; return assembleMultipartBody(request, requestBuilder); &#125; else &#123; return request; &#125; &#125; /** * 构建流媒体参数的 body * * @param request * @param builder * @return */ private Request assembleMultipartBody(Request request, Request.Builder builder) &#123; // 处理流的请求方式 MultipartBody body = (MultipartBody) request.body(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序 if (body != null &amp;&amp; body.parts().size() &gt; 0) &#123; for (MultipartBody.Part part : body.parts()) &#123; // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理 if (part.body().contentType() == null || !"image".equals(part.body().contentType().type()) || "text".equals(part.body().contentType().type())) &#123; Headers headers = part.headers(); // 从 header 中获取 Key, form-data; name= 的字段过滤获取key // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value // 将 key 和 value 填充到 TreeMap 中 for (int i = 0; i &lt; headers.names().size(); i++) &#123; String headerName = headers.value(i); if (headerName.contains("form-data; name=")) &#123; String key = headerName.replace("form-data; name=", "").replace("\"", ""); String value = body2String(part.body()); if (!TextUtils.isEmpty(value)) &#123; authMap.put(key, body2String(part.body())); &#125; &#125; &#125; &#125; &#125; &#125; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); multipartBuilder.addFormDataPart("auth", assembleAuth(authMap, false)); List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; builder.post(multipartBuilder.build()); return builder.build(); &#125; /** * 构建 Auth 数据 * &lt;p&gt; * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式, * Map 拼接完成后,在其后需要再次拼接上 * &lt;p&gt; * 最后将数据 MD5 转化为 32 位小写并返回 * * @param treeMap 构建 Auth 的具体数据 * @param isNeedDecode 是否需要解码 * @return 返回 auth 数据 */ private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, boolean isNeedDecode) &#123; StringBuilder stringBuilder = new StringBuilder(); if (treeMap.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123; try &#123; stringBuilder.append(stringStringEntry.getKey()) .append("=") .append(isNeedDecode ? URLDecoder.decode(stringStringEntry.getValue(), "UTF-8") : stringStringEntry.getValue()) .append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; treeMap.clear(); stringBuilder .append(authKey); Log.d(TAG, stringBuilder.toString()); return MD5.MD5(stringBuilder.toString()); &#125; /** * body 转 string 获取实际参数值 * * @param body Part body * @return part 中写如的参数数据 */ private String body2String(RequestBody body) &#123; if (body != null) &#123; Buffer buffer = new Buffer(); try &#123; body.writeTo(buffer); Charset charset = Charset.forName("UTF-8"); MediaType contentType = body.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; assert charset != null; return buffer.readString(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ""; &#125; /** * 组装 Form 表单请求数据 * * @param request * @param oldFormBody * @param requestBuilder * @return */ private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) &#123; TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 遍历请求参数,非空参数,添加到集合中 for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123; authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; &#125; if (authMap.size() != 0) &#123; // 生成 auth 数据 FormBody.Builder newFormBody = new FormBody.Builder(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add("auth", assembleAuth(authMap, true)); requestBuilder.method(request.method(), newFormBody.build()); return requestBuilder.build(); &#125; return request; &#125; /** * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作 */ public static class Builder &#123; AuthorizeInterceptor authorizeInterceptor; public Builder() &#123; authorizeInterceptor = new AuthorizeInterceptor(); &#125; public Builder setMid(String mid) &#123; authorizeInterceptor.mid = mid; return this; &#125; public Builder setAuthKey(String key) &#123; authorizeInterceptor.authKey = key; return this; &#125; public AuthorizeInterceptor build() &#123; return authorizeInterceptor; &#125; &#125;&#125; 该加签方式,讲请求参数拼接为 key=value 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 contentType 而又有所不同,这里介绍了Form表单提交和 Multipart 上传文件的参数获取方式,其他的请举一反三.]]></content>
      <tags>
        <tag>三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个 ssh 公钥提交代码到不同平台]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[作为一个技术开发人员，免不了在 github 以及 gitlab 以及其他 git 平台上进行代码管理；工作中您可能使用 svn （这不在我们的讨论范围）,也有可能使用 git, 生活中，您可能会将一些内容分享到你的 github 上， 供大家参阅。git 创建版本库很容易， clone 代码也仅仅是简单的一句 git clone https://github.com/xxxx.git，异或是 git clone git@github.com:xxxxx.git；当然，使用 https 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 https 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 SSH 的方式来处理 git 的版本管理。 生成 SSH 密钥使用 SSH 创建一套公密钥，将公钥添加到你要使用的 Git 平台账户下 1ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github 注意： -f 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理） 添加生成的 SSH 公钥添加 ssh 公钥到 github ** 打开 https://github.com/settings/profile ，选择 SSH and GPG keys 点击 New SSH key title 可以随便写，建议见名知意，能知道是哪台设备 key 通过刚刚通过 SSH 命令生成的 .pub 文件中复制即可。文件路径 .ssh/id_rsa.pub 异或是存在您 -f 之后指定的目录。 点击 add SSH key 配置多个 ssh配置多个 ssh 时，需要注意的是： 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 ssh 公钥到对应平台，否则，后续的 ssh 创建过程， 会覆盖掉之前创建的。 ssh-keygen 会同时创建 id_rsa 和 id_rsa.pub 两个文件， .pub 是公钥， 不带后缀的是你的私钥。 同时配置多个 ssh 时，需要您保留私钥在 .ssh 目录下，为保证多平台都可以使用，您需要手动修改一下 id_rsa 文件的名称，.pub 就随便了，配置完，就没用了。 将密钥添加到 ssh-agent 中 1ssh-add ~.ssh/id_rsa 123456# 查看 agent 中的密钥ssh-add -l# 查看 agent 中的公钥ssh-add -L# 删除 agent 中的密钥ssh-add -d .ssh/id_xxx.pub 修改配置文件说了半天，终于到重点了 在 ~/.ssh 目录下新建一个 config 文件 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 ssh 密钥。 touch config 添加以下配置信息 12345678910111213# githubHost github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓HostName github.com # 同上PreferredAuthentications publickey # 这里不要修改IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥# gitlabHost 公司 gitlab 地址HostName 公司 gitlab 地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitlab... 测试命令为： 1ssh -T git@github.com 结果 1Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 只需要替换后面的 git仓库地址, 其他版本库都可以进行测试。 结语说了半天， 还是要记住一点，既然要使用 ssh 的方式进行版本管理，那么在 clone 代码时，也要使用 ssh 方式， 不然我说了这么半天，都是白扯。 文章内容有瑕疵，请给予指正批评]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 判断字符串是否是数字的方法]]></title>
    <url>%2F2019%2F04%2F16%2FJava%2FJava-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用 Java自带的函数 12345678public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i &gt;=0) &#123; if (!Character.isDigit(str.charAt(i))) &#123; return false; &#125; &#125; return true;&#125; 使用正则表达式 方法一: 1234public static boolean isNumeric(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;); return pattern.matcher(str).matches();&#125; 方法二: 123456public static boolean isNumeric(String str) &#123; if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123; return s.matches(&quot;^[0-9]*$&quot;); &#125; return false;&#125; 方法三: 1234 public static boolean isNumeric (String str) &#123; Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); return pattern.matcher(str).matcher();&#125; 使用 ASCII 码 123456789public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i&gt;=0;) &#123; int chr = str.charAt(i); if (chr &lt; 48 || chr &gt; 57) &#123; return false; &#125; &#125; return true;&#125; 判断是不是浮点型数据 1234public static boolean isDouble(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;); return pattern.matcher(str).matches();&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中设置全屏的方法]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid%20%E5%9F%BA%E7%A1%80%2FAndroid-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置 一. 在代码中设置1234567891011public class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); // 无title requestWindowFeature(Window.FEATURE_NO_TITLE); // 全屏 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_main); &#125; &#125; 强调一点: 设置全屏的两段代码,必须在 setContentView() 之前调用,不然会报错 二. 在配置文件中修改1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.test&quot; android:versionCode=&quot;1&quot; ndroid:versionName=&quot;1.0&quot;&gt; &lt;application android:icon=&quot;@drawable/icon&quot; android:lable=&quot;@string/app_name&gt; &lt;activity android:name=&quot;.BaseActivity&quot; android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot; android:lable=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/application&gt;&lt;/manifest&gt; 使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 在一个应用中启动另外一个应用]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid%20%E5%9F%BA%E7%A1%80%2FAndroid-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android 在一个应用中启动另外一个应用Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动. 综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式. 1. 通过 APP 启动另一个 APP1234String packageName = &quot;com.android.calendar&quot;;Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);intent.putExtra(&quot;type&quot;, true);startActivity(intent); 上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException. 通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 android.intent.action.MAIN 的 Activity 启动. 这里介绍两种方式,检测目标应用是否已经安装 方法一: 1234Intent intent = getPackageName().getLaunchIntentForPackage(packageName);if (intent == null) &#123; // 这里判断 Intent 为空, 说明应用不存在 &#125; 方法二: 1234PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);if (packageInfo == null) &#123; // 这里如果 packageInfo 为 null, 说明应用不存在&#125; 2. 打开另外一个 APP 指定的 Activity1234Intent intent = new Intent();ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);intent.setComponent(componeneName);startActivity(intent); 值得注意: 需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错 123Caused by: java.lang.SecurityException: Permission Denial: starting Intent &#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125; (pid=11545, uid=10071) not exported from uid 10067 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦 12 Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; have you declared this activity in your AndroidManifest.xml?]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Dependencies Library Resolve]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-Studio-Dependencies-Library-Resolve%2F</url>
    <content type="text"><![CDATA[在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了. 先说点不正经的: 你可以把你自己引入的包去掉,使用依赖包 放弃治疗 哈哈,言归正传: 当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 build.gradle 中将我们不需要的包删除掉. 举个栗子:当我使用 com.squareup.retrofit2:adapter-rxjava:2.1.0 时, 它默认依赖使用 RxJava 1.5.0 版本. 当我使用 io.reactivex.rxjava2:rxjava:2.0.6 时, 就会引起包冲突. 解决方案:build.gradle 1234567891011...dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile (&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;)&#123; exclude group: &apos;io.reactivex&apos; &#125; compile &apos;io.reactivex.rxjava2:rxjava:2.0.6&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2F2019%2F04%2F16%2Fgit-command%2F</url>
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; git remote set-url &lt;仓库地址&gt; SSH 和 HTTPS 方式切换 1234# ssh to https$ git remote set-url origin https://github.com/USERNAME/repository.git# https to ssh$ git remote set-url origin git@github.com:USERNAME/repository.git 可以使用 git remote -v 来检查当前仓库地址 12&gt; origin git@github.com:username/repository.git (fetch)&gt; origin git@github.com:username/repository.git (push) SSH 和 HTTPS 的区别： 使用 SSH 方式需要在本地配置一个密钥，具体可参见多个 SSH 公钥提交代码到不同平台中介绍；而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。 git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git push 推送本地修改到远端服务器 git push origin master 有时因两个独立的历史，会导致推送无法达成， 通常在 git pull 时会提示 fatal: refusing to merge unrelated histories // 拒绝合并无关历史 这时可是使用 git pull origin master --allow-unrelated-histories 来解决。 git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2F2019%2F04%2F16%2FTools%2Fgit-command%2F</url>
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; git remote set-url &lt;仓库地址&gt; SSH 和 HTTPS 方式切换 1234# ssh to https$ git remote set-url origin https://github.com/USERNAME/repository.git# https to ssh$ git remote set-url origin git@github.com:USERNAME/repository.git 可以使用 git remote -v 来检查当前仓库地址 12&gt; origin git@github.com:username/repository.git (fetch)&gt; origin git@github.com:username/repository.git (push) SSH 和 HTTPS 的区别： 使用 SSH 方式需要在本地配置一个密钥，具体可参见多个 SSH 公钥提交代码到不同平台中介绍；而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。 git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git push 推送本地修改到远端服务器 git push origin master 有时因两个独立的历史，会导致推送无法达成， 通常在 git pull 时会提示 fatal: refusing to merge unrelated histories // 拒绝合并无关历史 这时可是使用 git pull origin master --allow-unrelated-histories 来解决。 git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Android IoT App]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App%2F</url>
    <content type="text"><![CDATA[构建 Android IoT App本文翻译自Building IoT APP for Android Things in 3 step 前言这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 Android Things and how it works 是很有必要的。 名词索引Android IoT App ： 安卓物联网应用 Raspberry Pi 3 ： 树莓派 3 目标这篇文章的目标是： 使用 Android Things 构建一个简单的 RGB Led 控制器 使用 Android API 构建 Android IoT UI 开发 我们会使用 Raspberry Pi 3 作为 IoT 开发板,你也可以使用其他的开发板去开发 Android Things。 此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。 步骤一通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 Raspberry， 每个颜色一个，原理图如下： 共阳极 RGB LED 灯非常常见，因此 Raspberry Pi 3 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 Raspberry 引脚： Pin 29 Pin 31 Pin 33 这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。 现在，我们使用 Android Studio 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle : 123dependencies &#123; provided &apos;com.google.android.things:androidthings:0.1-devpreview&apos;&#125; Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 RGBThingsActivity 类，并在 onCreate 方法中处理 Pin 通信。 步骤二使用 GPIO 引脚与 RGB LED 传递信息。 GPIO 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。 Android Things SDK 提供了一个 PeripheralManagerService 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值： 1234567891011121314try &#123; PeripheralManagerService manager = new PeripheralManagerService(); blueIO = manager.openGpio(&quot;BCM5&quot;); blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); greenIO = manager.openGpio(&quot;BCM6&quot;); greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH); redIO = manager.openGpio(&quot;BCM13&quot;); redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); redIO.setValue(false); blueIO.setValue(false); greenIO.setValue(false);&#125; catch (IOException e) &#123; Log.w(TAG, &quot;Unable to access GPIO&quot;, e);&#125; 这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 Respberry Pin reference ,下图： 可以了解到 Respberry Pi 3 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为： 1blueIO = manager.openGpio(&quot;BCM5&quot;); 开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。 步骤三Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Switch android:text=&quot;Red&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchRed&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Green&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchGreen&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Blue&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchBlue&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;/LinearLayout&gt; 在 onCreate 方法中，我们设置 layout 布局： 123456@Overridepublic void onCreate (Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ...&#125; 处理用户开关： 1234567891011Switch switchRed = (Switch)findViewById(R.id.switchRed);switch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener()&#123; @Override public void onCheckedChanged (CompoundButton buttonView, boolean isChecked)&#123; try &#123; redIO.setValue(!isChecked); &#125; catch (IOException e) &#123; Log.w(TAG,&quot;Red GPIO Error&quot;, e); &#125; &#125;&#125;); 我们必须为其他引脚重复同一段代码。最终结果如下： 因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。 最终结果展示–需要翻墙 youtube 上观看 最后，要使用我们的应用程序，我们必须在 Manifest.xml 文件中条件： 1&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt; 并且声明我的 Activity 是一个 IoT Activity， 启动脚本为： 1234&lt;intent-filter&gt; &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;&lt;/intent-filter&gt; 总结文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。 使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.]]></content>
      <tags>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins + gradle + git 构建 Android CI 构建环境]]></title>
    <url>%2F2019%2F04%2F16%2FJenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。 目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。 因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。 对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。 对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。 CI 的基本工作流程如下： 我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。 准备工作本文使用 Linux Ubuntu 系统为大家介绍环境的搭建 环境工具1. PC 机(mac/linux) 2. Java JDK 3. Android SDK 4. Gradle 5. Git 6. Tomcat 7. Jenkins 环境搭建Java 环境 安装Java JDK, Android SDK, Gradle 可从AndroidDevTools处下载获取。 git 安装git 可通过终端进行安装123sudo add-apt-repository ppa:git-core/ppasudo apt-get updatesudo apt-get install git 安装完成之后通过git --version 检查是否成功 安装后 git 存储在 /usr/bin/git下 Jenkins通过 Jenkins 官方网站下载最新Jenkins.war包 环境变量打开 vi /etc/profile 将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq 其中环境位置根据自己的所在位置进行相应的更改 启动激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins 将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。 启动后，在浏览器中输入： localhost:8080/jenkins 插件安装系统管理-&gt; 插件管理-&gt;可选插件： 在搜索框中搜索以下插件，并进行安装 git plugingitlab plugingrade pluginAndroid Lint PluginBuild Pipeline pluginbuild timeout pluginbuild name pluginchange assembly-version plugincredentials binding plugindescription setter pluginDynamic parameter pluginEmail Extension pluginFindBugs pluginJaCoco pluginUnit attachments pluginProject Description pluginTimestamperWorkspace cleanup plugin 安装完成后，重启。 系统设置系统管理-&gt;系统设置： 配置Android 环境，将地址指向本机的 SDK 目录 系统管理-&gt;全局工具配置 配置 Java， Git ， Gradle 目录等 JDK： Git： Gradle： 到此，环境配置，已基本完成。 下面我们开始进行项目够将操作 项目构建创建Job新建-&gt;构建一个自由风格的软件项目: 参数化构建通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。 在这里我们先看看 build.gradle 中的构建信息: 在项目的 moudle 下 build.gradle 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def getDate () &#123; def date = new Date() def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;) return formattedDate&#125;def verName = APP_VERSIONdef verCode = 14android &#123; .... signingConfigs &#123; release &#123; keyAlias &apos;&apos; keyPassword &apos;&apos; storeFile file (&apos;&apos;) storePassword &apos;&apos; &#125; &#125; defaultConfig &#123; applicationId &quot;cn.zhuangbudong.example&quot; minSdkVersion 18 targetSdkVersion 25 multiDexEnabled true versionCode verCode versionName verName resValues(&quot;string&quot;, &apos;app_version&apos;, verName) &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; lintOptions &#123; abortOnError false &#125; dexOptions &#123; javaMaxHeapSize &apos;2g&apos; &#125;applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def timeNow def oldFile = output.outputFile def outDirectory = oldFile.parent if (&quot;true&quot;.equals(IS_JENKINS)) &#123; timeNow = JENKINS_TIME outDirectory = &quot;/media/nexd/work/android/package/release/&quot; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; else &#123; timeNow = getDate() if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_debug.apk&quot; &#125; else &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; &#125;&#125; gradle.properties: 123APP_VERSION=2.0.2IS_JENKINS=falseJENKINS_TIME=&apos;&apos; 在工程中添加以上代码，并在Jenkins中为这些参数赋值。 下面介绍 Jenkins 参数配置 勾选参数化构建过程，如下图： 按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致 源码管理此处负责从版本库中拉去最新的代码 此处如果需要验证，点击 Add， 选择： Username with password 在对应窗口输入用户名和密码信息 点击添加。 使用 gitlab 进行源码库管理。 触发器触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。 构建环境此处只是在Jenkins在打包时，配置任务名称即可。如下图： 构建这里是最重要滴，配置以下命令，才能进行打包签名等等。 如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。 同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。 构建后操作当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图： 12345678910111213&lt;hr/&gt;(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;项目名称：$&#123;PROJECT_NAME&#125;&lt;br/&gt;&lt;hr/&gt;构建编号：$&#123;BUILD_NUMBER&#125;&lt;br/&gt;&lt;hr/&gt;构建状态：$&#123;BUILD_STATUS&#125;&lt;br/&gt;&lt;hr/&gt;触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;hr/&gt;测试报告：&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&quot;&gt;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建地址：&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建报告：&lt;a href=&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;变更集:$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;&lt;hr/&gt; 开始构建回到 Jenkins 首页，点击创建的项目，点击 build with parameters: 点击开始构建，启动 Jenkins 构建任务。 构建成功时，显示为蓝色， 失败为红色，如下图： 构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。 谢谢~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb command]]></title>
    <url>%2F2019%2F04%2F16%2FTools%2Fadb-command%2F</url>
    <content type="text"><![CDATA[查看PID 1adb shell ps 查看日志 12345全部日志adb logcat按照 PID 筛选日志adb logcat | grep &lt;PID&gt; 查询链接设备 1adb devices 重启机器 1adb reboot 杀死进程服务 1adb kill-server 重启进程服务 1adb start-server 获取机器 Mac 地址 1adb shell cat /sys/class/net/wlan0/address 安装 APK 12345678普通安装adb install &lt;file path&gt;保留数据和缓存文件adb install -r &lt;file path&gt;安装到 SD 卡上adb install -s &lt;file path&gt; 卸载 APK 12345普通卸载adb uninstall &lt;package name&gt;保留数据和缓存文件adb uninstall -k &lt;package name&gt; 启动应用 1adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt; 查看 CPU 占用率 1234567adb shell top查看内存占用前 6 的 appadb shell top -m 6刷新一次内存adb shell top -n 1 杀死进程 1adb shell kill &lt;pid&gt; 将 System 分区重新挂在为可读写分区 1adb remount 从本地复制文件到设备 1adb push &lt;local&gt; &lt;remote&gt; 从设备复制文件到本地 1adb pull &lt;remote&gt; &lt;local&gt; 查看 WiFi 密码 1adb shell cat /data/misc/wifi/*.conf 查看 bug 报告 1adb bugreport 跑 monkey 1adb shell monkey -v -p your.package.name 500 截图 1adb shell screencap -p /sdcard/screenshot.png 录屏 1adb shell screenrecord /sdcard/demo.mp4 查看安装列表 1adb shell pm list packages 安装证书 1adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer 查看内存占用 1adb shell dumpsys meminfo &lt;package&gt; -d 查询栈信息 12345adb shell dumpsys activity// 获取自己应用adb shell dumpsys activity | grep &lt;package&gt;// 获取处于栈顶的 activityadb shell dumpsys activity | grep mFocusedActivity]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sitemap]]></title>
    <url>%2Fsitemap%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
