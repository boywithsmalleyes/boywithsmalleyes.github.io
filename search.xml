<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lifecycle 源码分析]]></title>
    <url>%2F2020%2F09%2F17%2FLifecycle-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[开始是废话（翻译自源码）定义了一个 Android 生命周期的对象。 Fragment和FragmentActivity类实现LifecycleOwner接口， 并可以通过 getLifecycle() 方法来访问生命周期。 我们也可以实现LifecycleOwner在自己的类。 1234// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 Lifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。Lifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY 如果您使用Java 8 语言 ，然后使用DefaultLifecycleObserver 观察事件。 需要将&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot; 增加到你的 build.gradle 文件中。 123456class TestObserver implements DefaultLifecycleObserver &#123; @Override public void onCreate(LifecycleOwner owner) &#123; // your code &#125;&#125; 如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以DefaultLifecycleObserver和注释之间，则须偏向 DefaultLifecycleObserver。 1234class TestObserver implements LifecycleObserver &#123; @OnLifecycleEvent(ON_STOP) void onStopped() &#123;&#125;&#125; 观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为LifecycleOwner 。 带注释的方法Lifecycle.Event.ON_ANY 可以接收第二个参数，它必须是类型的Lifecycle.Event。 123456class TestObserver implements LifecycleObserver &#123; @OnLifecycleEvent(ON_CREATE) void onCreated(LifecycleOwner source) &#123;&#125; @OnLifecycleEvent(ON_ANY) void onAny(LifecycleOwner source, Event event) &#123;&#125;&#125; 提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。 那我能做什么呢说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 友盟统计 在友盟统计中，我们经常会在 BaseActivity 中插入友盟对页面流转的统计, onStart() onResume() onPause() onStop() 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。 干货~~~来了 那么解决上述问题的方案就来了，我们通过实现 LifecycleObserver ，通过标识声明周期方法之后，仅需一句 addObserver(this) ，就可以将 Activity 或 Fragment 的声明周期方法与我们定义的 Observer 方法关联起来。通过感知 Activity 或 Fragment 的声明周期方法，实现友盟统计，此时就将业务整体与 BaseActivity 抽离开，是的公共组件变得更简洁一些。 当然，这只是 Lifecycle 的一种简单应用，其他的使用方法还是需要我们不断的去探索。 源码分析Lifecycle UML 想理解一个东西，最好的方式就是去阅读它， 这是开发多年总结出的一句话。 那么通过上面的 UML 类图关系，我们能够看出， Lifecycle 的内容并不是很多。但它怎么就会这么强大呢。 ComponentActivity &amp; ReportFragment就算没看过源码，知道Lifecycle 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 Activity 有关，通过AppCompatActivity 类，我们向上查找，我们可以看到 ComponentActivity 这个类，实现了 LifecycleOwner 接口，并返回了一个 mLifecycleRegistry 12345678// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);// LifecycleOwner 接口，提供了一个 getLifecycle() 方法@Overridepublic Lifecycle getLifecycle()&#123; return mLifecycleRegistry;&#125; 在 ComponentActivity 的构造方法里，适配了不同的平台版本。 12345678910111213141516171819202122232425262728293031323334353637383940public ComponentActivity() &#123; Lifecycle lifecycle = getLifecycle(); //noinspection ConstantConditions if (lifecycle == null) &#123; throw new IllegalStateException("getLifecycle() returned null in ComponentActivity's " + "constructor. Please make sure you are lazily constructing your Lifecycle " + "in the first call to getLifecycle() rather than relying on field " + "initialization."); &#125; if (Build.VERSION.SDK_INT &gt;= 19) &#123; getLifecycle().addObserver(new LifecycleEventObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_STOP) &#123; Window window = getWindow(); final View decor = window != null ? window.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; &#125; &#125; &#125;); &#125; getLifecycle().addObserver(new LifecycleEventObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; if (!isChangingConfigurations()) &#123; getViewModelStore().clear(); &#125; &#125; &#125; &#125;); if (19 &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= 23) &#123; getLifecycle().addObserver(new ImmLeaksCleaner(this)); &#125;&#125; 通过构造方法，有没有发现一个很重要的信息， addObserver()， 由此，我们不难看出 ，LifecycleRegister 的一个重要的方法就是 addObserver() 。翻阅类结构了解到 LifecycleRegister 是 Lifecycle 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。 我们先不着急看 LifecycleRegister，继续看 CompontentActivity 类，既然是个 Activity 那么一定会有创建过程，回看 onCreate() 方法，我们可以观察到一个有趣的东西： 123456789101112131415/** * &#123;@inheritDoc&#125; * * If your ComponentActivity is annotated with &#123;@link ContentView&#125;, this will * call &#123;@link #setContentView(int)&#125; for you. */@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); ReportFragment.injectIfNeededIn(this); if (mContentLayoutId != 0) &#123; setContentView(mContentLayoutId); &#125;&#125; ReportFragment.injectIfNeededIn(this) 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。 别慌，进去看。 ReportFragment12345678910public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125;&#125; 咦？？？？为什么要在我的 Activity 上添加一个 Fragment， 翻遍代码，我们也未见到任何布局，你是一个空的 ，😱😱😱， 太可怕了！ 按照 Fragment 的生命周期，我们继续看 dispatch()1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE);&#125;@Overridepublic void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START);&#125;@Overridepublic void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME);&#125;@Overridepublic void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE);&#125;@Overridepublic void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null;&#125; 有没有发现， 又有一个方法被重复的利用，没错，就是dispatch(Lifecycle.Event event) 而且传入的参数，又和 Activity 的生命周期一致。那么我们来看看它. handleLifecycleEvent()1234567891011121314private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 handleLifecycleEvent(event) 方法，又蒙蔽了不，这里啥也没干，就跑了。 你跑，那我就追！ LifecycleRegister123456789101112131415161718192021222324252627/** * Sets the current state and notifies the observers. * &lt;p&gt; * Note that if the &#123;@code currentState&#125; is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 两个方法，我们翻译下注释 设置当前状态，并通知观察者 注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效 getStateAfter()现在我们来分析源码，getStateAfter(event) 这个方法，我们先进去看下做了什么： 1234567891011121314151617static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException("Unexpected event value " + event);&#125; 原来是一个静态方法，通过传入的 Event 事件，找到当前事件对应的下一个生命周期状态 State 我们还有一个方法没有分析 moveToState(State next), 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 123if (mState == next) &#123; return;&#125; 如果当前状态和下一个（操作后的）状态一致，则直接 return 这也映照了注释中的那句话。 sync()继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 sync() 方法，咦，这又是什么呢？===&gt; 状态同步 12345678910111213141516171819202122232425262728293031/** * Custom list that keeps observers and can handle removals / additions during traversal. * * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), */private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;();// happens only on the top of stack (never in reentrance),// so it doesn't have to take in account parentsprivate void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already" + "garbage collected. It is too late to change lifecycle state."); &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125; 这里出现了一个新东西 mObserverMap 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。 继续分析源码 mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个backwardPass(lifecycleOwner) 方法，让观察者的状态回退到当前状态上 mState.compareTo(newest.getValue().mState) &gt; 0 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 forwardPass(lifecycleOwner) Lifecycle State Sequence通过分析 forwardPass 和 backwardPass 方法，我们看到其内部又调用了两个方法, downEvent 和 upEvent，我们称呼为升级事件和降级事件 123456789101112131415161718192021222324252627282930private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; 通过上面两个方法，我们总结出 Lifecycle 中 State 和 Event 的时序关系，如下图 同时我们也回顾一下，getStateAfter() 方法，对事件和状态的判断，也就明白了状态和事件的关系。 dispatchEvent123456789101112131415161718192021222324252627282930private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125;&#125;private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125;&#125; 迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发observer.dispatchEvent(lifecycleOwner, event) 123456void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; 哈哈， 又是一个方法进入了我们的视线 onStateChanged(owner, event)，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？ 但我们只需要关注 ReflectiveGenericLifecycleObserver , 想知道为什么吗？ 我也是看了源码才总结出来的。 ReflectiveGenericLifecycleObserver1234567891011121314151617/** * An internal implementation of &#123;@link LifecycleObserver&#125; that relies on reflection. */class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(LifecycleOwner source, Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; 哎，mInfo.invokeCallbacks(source,event,mWrapped); 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨 既然是类嘛，那肯定是要创建的，那就看下构造器呗。 wrapped 这东西，经过了缓存，Emmm ，我也是点进去 ClassesInfoCache 之后，都了它的注释才明白的。 那 wrapped 又是什么呢？通过 ClassesInfoCache 和我们追踪 ReflectiveGenericLifecycleObserver 可以看出， ClassesInfoCache 缓存了 LifecycleObserver 的类对象，ReflectiveGenericLifecycleObserver 也是向下传递一个 LifecycleObserver。由此我们可以判断出，其实这个 LifecycleObserver 就是我们自己定义的观察者。 而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 mInfo.invokeCallback(source event, mWrapped); reflect invoke method1234567891011121314151617181920void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; //noinspection TryWithIdenticalCatches try &#123; switch (mCallType) &#123; case CALL_TYPE_NO_ARG: mMethod.invoke(target); break; case CALL_TYPE_PROVIDER: mMethod.invoke(target, source); break; case CALL_TYPE_PROVIDER_WITH_EVENT: mMethod.invoke(target, source, event); break; &#125; &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException("Failed to call observer method", e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125;&#125; 还记得文章开头对 Lifecycle 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法 至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。 但是！！！！！！！！！！！！！！！！ 我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！ addObserver()前面我们说了一大堆，都是对 Lifecycle 如何处理，并监听我们的生命周期的方法，也就是 Lifecycle是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？ 好，我们继续观察 LifecycleRegister 中的 addObserver(LifecycleObserver) 这个也是我们自定义观察者后，需要调用的方法 123456789101112131415161718192021222324252627282930313233@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125; 哈哈，看起来代码并不是很多丫！！！！ 哼，天真的你！但它就是这么多 我们这里要逐行清点 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; 嗯，一上来就初始化了一个 INITIALIZED 状态的状态，哈哈哈，好拗口。 随后创建了一个 ObserverWithState ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。 紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 Map 中，也就是 mObserverMap 然后返回了个东西， 阅读后发现，又和 Lifecycle 的注释对上了。 之后，计算出当前 Activity 或 Fragment 的状态，并判断，如果当前观察者的状态落后于 Activity 或 Fragment 的状态，则立即执行dispatchEvent() 方法，执行回调。 总结认真阅读源码后，我们能够看出，其实 Lifecycle 的技术很简单，只有反射，观察者，装饰器，它将这三个东西应用的很神。 总结一下，分析源码我们从两方面入手 addObserver() 这个方法是对用户最直接的内容，当我们创建一个 Observer 后，都会通过 add 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到 给要添加的Observer 一个初始的状态（装饰器模式，包装数据） 将数据存储再本地缓存中 （mObserverMap） 立即进行状态判断，决定是否处理生命周期变化 ReportFragment 作用是，附着再 Activity 上，用来感知 Activity 的生命周期变化，也起到将业务从 Activity 中分离出来。通过生命感知生命周期的变化，执行 dispatch() 方法，将生命周期事件分发给它所有的观察者去处理消息 handleLifecycleEvent 反射 这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。 sync() 这个方法是用来快速同步观察者状态与 Activity 和 Fragment ，目的也是能够让观察者执行到它所有观察的数据。两个方法 forwardPass() 和 backwardPass() 是其实现的原理。]]></content>
      <tags>
        <tag>Android,Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2F2020%2F07%2F09%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[RechclerView 总结 Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示 ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给 RecyclerView LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成 Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误 ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡 RecyclerView 的绘制RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 onMeasure() onLayout() onDraw() onMeasureLayoutManager 负责 RecyclerView 的绘制，其有一个 mAutoMeasure 属性，用来控制是否开启自动测量，开启情况下，布局交由 RecyclerView 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 onMeasure 来处理自身的测量工作。 自动测量原理： 当 RecyclerView 的宽高都为 EXACTLY 时， 可以直接设置对应的宽高，然后返回，结束测量 如果宽高都不时 EXACTLY 则会在 onMeasure 中开始布局的处理。 RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 mLayoutStep 记录了 RecyclerView 当前的布局状态 STEP_START STEP_LAYOUT STEP_ANIMATIONS 对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 dispatchLayoutStep1() 来执行第一步布局，结束后， mLayoutStep 变为 STEP_LAYOUT ，表示接下来需要调用 dispatchLayoutStep2() 进行布局，结束后 mLayoutStep 变为 STEP_ANIMATIONS, 继续执行第三步 dispatchLayoutStep3() dispatchLayoutStep1: 负责记录状态 dispatchLayoutStep2：负责布局 dispatchLayoutStep3：与 step1 比较，根据变化来触发动画 onLayout 1234567891011121314151617181920212223242526protected void onLayout(boolean changed, int l int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; mState.mIsMeasuring = false; if(mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if(mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // first 2 steps are done in onMeasure but looks like we have to run again due to changed size mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 通过 dispatchLayout 可以验证RecyclerView 的 layout三步走原则，如果在 onMeasure 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 onLayout 中依次触发三步走。 dispatchLayoutStep1 1234567891011private void dispatchLayoutStep1()&#123; if(mState.mRunSimpleAnimations) &#123; int count = mChildHelper.getChildCount(); for(int i = 0; i &lt; count; i++) &#123; final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); mViewInfoStore.addToPreLayout(holder, animationInfo); &#125; &#125; mState.mLayoutStep = State.STEP_LAYOUT&#125; step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变 dispatchLayoutStep2 12345private void dispatchLayoutStep2()&#123; mLayout.onLayoutChildren(mRecycler, mState); mState.mLayoutStep = State.STATE_ANIMATIONS;&#125; layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。 1234567891011121314151617181920212223242526272829303132public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if(!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) &#123; updateAnchorInfoForLayout(recycler, state, mAnchorInfo); &#125; if(mAnchorInfo.mLayoutFromEnd) &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTIONTAIL : LayoutState.ITEM_DIRECTION_HEAD; &#125; else &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; &#125; onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); if(mAnchorInfo.mLayoutFromEnd) &#123; &#125; else &#123; // fill towards end updateLayouStateToFillEnd(mAnchorInfo); fill(recycler, mLayoutState, state, false); // fill towards start updateLayoutStateToFillStart(mAnchorInfo); fill(recycler, mLayoutState, state, false); &#125;&#125; 流程很负责，大致流程如下 找到 anchor点 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域 anchor 点的寻找是由 updateAnchorInfoForLayout 函数负责。向下追踪会看到 updateAnchorFromChildren 方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 anchorInfo 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。 继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成 1234567891011121314int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) &#123; final int start = layoutState.mAvailable; if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; recycleByLayoutState(recycler, layoutState); &#125; int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; while((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult); &#125; return start-layoutState.mAvailable;&#125; recycleByLayoutState 这个函数，会根据当前信息对不需要的 View 进行回收: 1234567private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123; if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; &#125; else &#123; recycleViewsFromStart(recycler, layoutState.mScrollingOffset); &#125;&#125; 继续看 recycleViewsFromStart 12345678910111213141516private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt)&#123; final int limit = dt; final int childCount = getChildCount(); if(mShouldReverseLayout) &#123; &#125; else &#123; for(int i = 0; i &lt; childCount; i++)&#123; View child = getChildAt(i); if(mOrientationHelper.getDecoratedEnd(child) &gt; limit || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123; recycleChildren(recycler, 0, i); return; &#125; &#125; &#125;&#125; 该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 recycleChildren 里，而这函数又调用了 removeAndRecycleViewAt 12345public void removeAndRecycleViewAt(int index, Recycler recycler) &#123; final View view = getChildAt(index); removeViewAt(index); recycler.recycleView(view);&#125; 该函数先调用 removeViewAt ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。 1234while((layoutState.mInfinite || remainningSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunk(recycler, state, layoutState, layoutChunkResult);&#125; 只要又剩余空间，就会执行 layoutChunk 方法 12345678910111213141516void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result)&#123; View view = layoutState.next(recycler); LayoutParams params = (LayoutParams) view.getLayoutParams(); if(layoutState.mScrapList == null) &#123; if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; &#125; layoutDecoratedWithMargins(view, left, top, right, bottom);&#125; 在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇 1234View next(RecyclerView.Recycler recycler ) &#123; final View view = recycler.getViewForPosition(mCurrentPosition); return view;&#125; 可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。 我们在看 layoutChunk 对刚刚生成的 View 的处理 12345if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) &#123; addView(view);&#125; else &#123; addView(view, 0);&#125; 明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。 dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局 dispatchLayoutStep3最后一步 1234567891011private void dispatchLayoutStep3()&#123; mState.mLayoutStep = State.STEP_START; if(mState.mRunSimpleAnimations) &#123; for(int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder); mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; mViewInfoStore.process(mViewInfoProcessCallback); &#125;&#125; 这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法， 12345678void addToPostLayout(ViewHolder holder, ItemHolderInfo info) &#123; InfoRecord record = mLayoutHolderMap.get(holder); if(record == null ) &#123; record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); &#125; record.postInfo = info;record.flags |= FLAT_POST;&#125; 最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。 缓存逻辑 RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解， 12345678910111213141516171819202122232425262728293031323334353637383940414243View getViewForPosition(int position, boolean dryRun) &#123; boolean fromScrap = false; ViewHolder holder = null; if(mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrap = holder != null &#125; if(hoder == null) &#123; hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun); &#125; if(holder == null )&#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); final int type = mAdapter.getItemViewType(offsetPosition); if(mAdapter.hasStableIds())&#123; holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); &#125; if(holder == null &amp;&amp; mViewCacheExtension != null) &#123; final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); &#125; if(holder == null) &#123; // fallback to recycler holder = getRecyclerViewPool().getRecyclerView(type); if(holder != null)&#123; holder.resetInternal(); if(FORCE_INVALIDATE_DISPLAY_LIST)&#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if(holder == null )&#123; holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; // 生成 LayoutParams 的代码 return holder.itemView;&#125; 获取 View 的逻辑可以整理为 搜索 mChangedScrap， 如果找到则返回相应的 holder 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder 搜索 mRecyclerPool, 如果找到则返回 Holder 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例 对于 View 的回收 12345678910111213141516171819202122void recycleViewHolderInternal(ViewHolder holder ) &#123; if(holder.isRecyclable()) &#123; if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) &#123; int cachedViewSize = mCachedViews.size(); if(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; if(cachedViewSize &lt; mViewCacheMax) &#123; mCachedViews.add(holder); cached = true; &#125; &#125; if(!cached) &#123; addViewHolderToRecycledViewPool(holder); recycled = true; &#125; &#125;&#125; 回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView 则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool 时可以多个 RecyclerView 共享的。 与 AdapterView 比较 index AdapterView RecyclerView 1 Simple click listener OnItemTouchListener 2 Simple Divider ItemDecoration 3 ListView and GridView LinearLayoutManagerGridLayoutManager.. 4 RecyclerBin Recycler 5 Header and Footer Partial refresh 点击事件 ListView 原生提供了Item 点击、长安的事件，而 RecyclerView 则需要使用 onTouchListener 相对比较复杂 分割线 ListView 可以很轻松设施 Divider 属性来显示 item 之间的分割线， RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强 布局类型 AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。 缓存方式 ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致 不同点 局部刷新 ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 notifyItemChanged(position) 来完成，甚至可以通过 notifyItemChanged(position, payload) 传入一个 payload 信息来刷新单个 item 中的特定内容。 动画 RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难 嵌套布局 RecyclerView 实现了 NestedScrollingChild 接口，可以和一切嵌套组件很好的工作 ListView 原生特点 头部与尾部支持 ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、 多选 支持多选和单选的 ListView 更方便 多数据源支持 ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。 总结 RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Q 文件权限适配]]></title>
    <url>%2F2020%2F03%2F11%2FAndroid-Q-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。 “沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为Context.getExternalFilesDir() 下的文件夹。需要传入以下参数 1234567Environment.DIRECTORY_MUSICEnvironment.DIRECTORY_PODCASTSEnvironment.DIRECTORY_RINGTONESEnvironment.DIRECTORY_ALARMSEnvironment.DIRECTORY_NOTIFICATIONSEnvironment.DIRECTORY_PICUTRESEnvironment.DIRECTORY_MOVIES 可根据具体需要，传入不通的参数。 1234567891011121314151617181920212223/** * 获取一个文件通过文件夹类型 * * @param fileName * @param boxType * @param defaultPath * @return * @throws FileNotFoundException */default File getFile(String fileName, String boxType, String defaultPath) throws FileNotFoundException &#123; File file; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123; file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName); &#125; else &#123; file = new File(defaultPath + fileName); &#125; if (file == null || !file.exists()) &#123; throw new FileNotFoundException(); &#125; return file;&#125; 以上代码未经测试，忘见谅 接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例： 访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，Manifest.permission.READ_EXTERNAL_STORAGE 和 Manifest.permission.WRITE_EXTERNAL_STORAGE 我们来看一下获取相册资源的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859final Uri contentUri = MediaStore.Files.getContentUri("external"); final String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + " DESC"; final String selection = "(" + MediaStore.Files.FileColumns.MEDIA_TYPE + "=?" + " OR " + MediaStore.Files.FileColumns.MEDIA_TYPE + "=?)" + " AND " + MediaStore.MediaColumns.SIZE + "&gt;0"; final String[] selectionAllArgs = &#123;String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)&#125;; ContentResolver contentResolver = mContext.getContentResolver(); String[] projections; projections = new String[]&#123;MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED, MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE&#125;; Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA); int mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE); int sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE); int widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH); int heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT); do &#123; long size = cursor.getLong(sizeIndex); if (size &lt; 1) &#123; continue; &#125; String type = cursor.getString(mimeTypeIndex); String path = cursor.getString(pathIndex); if (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) &#123; continue; &#125; int width = cursor.getInt(widthIndex); int height = cursor.getInt(heightIndex); if (width &lt; 1 || height &lt; 1) &#123; continue; &#125; File file = new File(path); if (!file.exists() || !file.isFile()) &#123; continue; &#125; File parentFile = file.getParentFile(); if (parentFile != null) &#123; images.add(path); &#125; &#125; while (cursor.moveToNext()); cursor.close(); &#125; 通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在AndroidManifest.xml 中的 &lt;application&gt; 标签中加入 android:requestLegacyExternalStorage=&quot;true&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ASpectJ 初识]]></title>
    <url>%2F2020%2F03%2F06%2FASpectJ-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先我们先来了解一下 AOP AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能 面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。 AOP 术语 key 别名 描述 Advice 通知 切面的具体行为，要执行的代码 PointCut 切点 通知被应用的具体位置 Join Point 连接点 程序运行时，能够应用通知的所有点 Aspect 切面 什么时候在什么地方做什么事情，是切点和通知的结合 Target 目标对象 被切入功能的目标对象 Introduction 引入 将新的方法或属性引入到现有的类中 Weaving 织入 将切面应用到目标对象并创建新的代理对象的过程 AOP 底层通过使用动态代理实现，包含两种方式： 使用 JDK 动态代理实现 使用 cglib 实现 通知类型 前置通知(Befor)：在方法之前执行 后置通知(After)：在方法之后执行 异常通知(AfterThrowing)：方法出现异常执行 最终通知(AfterReturning)：在后置之后执行 环绕通知(Around)：在方法之前和之后执行 AspectJAspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。 先写到这里！]]></content>
  </entry>
  <entry>
    <title><![CDATA[OKHttp 重定向拦截器]]></title>
    <url>%2F2020%2F02%2F20%2FOKHttp-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用 OKHttp 进行重定向拦截处理okhttp重定向存在两个缺陷： okhttp处理301,302重定向时，会把请求方式设置为GET这样会丢失原来Post请求中的参数。 okhttp默认不支持跨协议的重定向，比如http重定向到https 为了解决这两个问题写了这个拦截器 1234567891011121314151617181920class RedirectInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); HttpUrl beforeUrl = request.url(); Response response = chain.proceed(request); HttpUrl afterUrl = response.request().url(); //1.根据url判断是否是重定向 if(!beforeUrl.equals(afterUrl)) &#123; //处理两种情况 1、跨协议 2、原先不是GET请求。 if (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals("GET")) &#123; //重新请求 Request newRequest = request.newBuilder().url(response.request().url()).build(); response = chain.proceed(newRequest); &#125; &#125; return response; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 常用工具和插件]]></title>
    <url>%2F2020%2F02%2F20%2FAndroid-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android 开发必备插件和工具Android Studio 插件 插件名 注释 Alibaba Java Coding Guidelines 阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等； Android Parcelable code generator 序列化 Po 类时，可以快速生成序列化代码 CodeGlance 代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码 DataBase Navigator 支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题 FindBugs-IDEA 可以分析现存代码中容易引起异常的部分，并提供修改建议 GsonFormater 将 xml 和 json 转换位 pojo 类，可以快速生成数据源 Markdown 语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档 Markdown Navigator Markdown 预览工具，可以观察实时渲染的 HTML 文档 Android Resource Tools 1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像） 3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度 Codota 模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有 以及在编译时，会给予相关的代码块提示 GoodFormatter 保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改； ButterknifePlugin 快速生成 butternkife 的注入代码，前提需要引入 butterknife JsonViewer 可以替换 postman 的插件，用来调试接口 Git Commit Template Git 提交记录模版工具 — — codata 123456789101112public void zipFile(File srcFile, File zipFile) throws IOException &#123; try (FileInputStream fis = new FileInputStream(srcFile); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) &#123; zos.putNextEntry(new ZipEntry(srcFile.getName())); int len; byte[] buffer = new byte[1024]; while ((len = fis.read(buffer)) &gt; 0) &#123; zos.write(buffer, 0, len); &#125; zos.closeEntry(); &#125;&#125; AndroidResourceTools JsonViewer 开发工具除必要 AS 之外，需要以下工具, Mac 用户可以通过 XClient 下载破解版软件 工具 注释 Sublime Text 3 文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；PrettyJson 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；支持列编辑，快速修改 Markdown 可以用来写 Markdown 文件，但不支持渲染Sublime Text 3 下载地址 Postman 接口调试工具，也可以用上面推荐的 JsonViewerPostman 下载地址 Fiddler、Charles 抓包调试工具，可抓包，修改参数调试接口，任选Fiddler 下载地址Charles 下载地址 Markdown Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）Typora 下载地址MWeb Pro 下载地址 Vysor Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问Vysor 下载地址 XMind 脑图工具，用来写结构XMind 下载地址 Beyond Compare 文件比较器，比较两组文件的差异BeyondCompare 下载地址 Dash 源码查看器， 也可以使用在线的 Android 社区 PxCook 云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。PxCook 下载地址 — —]]></content>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（四）]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[丢了···································· T_T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 下配置 Android Studio 中文输入]]></title>
    <url>%2F2019%2F08%2F23%2FLinux-%E4%B8%8B%E9%85%8D%E7%BD%AE-Android-Studio-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。 虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。 最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。 首先，打开 Android Studio 的文件目录 /android-stdio/bin/ ，使用 Vi 命令打开文件 studio.sh， 在文件的开头，输入下面这一串 123export XMODIFIERS=@im=fcitxexport QT_IM_MODULE=fcitxexport GTK_IM_MODULE=&quot;fcitx&quot; 然后 :wq 保存退出。 接着重启 Android Studio 就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 获取 View 的宽高]]></title>
    <url>%2F2019%2F08%2F21%2FAndroid-%E8%8E%B7%E5%8F%96-View-%E7%9A%84%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[实际开发中，获取一个 View 的宽高有很多中方法，最直接的就是： 1234567// 返回 View 的宽高，单位是像素int height = view.getHeight();int width = view.getWidth();// 返回 View 的原始测量高度int height = view.getMeasuredHeight();int width = view.getMeasuredWidth(); 有时需要在 onCreate 方法中获取某个 View 组件的宽度和高度信息，而直接调用 View 组件的 getWidth(), getHeight(), getMeasuredWidth(), getMeasuredHeight(), getTop(), getLeft() 等方法是无法获取到真实值，只会得到 0 ，这是因为 View 组件布局要在 onResume 后回调 。 因此，当我们需要 View 的宽高数据时，可以使用 getViewTreeObserver().addOnGlobalLayoutListener() 来获取 View 的宽度或者高度。这是获得一个 View 的宽度和高度的方法之一。 onGlobalLayoutListener() 是 ViewTreeObserver 的内部类，当一个视图树的布局发生改变时，可以被 ViewTreeObserver 监听到，这是一个注册监听视图的观察者(observer)， 在视图树的全局事件改变时得到通知。 ViewTreeObserver 不能直接实例化，而是通过 getViewTreeObserver() 获得。 其中，我们可以利用 OnGlobalLayoutListener 来获取一个视图的真实高度。 1234567891011121314private int height;private int width;private int positionX;private int positionY;imageView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener()&#123; @Override public void onGlobalLayout()&#123; positionX = imageView.getX(); positionY = imageView.getY(); height = imageView.getHeight(); widht = imageView.getWidth(); imageView.getViewTreeObserver().removeOnGlobalLayoutListener(this); &#125;&#125;); OnGlobalLayoutListener 可能会被多次触发，因此在得到了高度之后，要将 OnGlobalLayoutListener 注销掉 1imageView.getViewTreeObserver().removeOnGlobalLayoutListener(this); ViewTreeObserver123public final class ViewTreeObserver extends Objectjava.lang.Objectandroid.view.ViewTreeObserver 是一个注册监听视图的观察者（Observer），在视图树全局事件改变时得到通知。这个全局事件不仅包括整个树的布局，从绘画过程开始，触摸模式的改变等。ViewTreeObserver 不能够被应用程序实例化，因为它是由视图提供 getViewTreeObserver() 基本常用的方法 1234567891011121314151617181920212223242526272829303132// 当在一个视图书中的焦点状态发生改变时，所要调用的回调函数接口interface ViewTreeObserver.OnGlobalFocusChangeListener;// 当在一个视图树中全局布局发生改变时或者视图树中的某个视图的可视化状态发生改变时interface ViewTreeObserver.OnGlobalLayoutListener;// 当一个视图树将要绘制时interface ViewTreeObserver.OnPreDrawListener;// 当一个视图树中的组件发生滚动时interface ViewTreeObserver.OnScrollChangedListener;// 当一个视图树中的触摸模式发生改变时，用于监听 touch 和非 touch 的转换interface ViewTreeObserver.OnTouchModeChangeListener;// 监听布局的变化interface ViewTreeObserver.OnGlobalLayoutLitener;// 当前 ViewTreeObserver 是否可用，不可用时，任何方法调用都会报错getViewTreeObserver().isAlive();addOnWindowAttachListenervoid removeOnGlobalFocusChangeListener();void removeOnScrollChangedListener();void removeOnTouchModeChangeListener();// 当整个布局发生改变时通知相应的注册监听器。如果你强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者在GONE状态下，它可以被手动的调用 void dispatchOnGlobalLayout()// 当一个视图树将要绘制时通知相应的注册监听器，如果返回 true， 则这个绘制将被取消并重新计划。如果强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者一个在 gone 状态下，将被手动调用void dispatchOnPreDraw();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Reference]]></title>
    <url>%2F2019%2F08%2F09%2FJava%20%E5%90%84%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Reference 引用继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。 三个子类的构造方法中涉及到 ReferenceQueue 和 Referent： Referent： 被引用对象 ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。 123456789101112131415161718192021public class ReferenceTest&#123; public static void main(String[] args) &#123; &#125; static class Person &#123; private String name; private String getName()&#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("in Person finalize"); &#125; &#125;&#125; StrongReference 强引用Java 中使用的最多，普通的引用 Object obj = new Object(); Person p = new Person(); 都属于强引用 强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。 一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。 1Person p = new Person(); person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。 SoftReference 软引用软引用普通使用形式： 12Person p = new Person();SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); 强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子： 12345678910111213141516171819202122private static void testSofeReference()&#123; // 创建强引用对象 Person person = new Person(); System.out.println("person 对象为" + person); // 创建软引用对象 SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前) if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.gc(); if(sr.get() == null)&#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125;&#125; 执行上面的例子： 123person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c 当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。 我们继续执行 System.gc() 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。 软引用所指向的对象要进行回收，需要满足两个条件： 没有任何强引用指向软引用指向的对象（内存中的 Person 对象） JVM 需要内存时，即在抛出 OOM 之前 总结： SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 软引用还可以和一个 ReferenceQueue 一起使用， 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。 1234567891011121314151617181920212223242526private static void testSoftReferenceWithQueue()&#123; Person person = new Person(); System.out.println("person 对象为：" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); SoftReference&lt;Person&gt; sr = new SoftReference&lt;&gt;(person, queue); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前） if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为：" + queue.poll()); System.gc(); if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为： " + queue.poll());&#125; 执行上述例子，结果如下： 12345person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 nullperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 null 注意： 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 WeakReference 弱引用弱引用的一般使用形式： 1234567891011121314151617181920private static void testWeakReference()&#123; Person person = new Person(); System.out.println("person 对象为： " + person); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person); person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。 if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.gc(); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125;&#125; 执行结果为： 1234person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象进入 GC 流程in Person finalize 当执行 person = null 后，堆内存的 Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。 此时调用 wr.get() 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 wr.get() 方法返回不为空。 继续执行 System.gc() 强制执行垃圾回收，打印结果可以看到，wr.get() 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。 弱引用所指向的对象要进行回收，只需要满足条件： ​ 没有任何强引用指向弱引用指向的对象（内存中的 Person 对象） 总结： ​ WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。 其主要使用场景见于： ​ 当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 WeakReference 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。 与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。 1234567891011121314151617181920212223242526272829303132333435private static void testWeakReferenceWithQueue () &#123; Person person = new Person(); System.out.println("person 对象为 " + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person, queue); System.out.println("wr 对象为 " + wr); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.out.println("Whether or not this reference has been enqueued:" + wr.isEnqueued()); System.out.println("Queue item: " + queue.pull()); System.gc(); if (wr.get() == null) &#123;// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; try &#123; // 确保垃圾回收线程能够执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Whether or not this reference has been enqueued: " + wr.isEnqueued()); System.out.println("queue item: " + queue.poll());&#125; 执行结果： 123456789person 对象为 com.example.ReferenceTEst$Person@522d9d8cwr 对象为 java.lang.ref.WeakReference@603828d2person 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8cWhether or not this reference has been enqueued: falsequeue item: nullperson 对象进入回收流程in Person finalizeWhether or not this reference has been enqueued: truequeue item: java.lang.ref.WeakReference@603828d2 从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。 注意： ​ 当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 ​ 而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。 PhantomReference 虚引用虚引用源码： 1234567891011121314package java.lang.ref;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get()&#123; return null; &#125; public PhantomReference(T var1, ReferenceQueue&lt;? super T&gt; var2) &#123; super.(var1, var2); &#125;&#125; PhantomReference 只有一个构造函数 PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q) 因此，PhantomReference 使用必须结合 ReferenceQueue； 不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null 举例： 1234567891011121314151617181920212223private static void testPhantomReference() &#123; Person person = new Person(); System.out.println("person 对象为" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;Person&gt; pr = new PhantomReference&lt;&gt;(person, queue); System.out.println("pr 对象为" + pr); System.out.println("pr.get() = " + pr.get()); person = null; System.gc(); try&#123; // 确保垃圾回收线程执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("queue item: " + queue.poll());&#125; 执行结果： 12345person 对象为 com.example.ReferenceTEst$Person@522d9d8cpr 对象为 java.lang.ref.PhantomReference@60e35b53pr.get() = nullin Person finalizequeue ite: java.lang.ref.PhantomReference@60e35b53 总结： ​ 与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并才去必要的行动） 用途： ​ 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ​ 程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。 ​ 程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内存管理]]></title>
    <url>%2F2019%2F08%2F04%2FAndroid%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。 Java 内存分配策略Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。 堆与栈的区别：在方法体内定义的（局部变量）一些基本类型的变量和对象的引用都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊变量，这个变量的取值等于数组或者对象在内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举例： 123456789101112public class Sample &#123; int s1 = 0; Sample sample1 = new Sample(); public void method () &#123; int s2 = 1; Sample sample2 = new Sample(); &#125;&#125;Sample sample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 sample2 都是存在于栈中，但 smaple2 指向的对象是存在于堆中。 sample3 指向的对象存放在堆中，包括这个对象的所有成员变量 s1 和 sample1， 而它自己存在与栈中。 结论： 局部变量的脚本数据类型和引用存储在栈中，引用的对象实体存储于堆中。—— 因为他们属于方法中的变量，生命周期随方法而结束 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。—— 因为他们属于类，类对象终究是要被 new 出来使用的。 Java 是如何管理内存Java 的内存管理就是对象的分配和释放的问题。在 Java 中，coder 需要通过关键字 new 为每一个对象申请新的存储空间（基本类型除外），所有的对象都在 堆（Heap）中分配空间。另外对象的释放是由 GC 决定和执行的，在 Java 中，内存分配是由 coder 完成的，而内存释放是由 GC 完成的。这种收支两条线的方法简化了 coder 的工作。同时也加重了 JVM 的工作。也是 Java 程序运行速度慢的原因之一。因为 GC 为了能够正确释放对象， GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要监控。 监控对象状态是为了更准确、及时地释放对象，而释放对象的根本原则就是该对象不在被引用。 Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要他们和根进程不可达，那么 GC 就可以回收他。这种管理方式的有点是管理内存的精度高，但是效率低。 什么是 Java 中的内存泄露在 Java 中，内存泄露就是存在一些被分配的对象，这些对象有两个特点。 这些对象是可达的，即在有向图中，存在通路与其相连 这些对象是无用的，即程序以后不会在使用这些对象。 如果满足这两个条件，这些对象就可以判定为 Java 中的内存泄露，这些对象不会被 GC 回收，但却是占用着内存。 对于程序猿来说， GC 基本是透明的，不可见的。虽然我们只有几个函数可以方位 GC， 例如运行 GC 的函数 System.gc()，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾回收器一定会执行。因为，不同的 JVM 实现着可能使用不同的算法管理 GC。 通常 GC 的线程优先级比较低。 JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定成都时， GC 才开始工作；也有定时执行，有的是平缓执行 GC， 有的是中断式执行 GC。 通常来说，我们不需要关心这些。除非在一些特定的场合， GC 的执行影响应用程序的性能，例如对于基于 Web 的实时系统，如网络游戏等，用户不希望 GC 突然终端应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行， Sun 提供了 HotSpot JVM 支持这一特性。 同样给出一个 Java 内存泄露的典型例子 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null;&#125; 在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然应用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 详细的 Java 中的内存泄露Java 内存回收机制不论那种语言的内存分配方式，都需要返回所分配的真实地址，也就是返回一个指针到内存块的首地址。Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的。所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成。 GC 为了能够正确释放对象，会监控每个对象的运行状态，对他们的申请、引用、被引用、赋值等状况进行监控， Java 会使用有向图的方式进行管理内存，实时监控对象是否可以到达，如果不可以到达，则将其回收，这样也可以消除引用的循环问题。在 Java 语言中，判断一个内存空间是否符合垃圾回收标准有两个： 1. 给对象赋予了空值 null 2. 给对象赋予了新值，这样重新分配了内存空间。 Java 内存泄漏引起的原因内存泄露是指无用对象（不再使用的对象）持续占有内存活无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄漏有时不严重，不易察觉，这样开发者就不知道存在内存泄漏，但有时也很严重，会提示 Out of memory。 Java 内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被释放回收，这就是 Java 中内存泄漏的发生场景，主要有一下几大类： 静态集合类引起的内存泄漏： 像 HashMap、Vector 等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等引用着。 例如： 123456Static Vector v = new Vercor(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null;&#125; 在这个例子中，循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果仅仅释放引用本身（o = null），那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可会说的。因此对象加入到 Vector 后， 还必须从 Vector 中删除，最简单的是将 Vector 设置为 null。 当集合里面的对象属性被修改后，再调用 remove() 方法时，不起作用 例如： 12345678910111213141516171819202122public static void main(String[] args) &#123; Set&lt;Person&gt; set = new HashSet&lt;Person&gt;(); Person p1 = new Person("唐僧", "pwd1", 25); Person p2 = new Person("孙悟空", "pwd2", 24); Person p3 = new Person("猪八戒", "pwd3", 26); set.add(p1); set.add(p2); set.add(p3); System.out.println("总共有：" + set.size() + " 个元素");// 结果： 总共有 3 个元素 p3.setAge(2); // 修改 p3 的年龄，此时 p3 元素对应的 hashcode 值发生改变 set.remove(p3); // remove 掉，造成内存泄露 set.add(p3); // 重新添加，成功 System.out.println("总共有：" + set.size() + " 个元素"); // 结果：总共有 4 个元素 for (Person person : set) &#123; System.out.println(person); &#125;&#125; 监听器 在 Java 变成中，我们需要和监听器打交道，通常一个应用当中会有多个监听器，我们会调用一个控件的例如addXXXXListener() 等方法来增加监听器，但往往在释放对象的时候，却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 各种连接 比如数据库连接（dataSourse.getConnection()）、 网络连接(socket) 和 io 连接，除非其显示的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的。对于 Resultset 和 Statement 对象可以不进行显示回收，但 Connection 一定要显示回收，因为 Connection 在任何时候都无法自动回收，而 Connection 一旦回收， Resultset 和 Statement 对象就会立即2为 NULL。 但是如果使用连接池，情况就不一样了，除了要显示地关闭链接，还必须显示地关闭 Resultset 和 Statement 对象（关闭其中一个， 另外一个也会关闭），否则就会造成大量的 Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在 try 里面去连接，在 finally 里面释放连接。 内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后续类对象没有释放。此外 coder 还要小心外部模块不经意的引用，例如 coder A 负责 A 模块，调用了 B 模块的一个方法： public void registerMsg(Object b); 这种调用就要小心，传入了一个对象，很可能模块 B 就保持了对该对象的引用，这时候就需要注意模块 B 是否提供响应的操作去除引用。 单例模式 不正确的使用单例模式是引起内存泄漏的一个常见问题，单利对象在初始化后，将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。 12345678910111213141516171819202122class A &#123; public A () &#123; B.getInstance().setA(this); &#125; ...&#125;// B 采用单例模式class B &#123; private A a; private static B instance = new B(); private b ()&#123;&#125; public static B getInstance()&#123; return instacne; &#125; public void setA (A a) &#123; this.a = a; &#125; // .........&#125; 显然 B 采用 singleton 模式， 它持有一个 A 对象的引用，而这个类的对象将不能被回收。想象下如果 A 是个比较复杂的对象或者集合类型会发生什么。 Android 中常见的内存泄漏汇总集合类泄漏集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的例子中就是其中一种情况，当然实际上我们在项目中肯定不会这样谢代码，但稍不注意还是很容易出现这种情况。 单例造成的内存泄露由于单利的静态特性使得其生命周期跟应用一样长，所以如果使用不恰当的话，很容易造成内存泄漏。 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.connect = connect; &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context， 所以这个 Context 的生命周期的长短至关重要： 如果此时传入的是 Application 的 Context， 因为 Application 的生命周期就是这个应用的生命周期，所以这将没有任何问题。 如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的应用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时，它的内存并不会被释放，就会造成泄漏。 正确的方式应修改为： 1234567891011121314public class AppManager &#123; private static AppManager instance; private Context context; private AppManager (Context context) &#123; this.context = context.getApplicationContext();// 使用 Application 的 context &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 或者这样写，连 Context 都不用传进来： 12345678910111213141516171819202122232425262728293031在你的 Application 中添加一个静态方法， getContext() 返回 Application 的 context...context = getApplicationContext();.../** * 获取全局的 Context * @return 返回全局的 context 对象 */ public static Context getContext()&#123; reutnr context;&#125;public class AppManager &#123; private static AppManager instance; private Context context; private AppManager () &#123; this.context = MyApplication.getContext();// 使用 Application 的 context &#125; public staitc AppManager getInstance() &#123; if (instance == null) &#123; instance = new AppManager(); &#125; return instance; &#125;&#125; 匿名内部类/非静态内部类和异步线程非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的 Activity 中，为了避免重复创建相同资源，可能会出现这种写法 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private staitc TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null) &#123; mResource = new TestResource(); &#125; //.... &#125; class TestResource &#123; //.... &#125;&#125; 这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 都会使用该单利的数据，这样虽然避免了资源的重复创建，不过这种写法却造成了内存写泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法： 将该内部类设为静态内部类或者将该内部类抽取出来封装成单例，如果需要使用 Context， 按照上一个方法推荐使用 Application 中的 Context。 当然 Application 的 Context 不是万能的，所以也不能随便乱用，对于有些地方则是必须使用 Activity 的 Context ，对于 Application，Service， Activity 三者的 Context 的应用场景如下： 其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。 匿名内部类Android 开发经常会继承实现 Activity/Fragment/View， 此时如果你使用了匿名类，并被异步线程持有，如果没有任何措施这样一定会导致泄漏 1234567891011public class MainActivity extends Activity &#123; ... Runnable ref1 = new MyRunnable(); Runnable ref2 = new Runnable ()&#123; @Override public void run() &#123; .... &#125; &#125;; ...&#125; ref1 和 ref2 的区别是， ref2 使用了匿名内部类。我们看一下运行时，这两个引用的内存： 可以看到 ref1 没什么特别的。 但 ref2 这个匿名类的实现对象里面多了一个引用： this$0 这个引用指向 MainActivity.this， 也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就会造成内存泄漏。 Handler 造成的内存泄漏Handler 的使用造成的内存泄漏问题应该说是最常见的，但很多时候我们为了避免 ANR 而不在主线程中进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写不规范就有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。 由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，很容易导致无法正确释放。 1234567891011121314151617181920212223public class MainActivity extends Activity &#123; private final Handler mLeakyHandler = new Handerl()&#123; @Override public void handleMessage(Message msg) &#123; ... &#125; &#125;; @Override protected void onCreate(Bundler savedInstanceState) &#123; super.onCreate(savedInstanceState); // post a message and delay its execution for 10 minutes. mLeakHandler.postDelayed(new Runnable()&#123; @Override public void run()&#123; ... &#125; &#125;, 1000 * 6 * 10); // go back to the previous Activity finish(); &#125;&#125; 在该例中，生命了一个延时 10 分钟执行的消息 Message， mLeakyHandler 将其 push 进了消息队列 MessageQueue 中。当 Activity 被 finish() 掉，延时任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，此时 finish() 掉的 Activity 就不会被回收，从而造成内存泄漏（因 Handler 为非静态内部类，会持有外部类的引用，在这里就是 MainActivity）. 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 生命为静态的，则其存活期和 Activity的 生命周期无关了，同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 Context 传入， 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SampleActivity extends Activity &#123; /** * Instence of static inner classes do not bold an implicit reference to their outer class */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler (SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage (Message msg) &#123; SampleActivity activity = mActivity.get(); if(activity != null) &#123; //.... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instance of anonymous classes do not hold an implicit * reference to their outer class when they are "static" */ private static final Runnable sRunnable = new Runnable () &#123; @Override public void run()&#123; ... &#125; &#125;; @Override protected void onCreate(Bundler savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 mintues. mHandler.postDelay(sRunnable, 1000 * 60 * 10); // go back to the previous Activity finish(); &#125; &#125; 综述， 即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到的 WeakReference，所以这里简单说下 Java 中对象的几种引用类型。 Java 对引用分为 StrongReference， SoftReference， WeakReference和 PhantomReference 四种。 级别 回收时机 用途 生存时间 强(StrongReference) 从来不会 对象的一般状态 JVM 停止运行时终止 软(SoftReference) 在内存不足时 联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器(内存不足才清空) 内存不足时终止 弱（WeakReference） 在垃圾回收时 联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器(系统发生 gc 则清空) gc 运行后终止 虚（PhantomReference） 在垃圾回收时 联合 ReferenceQueue 来跟踪对象被垃圾回收器回收的活动 gc 运行后终止 在 Android 应用开发中，为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联得的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清楚已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次去读取图片，由于读取文件需要硬件操作，速度很慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是由于图片占用空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生 OutOfMemery 异常。这时我们可以考虑使用软/弱引用技术来避免这个问题发生。以下是高速缓冲器的雏形： 首先定义一个 HashMap，保存软引用对象： 1private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(); 再定义一个方法，保存 bitmap 的软引用到 HashMap。 123456789101112131415161718192021222324public class CacheBySoftRef &#123; // 先定义一个 HashMap，保存软引用对象 private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(); // 再定义一个方法，保存 bitmap 的软引用到 HashMap。 public void addBitmapToCache(String path) &#123; // 强引用的 Bitmap 对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的 bitmap 对象 SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap); imageCache.put(path, softBitmap); &#125; // 获取的时候，可以通过 SoftReference 的 get() 方法得到 bitmap 对象 public Bitmap getBitmapByPath(String path) &#123; // 从缓存中取软引用的 bitmap 对象 SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path); // 判断是否存在软引用 if (softBitmap == null) return; // 通过软引用取出 bitmap 对象，如果由于内存不足 Bitmap 被回收，将取到空，如果未被回收，则可重复使用，提高速度 Bitmap bitmap = softBitmap.get(); return bitmap; &#125;&#125; 使用软引用以后，在 OutOfMemory 异常发生之前，这些缓存的图片资源的内存空间可以被释放掉，从而避免内存达到上线，避免 Crash 发生。 如果只是想避免 OutOfMemory 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果对象可能会经常使用，就尽可能的使用软引用。如果对象不被使用的可能性更大，就用弱引用。 前面所说，创建一个静态的 Handler 内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 的泄漏，不过 Looper 线程的消息队列中，还是可能会有待处理的消息，所以我们在 Activity 的 onDestory() 时，或者 Stop 时应该移除消息队列 MessageQueue 中的消息。 移除消息队列中 Message 的方法： 12345public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Objject token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object); 尽量避免使用 static 成员变量如果成员变量被声明为 static, 那我们都知道其生命周期将与整个 APP 进程生命周期一样。 这会导致一些列问题，如果你的 APP 进程设计上是常驻内存的，那即使 APP 切到后台，这部分内存也不会被释放。按照现在手机 APP 内存管理机制，占内存较大的后台集成将优先回收，因为如果此 APP 做过进程互相保活，那会造成 APP 在后台频繁重启。当手机安装了你参与开发的 APP 以后一夜时间手机被消耗空了电量、流量，你的 APP 不得不被用户卸载或者静默。 修复方法是： 不要在类初始化时初始化静态成员。可以考虑 lazy 初始化。架构设计上要死好是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 避免 Override finalize() finalize 方法被执行的时间不确定，不能依赖它来释放紧缺的资源，时间不确定的原因是：虚拟机调用 GC 的时间不确定 finalize daemon 线程被调度到的时间不确定。 finalize 方法只会被执行一次，及时对象被复活，如果已经执行过 finalize 方法，再次被 GC 时，也不会再执行，原因是： 含有 finalize 方法的 Object 是在 new 的时候，由虚拟机生成了一个 finalize reference 在来引用到该 Object的，而在finalize 方法执行的时候，该 Object 所对应的 finalize Reference 会被释放掉。即使在这个时候把该Object 复活（即用强引用引用住该 Object），再第二次被 GC 的时候，由于没有了 finalize Reference 与之对应，所以 finalize 方法不会再执行。 含有 finalize 方法的 Object 需要至少经过两轮 GC 才有可能被释放。 资源未关闭造成的内存泄漏对于使用了 BroadcastRevicer, ContentObserver, File， 游标 Cursor， Stream， Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 一些不良代码造成的内存压力有些代码并不造成内存泄漏，但是他们， 或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。 比如: Bitmap 没有调用 recycle(), 对于 Bitmap 对象在不使用时，我们应该先调用 recycle(), 释放内存，然后设置为 null。 因为加载 bitmap 对象的内存空间，一部分是 Java 的， 一部分是 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的）。而这个 recycle() 就是针对 C 部分的内存释放。构造 Adapter 时，没有使用缓存的 convertView， 每次都在创建新的 converView。 这里推荐使用 ViewHolder。 总结对 Activity 等组件的引用应该控制在 Activity 的生命周期内；如果不能就考虑使用 getApplicationContext 或者 getApplication ,以避免 Activity 被外部长生命周期的对象引用而泄漏。 尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括 context），即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。 对生命周期比 Activity 长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样避免内存泄漏： 12将内部类改为静态内部类静态内部类中使用弱引用来引用外部成员的成员变量 Handler 的持有的引用对象最好使用弱引用，资源释放时，也可以清空 Handler 中的消息，比如在 Activity onStop 或者 onDestory 的时候，取消掉该 Handler 对象的 Message 和 Runnable。 在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象是，显式地将此对象赋值为 null, 比如使用完 Bitmap 后，先调用 recycle()， 再赋 null， 清空对图片等资源有直接引用或简洁引用的数组（使用 array.clear(); array=null）等，最好遵循谁创建谁释放的原则。 正确关闭资源，对于使用了 BroadcastReceived， ContentObserver, File, Cursor, Stream, Bitmap 等资源的使用，应该在 Activity 销毁时及时关闭或者注销。 保持对对象生命周期的敏感，特别注意单例，静态对象，全局性集合等的生命周期。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 线程通信基础流程]]></title>
    <url>%2F2019%2F08%2F01%2FHandler%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。 Looper在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出 mThread = Thread.currentThread();&#125; Looper 在构造函数里做了两件事儿： 将线程对象指向了创建的 Looper 的线程 创建了一个新的 MessageQueue 分析完构造函数后，看下面两个方法 looper.loop() looper.prepare() looper.loop()在当前线程中启动一个 Message loop 机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop()&#123; final Looper me = myLooper();// 获取当前线程绑定的 Looper if(me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn`t called on this thread"); &#125; final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue // make sure the identity of this thread is that of the local process, // And keep track of what that identity token actuall is. Binder.clearCallingIdentity(); fianl long ident = Binder.clearCallingIdentity(); // 进入死循环，不断获取对象，分发对象到 Handler 中去消费 for(;;) &#123; Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。 if(msg == null) &#123; // No message idicates that the message queue is quittig. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if(logging != null) &#123; logging.println("&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback _ ": " + msg.what); &#125; // 在这里开始分发 Message msg.target.dispatchMessage(msg); if(logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted. final long newIdent = Binder.clearCallingIdentity(); if(ident != null) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用” msg.recycleUnchecked(); &#125;&#125; 从上面的代码可以看出，最重要的方法是： queue.next() msg.target.dispatchMessage(msg) msg.recycleUnchecked() 其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下: MessageQueue： 装食物的容器 Message ：被装的食物 Handler （msg.target 实际上就是 Handler）：食物的消费者 Looper：负责分发食物的人 looper.prepare() 在当前线程关联一个 Lopper 对象12345678private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Lopper may be created per thread"); &#125; // 在当前线程绑定一个 looper mThreadLocal.set(new Looper(quiteAllowed));&#125; 在上面的代码中，做了两件事儿： 判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。 如果有的话，那么就设置一个新的 Looper 到当前线程。 Handler 的使用1234567Handler handler = new Handler ()&#123; // @Override public void handleMessage(Message msg) &#123; // handle your message &#125;&#125; 我们先来看下 Handler 的构造： 12345678910111213141516// 空参构造与之对应public Handler(Callback callbacck, boolean async) &#123; // 大姨泄漏提醒log ... // 获取与创建 Handler 线程的 Looper mLooper = Looper.myLooper(); if(mLooper == null) &#123; throw new RunntimeException("Can`t create handler inside thread that has not called Looper.prepare()"); &#125; // 获取 Looper 绑定的 MessageQueue // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？ handler.handleMessage(msg) 在什么时候被回调的？ A1: Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg) 还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法： 1234567891011121314public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; // 引用 Handler 中的 MessageQueue // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue MessageQueue queue = mQueue; if(queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called withe no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; // 将新来的 Message 加入到 MessageQueue 中 return enqueueMessage(queue, msg, uptimeMillis);&#125; 接下来看一下 enququeMessage(queue, msg, uptimeMillis): 1234567private boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) &#123; msg.target = this; if(mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; A2: handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法 123456789101112public void diapatchMessage(Message msg) &#123; if(msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if(mCallback != null) &#123; if(mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); // 开始回调 &#125;&#125; 通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。 总结当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。 一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。]]></content>
      <tags>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（三）]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一次更新已经过去一个半月了，请不要担心，他还在！作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。 这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。 绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。 这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。 现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧： 掉叶 掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。 黄叶 黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。 土壤 起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。 总结 总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。 习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（二）]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋. 记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去. 植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以. 植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇. 昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根. 新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（一）]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[激动的心，颤抖的手，京东上面动动手。哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株清香木，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。 其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。 那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。 自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。 OK，说正事儿，先来介绍一下清香木： 清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。 这里有一个养花的 APP，养花大全，我就是在这上学习养花的技术及注意事项的。 虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。 虽然 APP 上介绍了清香木一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下 术语 含义 见干见湿 见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。 浇水要浇透 浇水时，见到水从底部孔流出 这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。 那么这里我在详细的说一下我的理解： 见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。 浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm 我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。 小白在这献丑了，后续会持续更新]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp Intercept]]></title>
    <url>%2F2019%2F04%2F30%2FOkHttp-Intercept%2F</url>
    <content type="text"><![CDATA[OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子 要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法. 这里介绍两种 Interceptor 的实例 Log 日志 (LogInterceptor)Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等. 这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等. 话不多说, 上代码. 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义 log 拦截器,输入请求地址,请求参,请求结果*/public class LogInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 拦截请求信息,获取请求地址及请求参数 Request request = chain.request(); long t1 = System.nanoTime(); // 获取请求方式 String method = request.method(); if ("POST".equals(method)) &#123; StringBuilder sb = new StringBuilder(); if (request.body() instanceof FormBody) &#123; FormBody body = (FormBody) request.body(); for (int i = 0; i &lt; body.size(); i++) &#123; sb.append(body.encodedName(i) + "=" + body.encodedValue(i) + ","); &#125; sb.delete(sb.length() - 1, sb.length()); LogUtils.d(TAG, String.format("Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;", request.url(), chain.connection(), request.headers(), sb.toString())); &#125; &#125; else &#123; LogUtils.d(TAG, String.format("Sending request %s on %s %n%s", request.url(), chain.connection(), request.headers())); &#125; // 获取响应信息 Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); MediaType contentType = response.body().contentType(); String content = response.body().string(); LogUtils.d(TAG, content); ResponseBody wrappedBody = ResponseBody.create(contentType, content); return response.newBuilder().body(wrappedBody).build(); &#125; &#125; 加参加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为公参, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便. 因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数. 公参拦截器在请求中,增加一些公共的参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class CommonParamsInterceptor implements Interceptor &#123; private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;(); private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;(); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); // process header params inject Headers.Builder headerBuilder = request.headers().newBuilder(); if (headerParamsMap.size() &gt; 0) &#123; Iterator iterator = headerParamsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); headerBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; if (headerLinesList.size() &gt; 0) &#123; for (String line : headerLinesList) &#123; headerBuilder.add(line); &#125; requestBuilder.headers(headerBuilder.build()); &#125; // process header params end // process queryParams inject whatever it's GET or POST if (queryParamsMap.size() &gt; 0 &amp;&amp; "GET".equals(request.method())) &#123;// if (queryParamsMap.size() &gt; 0) &#123; request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap); &#125; // process post body inject if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; "POST".equals(request.method())) &#123; if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBodyBuilder = new FormBody.Builder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; FormBody oldFormBody = (FormBody) request.body(); int paramSize = oldFormBody.size(); if (paramSize &gt; 0) &#123; for (int i = 0; i &lt; paramSize; i++) &#123; newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i)); &#125; &#125; requestBuilder.post(newFormBodyBuilder.build()); request = requestBuilder.build(); &#125; else if (request.body() instanceof MultipartBody) &#123; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue()); &#125; List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; requestBuilder.post(multipartBuilder.build()); request = requestBuilder.build(); &#125; &#125; return chain.proceed(request); &#125; private boolean canInjectIntoBody(Request request) &#123; if (request == null) &#123; return false; &#125; if (!TextUtils.equals(request.method(), "POST")) &#123; return false; &#125; RequestBody body = request.body(); if (body == null) &#123; return false; &#125; MediaType mediaType = body.contentType(); if (mediaType == null) &#123; return false; &#125; if (!TextUtils.equals(mediaType.subtype(), "x-www-form-urlencoded")) &#123; return false; &#125; return true; &#125; // func to inject params into url private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) &#123; HttpUrl.Builder httpUrlBuilder = request.url().newBuilder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue()); &#125; requestBuilder.url(httpUrlBuilder.build()); return requestBuilder.build(); &#125; return request; &#125; private static String bodyToString(final RequestBody request) &#123; try &#123; final RequestBody copy = request; final Buffer buffer = new Buffer(); if (copy != null) copy.writeTo(buffer); else return ""; return buffer.readUtf8(); &#125; catch (final IOException e) &#123; return "did not work"; &#125; &#125; public static class Builder &#123; CommonParamsInterceptor interceptor; public Builder() &#123; interceptor = new CommonParamsInterceptor(); &#125; public Builder addParam(String key, String value) &#123; interceptor.paramsMap.put(key, value); return this; &#125; public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) &#123; interceptor.paramsMap.putAll(paramsMap); return this; &#125; public Builder addHeaderParam(String key, String value) &#123; interceptor.headerParamsMap.put(key, value); return this; &#125; public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) &#123; interceptor.headerParamsMap.putAll(headerParamsMap); return this; &#125; public Builder addHeaderLine(String headerLine) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); return this; &#125; public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) &#123; for (String headerLine : headerLinesList) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); &#125; return this; &#125; public Builder addQueryParam(String key, String value) &#123; interceptor.queryParamsMap.put(key, value); return this; &#125; public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) &#123; interceptor.queryParamsMap.putAll(queryParamsMap); return this; &#125; public CommonParamsInterceptor build() &#123; return interceptor; &#125; &#125;&#125; 加签拦截器互联网是一个开放的环境,危险无处不在,加密通信是安全的基础. 加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签; 加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥. 这里介绍一种加签方式, 加密规则 根据请求参数 key 进行排序 按排好的顺序组装成 key=value&amp;key=value 形式的字符串 将上述字符串拼接 ,最终形成 key=value&amp;key=value的字符串 将字符串 md5, 生成 auth. 一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243public class AuthorizeInterceptor implements Interceptor &#123; private static final String TAG = "AuthorizeInterceptor"; /** * 生成 auth 的私钥 */ private String authKey; /** * 当前设备 mid,用来生成 auth * 数据由 Builder 类传入 */ private String mid = ""; private AuthorizeInterceptor() &#123; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); String url = request.url().toString(); LogUtils.d(TAG, url); if ("POST".equals(request.method())) &#123; request = injectionParamIntoBody(request, requestBuilder); &#125; else if ("GET".equals(request.method())) &#123; request = injectionAuthIntoUrl(request, requestBuilder); &#125; return chain.proceed(request); &#125; /** * GET 请求方式, 生成授权和添加时间戳 * * @param request * @param requestBuilder * @return */ private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) &#123; //获取到请求地址api HttpUrl newHttpUrl = request.url(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); //通过请求地址(最初始的请求地址)获取到参数列表 Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames(); for (String key : parameterNames) &#123; //循环参数列表,获取参数value, String paramValue = newHttpUrl.queryParameter(key); if (!TextUtils.isEmpty(paramValue)) &#123; authMap.put(key, paramValue); &#125; &#125; HttpUrl.Builder newBuilder = request.url().newBuilder() .addEncodedQueryParameter("auth", assembleAuth(authMap, false)); requestBuilder.url(newBuilder.build()); return requestBuilder.build(); &#125; /** * 将参数注入到 POST 请求的 body 中 * * @param request * @param requestBuilder * @return */ private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) &#123; if (request.body() instanceof FormBody) &#123; // 处理正常表单请求方式 FormBody oldFormBody = (FormBody) request.body(); return assembleFormBody(request, oldFormBody, requestBuilder); &#125; else if (request.body() instanceof MultipartBody) &#123; return assembleMultipartBody(request, requestBuilder); &#125; else &#123; return request; &#125; &#125; /** * 构建流媒体参数的 body * * @param request * @param builder * @return */ private Request assembleMultipartBody(Request request, Request.Builder builder) &#123; // 处理流的请求方式 MultipartBody body = (MultipartBody) request.body(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序 if (body != null &amp;&amp; body.parts().size() &gt; 0) &#123; for (MultipartBody.Part part : body.parts()) &#123; // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理 if (part.body().contentType() == null || !"image".equals(part.body().contentType().type()) || "text".equals(part.body().contentType().type())) &#123; Headers headers = part.headers(); // 从 header 中获取 Key, form-data; name= 的字段过滤获取key // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value // 将 key 和 value 填充到 TreeMap 中 for (int i = 0; i &lt; headers.names().size(); i++) &#123; String headerName = headers.value(i); if (headerName.contains("form-data; name=")) &#123; String key = headerName.replace("form-data; name=", "").replace("\"", ""); String value = body2String(part.body()); if (!TextUtils.isEmpty(value)) &#123; authMap.put(key, body2String(part.body())); &#125; &#125; &#125; &#125; &#125; &#125; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); multipartBuilder.addFormDataPart("auth", assembleAuth(authMap, false)); List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; builder.post(multipartBuilder.build()); return builder.build(); &#125; /** * 构建 Auth 数据 * &lt;p&gt; * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式, * Map 拼接完成后,在其后需要再次拼接上 * &lt;p&gt; * 最后将数据 MD5 转化为 32 位小写并返回 * * @param treeMap 构建 Auth 的具体数据 * @param isNeedDecode 是否需要解码 * @return 返回 auth 数据 */ private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, boolean isNeedDecode) &#123; StringBuilder stringBuilder = new StringBuilder(); if (treeMap.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123; try &#123; stringBuilder.append(stringStringEntry.getKey()) .append("=") .append(isNeedDecode ? URLDecoder.decode(stringStringEntry.getValue(), "UTF-8") : stringStringEntry.getValue()) .append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; treeMap.clear(); stringBuilder .append(authKey); Log.d(TAG, stringBuilder.toString()); return MD5.MD5(stringBuilder.toString()); &#125; /** * body 转 string 获取实际参数值 * * @param body Part body * @return part 中写如的参数数据 */ private String body2String(RequestBody body) &#123; if (body != null) &#123; Buffer buffer = new Buffer(); try &#123; body.writeTo(buffer); Charset charset = Charset.forName("UTF-8"); MediaType contentType = body.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; assert charset != null; return buffer.readString(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ""; &#125; /** * 组装 Form 表单请求数据 * * @param request * @param oldFormBody * @param requestBuilder * @return */ private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) &#123; TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 遍历请求参数,非空参数,添加到集合中 for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123; authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; &#125; if (authMap.size() != 0) &#123; // 生成 auth 数据 FormBody.Builder newFormBody = new FormBody.Builder(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add("auth", assembleAuth(authMap, true)); requestBuilder.method(request.method(), newFormBody.build()); return requestBuilder.build(); &#125; return request; &#125; /** * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作 */ public static class Builder &#123; AuthorizeInterceptor authorizeInterceptor; public Builder() &#123; authorizeInterceptor = new AuthorizeInterceptor(); &#125; public Builder setMid(String mid) &#123; authorizeInterceptor.mid = mid; return this; &#125; public Builder setAuthKey(String key) &#123; authorizeInterceptor.authKey = key; return this; &#125; public AuthorizeInterceptor build() &#123; return authorizeInterceptor; &#125; &#125;&#125; 该加签方式,讲请求参数拼接为 key=value 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 contentType 而又有所不同,这里介绍了Form表单提交和 Multipart 上传文件的参数获取方式,其他的请举一反三.]]></content>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个 ssh 公钥提交代码到不同平台]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[作为一个技术开发人员，免不了在 github 以及 gitlab 以及其他 git 平台上进行代码管理；工作中您可能使用 svn （这不在我们的讨论范围）,也有可能使用 git, 生活中，您可能会将一些内容分享到你的 github 上， 供大家参阅。 git 创建版本库很容易， clone 代码也仅仅是简单的一句 git clone https://github.com/xxxx.git，异或是 git clone git@github.com:xxxxx.git；当然，使用 https 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 https 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 SSH 的方式来处理 git 的版本管理。 生成 SSH 密钥使用 SSH 创建一套公密钥，将公钥添加到你要使用的 Git 平台账户下 1ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github 注意： -f 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理） 添加生成的 SSH 公钥添加 ssh 公钥到 github ** 打开 https://github.com/settings/profile ，选择 SSH and GPG keys 点击 New SSH key title 可以随便写，建议见名知意，能知道是哪台设备 key 通过刚刚通过 SSH 命令生成的 .pub 文件中复制即可。文件路径 .ssh/id_rsa.pub 异或是存在您 -f 之后指定的目录。 点击 add SSH key 配置多个 ssh配置多个 ssh 时，需要注意的是： 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 ssh 公钥到对应平台，否则，后续的 ssh 创建过程， 会覆盖掉之前创建的。 ssh-keygen 会同时创建 id_rsa 和 id_rsa.pub 两个文件， .pub 是公钥， 不带后缀的是你的私钥。 同时配置多个 ssh 时，需要您保留私钥在 .ssh 目录下，为保证多平台都可以使用，您需要手动修改一下 id_rsa 文件的名称，.pub 就随便了，配置完，就没用了。 将密钥添加到 ssh-agent 中 1ssh-add ~.ssh/id_rsa 123456# 查看 agent 中的密钥ssh-add -l# 查看 agent 中的公钥ssh-add -L# 删除 agent 中的密钥ssh-add -d .ssh/id_xxx.pub 修改配置文件说了半天，终于到重点了 在 ~/.ssh 目录下新建一个 config 文件 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 ssh 密钥。 touch config 添加以下配置信息 12345678910111213# githubHost github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓HostName github.com # 同上PreferredAuthentications publickey # 这里不要修改IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥# gitlabHost 公司 gitlab 地址HostName 公司 gitlab 地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitlab... 测试命令为： 1ssh -T git@github.com 结果 1Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 只需要替换后面的 git仓库地址, 其他版本库都可以进行测试。 结语说了半天， 还是要记住一点，既然要使用 ssh 的方式进行版本管理，那么在 clone 代码时，也要使用 ssh 方式， 不然我说了这么半天，都是白扯。 文章内容有瑕疵，请给予指正批评]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 判断字符串是否是数字的方法]]></title>
    <url>%2F2019%2F04%2F16%2FJava-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用 Java自带的函数 12345678public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i &gt;=0) &#123; if (!Character.isDigit(str.charAt(i))) &#123; return false; &#125; &#125; return true;&#125; 使用正则表达式 方法一: 1234public static boolean isNumeric(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;); return pattern.matcher(str).matches();&#125; 方法二: 123456public static boolean isNumeric(String str) &#123; if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123; return s.matches(&quot;^[0-9]*$&quot;); &#125; return false;&#125; 方法三: 1234 public static boolean isNumeric (String str) &#123; Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); return pattern.matcher(str).matcher();&#125; 使用 ASCII 码 123456789public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i&gt;=0;) &#123; int chr = str.charAt(i); if (chr &lt; 48 || chr &gt; 57) &#123; return false; &#125; &#125; return true;&#125; 判断是不是浮点型数据 1234public static boolean isDouble(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;); return pattern.matcher(str).matches();&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中设置全屏的方法]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置 一. 在代码中设置1234567891011public class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); // 无title requestWindowFeature(Window.FEATURE_NO_TITLE); // 全屏 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_main); &#125; &#125; 强调一点: 设置全屏的两段代码,必须在 setContentView() 之前调用,不然会报错 二. 在配置文件中修改1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.test&quot; android:versionCode=&quot;1&quot; ndroid:versionName=&quot;1.0&quot;&gt; &lt;application android:icon=&quot;@drawable/icon&quot; android:lable=&quot;@string/app_name&gt; &lt;activity android:name=&quot;.BaseActivity&quot; android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot; android:lable=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/application&gt;&lt;/manifest&gt; 使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取 IP 地址]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求, 第一种方法: 123WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); 通过这种方式获取到的 IP 地址为一串数字,我们并不能看懂,因此我们需要通过下面的方法进行转换: 1String ip = (ipAddress &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;8 &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;16 &amp; 0xff) + &quot;.&quot; + (ipAddress &gt;&gt; 24 &amp; 0xff); 这样转换之后,我们获取到的 IP 地址就是我们平时认识的, 比如: 192.168.1.108 这种方法在飞行模式下获取到的 IP 地址为 0.0.0.0 第二种方法: 12345678910111213141516 public String getLocalIpAddress() &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress().toString(); &#125; &#125; &#125; &#125; catch (SocketException ex) &#123; Log.e(LOG_TAG, ex.toString()); &#125; return null; &#125; 第二种方式是比较通用的,在WiFi和3G/4G 状态下,都可以获取到正确的地址.比如: fe80::8e3a:e3ff:fe45:a018 这种方法在手机处于飞行状态下时, 获取到的 IP 地址为 null]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[事件分发的三个方法 dispatchTouchEvent(MotionEvent event) 判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件； onInterceptTouchEvent(MotionEvent event) 通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件； onTouchEvent(MotionEvent event) 当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。 关于事件分发的一些结论： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束； 正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理； 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。 如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。 View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。 onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。 事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（解决滑动冲突，内部拦截法）。 事件的传递过程：Activity -&gt; Window(PhoneWindow) -&gt; View -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent。 当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 在一个应用中启动另外一个应用]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android 在一个应用中启动另外一个应用Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动. 综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式. 1. 通过 APP 启动另一个 APP1234String packageName = &quot;com.android.calendar&quot;;Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);intent.putExtra(&quot;type&quot;, true);startActivity(intent); 上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException. 通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 android.intent.action.MAIN 的 Activity 启动. 这里介绍两种方式,检测目标应用是否已经安装 方法一: 1234Intent intent = getPackageName().getLaunchIntentForPackage(packageName);if (intent == null) &#123; // 这里判断 Intent 为空, 说明应用不存在 &#125; 方法二: 1234PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);if (packageInfo == null) &#123; // 这里如果 packageInfo 为 null, 说明应用不存在&#125; 2. 打开另外一个 APP 指定的 Activity1234Intent intent = new Intent();ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);intent.setComponent(componeneName);startActivity(intent); 值得注意: 需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错 123Caused by: java.lang.SecurityException: Permission Denial: starting Intent &#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125; (pid=11545, uid=10071) not exported from uid 10067 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦 12 Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; have you declared this activity in your AndroidManifest.xml?]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Dependencies Library Resolve]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-Studio-Dependencies-Library-Resolve%2F</url>
    <content type="text"><![CDATA[在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了. 先说点不正经的: 你可以把你自己引入的包去掉,使用依赖包 放弃治疗 哈哈,言归正传: 当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 build.gradle 中将我们不需要的包删除掉. 举个栗子:当我使用 com.squareup.retrofit2:adapter-rxjava:2.1.0 时, 它默认依赖使用 RxJava 1.5.0 版本. 当我使用 io.reactivex.rxjava2:rxjava:2.0.6 时, 就会引起包冲突. 解决方案:build.gradle 1234567891011...dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile (&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;)&#123; exclude group: &apos;io.reactivex&apos; &#125; compile &apos;io.reactivex.rxjava2:rxjava:2.0.6&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2F2019%2F04%2F16%2Fgit-command%2F</url>
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; git remote set-url &lt;仓库地址&gt; SSH 和 HTTPS 方式切换 1234# ssh to https$ git remote set-url origin https://github.com/USERNAME/repository.git# https to ssh$ git remote set-url origin git@github.com:USERNAME/repository.git 可以使用 git remote -v 来检查当前仓库地址 12&gt; origin git@github.com:username/repository.git (fetch)&gt; origin git@github.com:username/repository.git (push) SSH 和 HTTPS 的区别： 使用 SSH 方式需要在本地配置一个密钥，具体可参见多个 SSH 公钥提交代码到不同平台中介绍；而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。 git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git push 推送本地修改到远端服务器 git push origin master 有时因两个独立的历史，会导致推送无法达成， 通常在 git pull 时会提示 fatal: refusing to merge unrelated histories // 拒绝合并无关历史 这时可是使用 git pull origin master --allow-unrelated-histories 来解决。 git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Android IoT App]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App%2F</url>
    <content type="text"><![CDATA[构建 Android IoT App本文翻译自Building IoT APP for Android Things in 3 step 前言这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 Android Things and how it works 是很有必要的。 名词索引Android IoT App ： 安卓物联网应用 Raspberry Pi 3 ： 树莓派 3 目标这篇文章的目标是： 使用 Android Things 构建一个简单的 RGB Led 控制器 使用 Android API 构建 Android IoT UI 开发 我们会使用 Raspberry Pi 3 作为 IoT 开发板,你也可以使用其他的开发板去开发 Android Things。 此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。 步骤一通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 Raspberry， 每个颜色一个，原理图如下： 共阳极 RGB LED 灯非常常见，因此 Raspberry Pi 3 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 Raspberry 引脚： Pin 29 Pin 31 Pin 33 这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。 现在，我们使用 Android Studio 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle : 123dependencies &#123; provided &apos;com.google.android.things:androidthings:0.1-devpreview&apos;&#125; Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 RGBThingsActivity 类，并在 onCreate 方法中处理 Pin 通信。 步骤二使用 GPIO 引脚与 RGB LED 传递信息。 GPIO 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。 Android Things SDK 提供了一个 PeripheralManagerService 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值： 1234567891011121314try &#123; PeripheralManagerService manager = new PeripheralManagerService(); blueIO = manager.openGpio(&quot;BCM5&quot;); blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); greenIO = manager.openGpio(&quot;BCM6&quot;); greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH); redIO = manager.openGpio(&quot;BCM13&quot;); redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); redIO.setValue(false); blueIO.setValue(false); greenIO.setValue(false);&#125; catch (IOException e) &#123; Log.w(TAG, &quot;Unable to access GPIO&quot;, e);&#125; 这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 Respberry Pin reference ,下图： 可以了解到 Respberry Pi 3 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为： 1blueIO = manager.openGpio(&quot;BCM5&quot;); 开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。 步骤三Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Switch android:text=&quot;Red&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchRed&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Green&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchGreen&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Blue&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchBlue&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;/LinearLayout&gt; 在 onCreate 方法中，我们设置 layout 布局： 123456@Overridepublic void onCreate (Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ...&#125; 处理用户开关： 1234567891011Switch switchRed = (Switch)findViewById(R.id.switchRed);switch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener()&#123; @Override public void onCheckedChanged (CompoundButton buttonView, boolean isChecked)&#123; try &#123; redIO.setValue(!isChecked); &#125; catch (IOException e) &#123; Log.w(TAG,&quot;Red GPIO Error&quot;, e); &#125; &#125;&#125;); 我们必须为其他引脚重复同一段代码。最终结果如下： 因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。 最终结果展示–需要翻墙 youtube 上观看 最后，要使用我们的应用程序，我们必须在 Manifest.xml 文件中条件： 1&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt; 并且声明我的 Activity 是一个 IoT Activity， 启动脚本为： 1234&lt;intent-filter&gt; &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;&lt;/intent-filter&gt; 总结文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。 使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.]]></content>
      <tags>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins + gradle + git 构建 Android CI 构建环境]]></title>
    <url>%2F2019%2F04%2F16%2FJenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。 目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。 然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。 因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。 对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。 对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。 CI 的基本工作流程如下： 我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。 准备工作本文使用 Linux Ubuntu 系统为大家介绍环境的搭建 环境工具1. PC 机(mac/linux) 2. Java JDK 3. Android SDK 4. Gradle 5. Git 6. Tomcat 7. Jenkins 环境搭建Java 环境 安装Java JDK, Android SDK, Gradle 可从AndroidDevTools处下载获取。 git 安装git 可通过终端进行安装123sudo add-apt-repository ppa:git-core/ppasudo apt-get updatesudo apt-get install git 安装完成之后通过git --version 检查是否成功 安装后 git 存储在 /usr/bin/git下 Jenkins通过 Jenkins 官方网站下载最新Jenkins.war包 环境变量打开 vi /etc/profile 将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq 其中环境位置根据自己的所在位置进行相应的更改 启动激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins 将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。 启动后，在浏览器中输入： localhost:8080/jenkins 插件安装系统管理-&gt; 插件管理-&gt;可选插件： 在搜索框中搜索以下插件，并进行安装 git plugingitlab plugingrade pluginAndroid Lint PluginBuild Pipeline pluginbuild timeout pluginbuild name pluginchange assembly-version plugincredentials binding plugindescription setter pluginDynamic parameter pluginEmail Extension pluginFindBugs pluginJaCoco pluginUnit attachments pluginProject Description pluginTimestamperWorkspace cleanup plugin 安装完成后，重启。 系统设置系统管理-&gt;系统设置： 配置Android 环境，将地址指向本机的 SDK 目录 系统管理-&gt;全局工具配置 配置 Java， Git ， Gradle 目录等 JDK： Git： Gradle： 到此，环境配置，已基本完成。 下面我们开始进行项目够将操作 项目构建创建Job新建-&gt;构建一个自由风格的软件项目: 参数化构建通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。 在这里我们先看看 build.gradle 中的构建信息: 在项目的 moudle 下 build.gradle 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def getDate () &#123; def date = new Date() def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;) return formattedDate&#125;def verName = APP_VERSIONdef verCode = 14android &#123; .... signingConfigs &#123; release &#123; keyAlias &apos;&apos; keyPassword &apos;&apos; storeFile file (&apos;&apos;) storePassword &apos;&apos; &#125; &#125; defaultConfig &#123; applicationId &quot;cn.zhuangbudong.example&quot; minSdkVersion 18 targetSdkVersion 25 multiDexEnabled true versionCode verCode versionName verName resValues(&quot;string&quot;, &apos;app_version&apos;, verName) &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; lintOptions &#123; abortOnError false &#125; dexOptions &#123; javaMaxHeapSize &apos;2g&apos; &#125;applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def timeNow def oldFile = output.outputFile def outDirectory = oldFile.parent if (&quot;true&quot;.equals(IS_JENKINS)) &#123; timeNow = JENKINS_TIME outDirectory = &quot;/media/nexd/work/android/package/release/&quot; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; else &#123; timeNow = getDate() if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_debug.apk&quot; &#125; else &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; &#125;&#125; gradle.properties: 123APP_VERSION=2.0.2IS_JENKINS=falseJENKINS_TIME=&apos;&apos; 在工程中添加以上代码，并在Jenkins中为这些参数赋值。 下面介绍 Jenkins 参数配置 勾选参数化构建过程，如下图： 按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致 源码管理此处负责从版本库中拉去最新的代码 此处如果需要验证，点击 Add， 选择： Username with password 在对应窗口输入用户名和密码信息 点击添加。 使用 gitlab 进行源码库管理。 触发器触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。 构建环境此处只是在Jenkins在打包时，配置任务名称即可。如下图： 构建这里是最重要滴，配置以下命令，才能进行打包签名等等。 如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。 同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。 构建后操作当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图： 12345678910111213&lt;hr/&gt;(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;项目名称：$&#123;PROJECT_NAME&#125;&lt;br/&gt;&lt;hr/&gt;构建编号：$&#123;BUILD_NUMBER&#125;&lt;br/&gt;&lt;hr/&gt;构建状态：$&#123;BUILD_STATUS&#125;&lt;br/&gt;&lt;hr/&gt;触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;hr/&gt;测试报告：&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&quot;&gt;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建地址：&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建报告：&lt;a href=&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;变更集:$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;&lt;hr/&gt; 开始构建回到 Jenkins 首页，点击创建的项目，点击 build with parameters: 点击开始构建，启动 Jenkins 构建任务。 构建成功时，显示为蓝色， 失败为红色，如下图： 构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。 谢谢~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb command]]></title>
    <url>%2F2019%2F04%2F16%2Fadb-command%2F</url>
    <content type="text"><![CDATA[查看PID 1adb shell ps 查看日志 12345全部日志adb logcat按照 PID 筛选日志adb logcat | grep &lt;PID&gt; 查询链接设备 1adb devices 重启机器 1adb reboot 杀死进程服务 1adb kill-server 重启进程服务 1adb start-server 获取机器 Mac 地址 1adb shell cat /sys/class/net/wlan0/address 安装 APK 12345678普通安装adb install &lt;file path&gt;保留数据和缓存文件adb install -r &lt;file path&gt;安装到 SD 卡上adb install -s &lt;file path&gt; 卸载 APK 12345普通卸载adb uninstall &lt;package name&gt;保留数据和缓存文件adb uninstall -k &lt;package name&gt; 启动应用 1adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt; 查看 CPU 占用率 1234567adb shell top查看内存占用前 6 的 appadb shell top -m 6刷新一次内存adb shell top -n 1 杀死进程 1adb shell kill &lt;pid&gt; 将 System 分区重新挂在为可读写分区 1adb remount 从本地复制文件到设备 1adb push &lt;local&gt; &lt;remote&gt; 从设备复制文件到本地 1adb pull &lt;remote&gt; &lt;local&gt; 查看 WiFi 密码 1adb shell cat /data/misc/wifi/*.conf 查看 bug 报告 1adb bugreport 跑 monkey 1adb shell monkey -v -p your.package.name 500 截图 1adb shell screencap -p /sdcard/screenshot.png 录屏 1adb shell screenrecord /sdcard/demo.mp4 查看安装列表 1adb shell pm list packages 安装证书 1adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer 查看内存占用 1adb shell dumpsys meminfo &lt;package&gt; -d 查询栈信息 12345adb shell dumpsys activity// 获取自己应用adb shell dumpsys activity | grep &lt;package&gt;// 获取处于栈顶的 activityadb shell dumpsys activity | grep mFocusedActivity]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sitemap]]></title>
    <url>%2Fsitemap%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
